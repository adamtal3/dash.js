{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["EventBus","Events","FactoryMaker","TimelineConverter","context","eventBus","getInstance","instance","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","initialize","resetInitialSettings","on","TIME_SYNCHRONIZATION_COMPLETED","onTimeSyncComplete","isTimeSyncCompleted","setTimeSyncCompleted","value","getClientTimeOffset","setClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","calcMSETimeOffset","reset","off","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n            voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n\n        return range;\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n\n        }\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}