{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["FactoryMaker","Constants","getTimeBasedSegment","TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getSegmentsFromTimeline","representation","requestedTime","index","availabilityUpperLimit","undefined","base","adaptation","period","mpd","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","isAvailableSegmentNumberCalculated","availableSegmentsNumber","maxSegmentsAhead","Infinity","time","scaledTime","availabilityIdx","segments","requiredMediaTime","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","hasEnoughSegments","startIdx","fTimescale","createSegment","s","media","mediaRange","d","tManifest","timescale","S_asArray","calcMediaTimeFromPresentationTime","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","segmentDuration","Math","ceil","push","getSegments","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"TimelineSegmentsGetter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Constants from '../../streaming/constants/Constants';\n\nimport {getTimeBasedSegment} from './SegmentsUtils';\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n\n    config = config || {};\n    const timelineConverter = config.timelineConverter;\n\n    let instance;\n\n    function checkConfig() {\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getSegmentsFromTimeline(representation, requestedTime, index, availabilityUpperLimit) {\n        checkConfig();\n\n        if (!representation) {\n            throw new Error('no representation');\n        }\n\n        if (requestedTime === undefined) {\n            requestedTime = null;\n        }\n\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n        const timeline = base.SegmentTimeline;\n        const list = base.SegmentURL_asArray;\n        const isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0;\n\n        let maxSegmentsAhead;\n\n        if (availabilityUpperLimit) {\n            maxSegmentsAhead = availabilityUpperLimit;\n        } else {\n            maxSegmentsAhead = (index > -1 || requestedTime !== null) ? 10 : Infinity;\n        }\n\n        let time = 0;\n        let scaledTime = 0;\n        let availabilityIdx = -1;\n        const segments = [];\n        let requiredMediaTime = null;\n\n        let fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            hasEnoughSegments,\n            startIdx,\n            fTimescale;\n\n        let createSegment = function (s, i) {\n            let media = base.media;\n            let mediaRange = s.mediaRange;\n\n            if (list) {\n                media = list[i].media || '';\n                mediaRange = list[i].mediaRange;\n            }\n\n            return getTimeBasedSegment(\n                timelineConverter,\n                isDynamic,\n                representation,\n                time,\n                s.d,\n                fTimescale,\n                media,\n                mediaRange,\n                availabilityIdx,\n                s.tManifest);\n        };\n\n        fTimescale = representation.timescale;\n\n        fragments = timeline.S_asArray;\n\n        startIdx = index;\n\n        if (requestedTime !== null) {\n            requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n        }\n\n        for (i = 0, len = fragments.length; i < len; i++) {\n            frag = fragments[i];\n            repeat = 0;\n            if (frag.hasOwnProperty('r')) {\n                repeat = frag.r;\n            }\n\n            // For a repeated S element, t belongs only to the first segment\n            if (frag.hasOwnProperty('t')) {\n                time = frag.t;\n                scaledTime = time / fTimescale;\n            }\n\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n            // next MPD update.\"\n            if (repeat < 0) {\n                nextFrag = fragments[i + 1];\n\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\n                    repeatEndTime = nextFrag.t / fTimescale;\n                } else {\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n                    representation.segmentDuration = frag.d / fTimescale;\n                }\n\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n            }\n\n            // if we have enough segments in the list, but we have not calculated the total number of the segments yet we\n            // should continue the loop and calc the number. Once it is calculated, we can break the loop.\n            if (hasEnoughSegments) {\n                if (isAvailableSegmentNumberCalculated) break;\n                availabilityIdx += repeat + 1;\n                continue;\n            }\n\n            for (j = 0; j <= repeat; j++) {\n                availabilityIdx++;\n\n                if (segments.length > maxSegmentsAhead) {\n                    hasEnoughSegments = true;\n                    if (isAvailableSegmentNumberCalculated) break;\n                    continue;\n                }\n\n                if (requiredMediaTime !== null) {\n                    // In some cases when requiredMediaTime = actual end time of the last segment\n                    // it is possible that this time a bit exceeds the declared end time of the last segment.\n                    // in this case we still need to include the last segment in the segment list. to do this we\n                    // use a correction factor = 1.5. This number is used because the largest possible deviation is\n                    // is 50% of segment duration.\n                    if (scaledTime >= (requiredMediaTime - (frag.d / fTimescale) * 1.5)) {\n                        segments.push(createSegment(frag, availabilityIdx));\n                    }\n                } else if (availabilityIdx >= startIdx) {\n                    segments.push(createSegment(frag, availabilityIdx));\n                }\n\n                time += frag.d;\n                scaledTime = time / fTimescale;\n            }\n        }\n\n        if (!isAvailableSegmentNumberCalculated) {\n            representation.availableSegmentsNumber = availabilityIdx + 1;\n        }\n\n        return segments;\n    }\n\n    instance = {\n        getSegments: getSegmentsFromTimeline\n    };\n\n    return instance;\n}\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\nexport default factory;\n"]}