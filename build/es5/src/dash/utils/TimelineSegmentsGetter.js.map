{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["FactoryMaker","Constants","getTimeBasedSegment","TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getSegmentsFromTimeline","representation","requestedTime","index","availabilityUpperLimit","undefined","base","adaptation","period","mpd","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","isAvailableSegmentNumberCalculated","availableSegmentsNumber","maxSegmentsAhead","Infinity","time","scaledTime","availabilityIdx","segments","requiredMediaTime","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","hasEnoughSegments","startIdx","fTimescale","createSegment","s","media","mediaRange","d","tManifest","timescale","S_asArray","calcMediaTimeFromPresentationTime","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","segmentDuration","Math","ceil","push","getSegments","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"TimelineSegmentsGetter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Constants from '../../streaming/constants/Constants';\n\nimport {getTimeBasedSegment} from './SegmentsUtils';\n\nfunction TimelineSegmentsGetter(config, isDynamic) {\n\n    config = config || {};\n    const timelineConverter = config.timelineConverter;\n\n    let instance;\n\n    function checkConfig() {\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    function getSegmentsFromTimeline(representation, requestedTime, index, availabilityUpperLimit) {\n        checkConfig();\n\n        if (!representation) {\n            throw new Error('no representation');\n        }\n\n        if (requestedTime === undefined) {\n            requestedTime = null;\n        }\n\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\n        const timeline = base.SegmentTimeline;\n        const list = base.SegmentURL_asArray;\n        const isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0;\n\n        let maxSegmentsAhead;\n\n        if (availabilityUpperLimit) {\n            maxSegmentsAhead = availabilityUpperLimit;\n        } else {\n            maxSegmentsAhead = (index > -1 || requestedTime !== null) ? 10 : Infinity;\n        }\n\n        let time = 0;\n        let scaledTime = 0;\n        let availabilityIdx = -1;\n        const segments = [];\n        let requiredMediaTime = null;\n\n        let fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            hasEnoughSegments,\n            startIdx,\n            fTimescale;\n\n        let createSegment = function (s, i) {\n            let media = base.media;\n            let mediaRange = s.mediaRange;\n\n            if (list) {\n                media = list[i].media || '';\n                mediaRange = list[i].mediaRange;\n            }\n\n            return getTimeBasedSegment(\n                timelineConverter,\n                isDynamic,\n                representation,\n                time,\n                s.d,\n                fTimescale,\n                media,\n                mediaRange,\n                availabilityIdx,\n                s.tManifest);\n        };\n\n        fTimescale = representation.timescale;\n\n        fragments = timeline.S_asArray;\n\n        startIdx = index;\n\n        if (requestedTime !== null) {\n            requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\n        }\n\n        for (i = 0, len = fragments.length; i < len; i++) {\n            frag = fragments[i];\n            repeat = 0;\n            if (frag.hasOwnProperty('r')) {\n                repeat = frag.r;\n            }\n\n            // For a repeated S element, t belongs only to the first segment\n            if (frag.hasOwnProperty('t')) {\n                time = frag.t;\n                scaledTime = time / fTimescale;\n            }\n\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n            // next MPD update.\"\n            if (repeat < 0) {\n                nextFrag = fragments[i + 1];\n\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\n                    repeatEndTime = nextFrag.t / fTimescale;\n                } else {\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\n                    representation.segmentDuration = frag.d / fTimescale;\n                }\n\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\n            }\n\n            // if we have enough segments in the list, but we have not calculated the total number of the segments yet we\n            // should continue the loop and calc the number. Once it is calculated, we can break the loop.\n            if (hasEnoughSegments) {\n                if (isAvailableSegmentNumberCalculated) break;\n                availabilityIdx += repeat + 1;\n                continue;\n            }\n\n            for (j = 0; j <= repeat; j++) {\n                availabilityIdx++;\n\n                if (segments.length > maxSegmentsAhead) {\n                    hasEnoughSegments = true;\n                    if (isAvailableSegmentNumberCalculated) break;\n                    continue;\n                }\n\n                if (requiredMediaTime !== null) {\n                    // In some cases when requiredMediaTime = actual end time of the last segment\n                    // it is possible that this time a bit exceeds the declared end time of the last segment.\n                    // in this case we still need to include the last segment in the segment list. to do this we\n                    // use a correction factor = 1.5. This number is used because the largest possible deviation is\n                    // is 50% of segment duration.\n                    if (scaledTime >= (requiredMediaTime - (frag.d / fTimescale) * 1.5)) {\n                        segments.push(createSegment(frag, availabilityIdx));\n                    }\n                } else if (availabilityIdx >= startIdx) {\n                    segments.push(createSegment(frag, availabilityIdx));\n                }\n\n                time += frag.d;\n                scaledTime = time / fTimescale;\n            }\n        }\n\n        if (!isAvailableSegmentNumberCalculated) {\n            representation.availableSegmentsNumber = availabilityIdx + 1;\n        }\n\n        return segments;\n    }\n\n    instance = {\n        getSegments: getSegmentsFromTimeline\n    };\n\n    return instance;\n}\n\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\nexport default factory;\n"]}