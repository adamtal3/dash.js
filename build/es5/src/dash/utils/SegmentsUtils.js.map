{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["Segment","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","unescapeDollarsInTemplate","url","split","join","replaceIDForTemplate","value","indexOf","v","toString","replaceTokenForTemplate","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","getIndexBasedSegment","timelineConverter","isDynamic","index","seg","duration","presentationStartTime","presentationEndTime","segmentDuration","isNaN","adaptation","period","parseFloat","start","toFixed","mediaStartTime","calcMediaTimeFromPresentationTime","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","getTimeBasedSegment","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange","getSegmentByIndex","segments","ln","i","decideSegmentListRangeForTemplate","requestedTime","givenAvailabilityUpperLimit","minBufferTime","availabilityWindow","segmentAvailabilityRange","periodRelativeRange","calcPeriodRelativeTimeFromMpdRelativeTime","NaN","end","currentSegmentList","availabilityLowerLimit","availabilityUpperLimit","max","originAvailabilityTime","originSegment","isTimeSyncCompleted","floor"],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) { return url; }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let seg,\n        duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n\n    seg.mediaStartTime = timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\n\n    seg.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = scaledDuration;\n    seg.mediaStartTime = scaledTime;\n\n    seg.presentationStartTime = presentationStartTime;\n\n    // For SegmentTimeline every segment is available at loadedTime\n    seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.loadedTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getSegmentByIndex(index, representation) {\n    if (!representation || !representation.segments) return null;\n\n    const ln = representation.segments.length;\n    let seg,\n        i;\n\n    if (index < ln) {\n        seg = representation.segments[index];\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    for (i = 0; i < ln; i++) {\n        seg = representation.segments[i];\n\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    return null;\n}\n\nexport function decideSegmentListRangeForTemplate(timelineConverter, isDynamic, representation, requestedTime, index, givenAvailabilityUpperLimit) {\n    const duration = representation.segmentDuration;\n    const minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime;\n    const availabilityWindow = representation.segmentAvailabilityRange;\n    let periodRelativeRange = {\n        start: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.start : NaN),\n        end: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.end : NaN)\n    };\n    const currentSegmentList = representation.segments;\n    const availabilityLowerLimit = 2 * duration;\n    const availabilityUpperLimit = givenAvailabilityUpperLimit || Math.max(2 * minBufferTime, 10 * duration);\n    let originAvailabilityTime = NaN;\n    let originSegment = null;\n\n    let start,\n        end,\n        range;\n\n    periodRelativeRange.start = Math.max(periodRelativeRange.start, 0);\n\n    if (isDynamic && !timelineConverter.isTimeSyncCompleted()) {\n        start = Math.floor(periodRelativeRange.start / duration);\n        end = Math.floor(periodRelativeRange.end / duration);\n        range = {start: start, end: end};\n        return range;\n    }\n\n    // if segments exist we should try to find the latest buffered time, which is the presentation time of the\n    // segment for the current index\n    if (currentSegmentList && currentSegmentList.length > 0) {\n        originSegment = getSegmentByIndex(index, representation);\n        if (originSegment) {\n            originAvailabilityTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, originSegment.presentationStartTime);\n        } else {\n            originAvailabilityTime = index > 0 ? index * duration :\n                timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, requestedTime);\n        }\n\n    } else {\n        // If no segments exist, but index > 0, it means that we switch to the other representation, so\n        // we should proceed from this time.\n        // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n        originAvailabilityTime = index > 0 ? index * duration : isDynamic ? periodRelativeRange.end : periodRelativeRange.start;\n    }\n\n    // segment list should not be out of the availability window range\n    start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, periodRelativeRange.start) / duration);\n    end = Math.floor(Math.min(start + availabilityUpperLimit / duration, periodRelativeRange.end / duration));\n\n    range = {start: start, end: end};\n\n    return range;\n}\n"]}