{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["Segment","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","unescapeDollarsInTemplate","url","split","join","replaceIDForTemplate","value","indexOf","v","toString","replaceTokenForTemplate","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","getIndexBasedSegment","timelineConverter","isDynamic","index","seg","duration","presentationStartTime","presentationEndTime","segmentDuration","isNaN","adaptation","period","parseFloat","start","toFixed","mediaStartTime","calcMediaTimeFromPresentationTime","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","getTimeBasedSegment","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange","getSegmentByIndex","segments","ln","i","decideSegmentListRangeForTemplate","requestedTime","givenAvailabilityUpperLimit","minBufferTime","availabilityWindow","segmentAvailabilityRange","periodRelativeRange","calcPeriodRelativeTimeFromMpdRelativeTime","NaN","end","currentSegmentList","availabilityLowerLimit","availabilityUpperLimit","max","originAvailabilityTime","originSegment","isTimeSyncCompleted","floor"],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) { return url; }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let seg,\n        duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n\n    seg.mediaStartTime = timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\n\n    seg.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = scaledDuration;\n    seg.mediaStartTime = scaledTime;\n\n    seg.presentationStartTime = presentationStartTime;\n\n    // For SegmentTimeline every segment is available at loadedTime\n    seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.loadedTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getSegmentByIndex(index, representation) {\n    if (!representation || !representation.segments) return null;\n\n    const ln = representation.segments.length;\n    let seg,\n        i;\n\n    if (index < ln) {\n        seg = representation.segments[index];\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    for (i = 0; i < ln; i++) {\n        seg = representation.segments[i];\n\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    return null;\n}\n\nexport function decideSegmentListRangeForTemplate(timelineConverter, isDynamic, representation, requestedTime, index, givenAvailabilityUpperLimit) {\n    const duration = representation.segmentDuration;\n    const minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime;\n    const availabilityWindow = representation.segmentAvailabilityRange;\n    let periodRelativeRange = {\n        start: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.start : NaN),\n        end: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.end : NaN)\n    };\n    const currentSegmentList = representation.segments;\n    const availabilityLowerLimit = 2 * duration;\n    const availabilityUpperLimit = givenAvailabilityUpperLimit || Math.max(2 * minBufferTime, 10 * duration);\n    let originAvailabilityTime = NaN;\n    let originSegment = null;\n\n    let start,\n        end,\n        range;\n\n    periodRelativeRange.start = Math.max(periodRelativeRange.start, 0);\n\n    if (isDynamic && !timelineConverter.isTimeSyncCompleted()) {\n        start = Math.floor(periodRelativeRange.start / duration);\n        end = Math.floor(periodRelativeRange.end / duration);\n        range = {start: start, end: end};\n        return range;\n    }\n\n    // if segments exist we should try to find the latest buffered time, which is the presentation time of the\n    // segment for the current index\n    if (currentSegmentList && currentSegmentList.length > 0) {\n        originSegment = getSegmentByIndex(index, representation);\n        if (originSegment) {\n            originAvailabilityTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, originSegment.presentationStartTime);\n        } else {\n            originAvailabilityTime = index > 0 ? index * duration :\n                timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, requestedTime);\n        }\n\n    } else {\n        // If no segments exist, but index > 0, it means that we switch to the other representation, so\n        // we should proceed from this time.\n        // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n        originAvailabilityTime = index > 0 ? index * duration : isDynamic ? periodRelativeRange.end : periodRelativeRange.start;\n    }\n\n    // segment list should not be out of the availability window range\n    start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, periodRelativeRange.start) / duration);\n    end = Math.floor(Math.min(start + availabilityUpperLimit / duration, periodRelativeRange.end / duration));\n\n    range = {start: start, end: end};\n\n    return range;\n}\n"]}