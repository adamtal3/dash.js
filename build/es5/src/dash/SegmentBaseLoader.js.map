{"version":3,"sources":["../../../../src/dash/SegmentBaseLoader.js"],"names":["RequestModifier","Segment","DashJSError","Events","EventBus","BoxParser","FactoryMaker","Debug","HTTPRequest","FragmentRequest","HTTPLoader","Errors","SegmentBaseLoader","context","eventBus","getInstance","instance","logger","errHandler","boxParser","requestModifier","metricsModel","mediaPlayerModel","httpLoader","baseURLController","setup","getLogger","initialize","create","setConfig","config","checkSetConfigCall","hasOwnProperty","Error","loadInitialization","representation","loadingInfo","initRange","baseUrl","resolve","path","info","init","url","undefined","range","start","end","searching","bytesLoaded","bytesToLoad","debug","request","getFragmentRequest","onload","response","findInitRange","trigger","INITIALIZATION_LOADED","onerror","load","success","error","loadSegments","type","callback","parts","toString","split","parseFloat","onLoaded","isoFile","sidx","hasRange","extraBytes","loadedLength","byteLength","parse","getBox","isComplete","offset","size","lastBox","getLastBox","ref","references","loadMultiSidx","segments","length","reference_type","j","len","ss","se","r","segs","count","tmpCallback","result","concat","referenced_size","getSegmentsForSidx","reset","abort","refs","timescale","time","earliest_presentation_time","first_offset","segment","duration","i","subsegment_duration","startTime","mediaRange","push","INIT_SEGMENT_TYPE","MEDIA_SEGMENT_TYPE","SEGMENTS_LOADED","mediaType","SEGMENT_BASE_LOADER_ERROR_CODE","SEGMENT_BASE_LOADER_ERROR_MESSAGE","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"SegmentBaseLoader.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport RequestModifier from '../streaming/utils/RequestModifier';\nimport Segment from './vo/Segment';\nimport DashJSError from '../streaming/vo/DashJSError';\nimport Events from '../core/events/Events';\nimport EventBus from '../core/EventBus';\nimport BoxParser from '../streaming/utils/BoxParser';\nimport FactoryMaker from '../core/FactoryMaker';\nimport Debug from '../core/Debug';\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport HTTPLoader from '../streaming/net/HTTPLoader';\nimport Errors from '../core/errors/Errors';\n\nfunction SegmentBaseLoader() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        errHandler,\n        boxParser,\n        requestModifier,\n        metricsModel,\n        mediaPlayerModel,\n        httpLoader,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize() {\n        boxParser = BoxParser(context).getInstance();\n        requestModifier = RequestModifier(context).getInstance();\n        httpLoader = HTTPLoader(context).create({\n            errHandler: errHandler,\n            metricsModel: metricsModel,\n            mediaPlayerModel: mediaPlayerModel,\n            requestModifier: requestModifier\n        });\n    }\n\n    function setConfig(config) {\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n    }\n\n    function checkSetConfigCall() {\n        if (!baseURLController || !baseURLController.hasOwnProperty('resolve')) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    function loadInitialization(representation, loadingInfo) {\n        checkSetConfigCall();\n        let initRange = null;\n        const baseUrl = baseURLController.resolve(representation.path);\n        const info = loadingInfo || {\n            init: true,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: {\n                start: 0,\n                end: 1500\n            },\n            searching: false,\n            bytesLoaded: 0,\n            bytesToLoad: 1500\n        };\n\n        logger.debug('Start searching for initialization.');\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            info.bytesLoaded = info.range.end;\n            initRange = boxParser.findInitRange(response);\n\n            if (initRange) {\n                representation.range = initRange;\n                // note that we don't explicitly set rep.initialization as this\n                // will be computed when all BaseURLs are resolved later\n                eventBus.trigger(Events.INITIALIZATION_LOADED, {representation: representation});\n            } else {\n                info.range.end = info.bytesLoaded + info.bytesToLoad;\n                loadInitialization(representation, info);\n            }\n\n        };\n\n        const onerror = function () {\n            eventBus.trigger(Events.INITIALIZATION_LOADED, {representation: representation});\n        };\n\n        httpLoader.load({request: request, success: onload, error: onerror});\n\n        logger.debug('Perform init search: ' + info.url);\n    }\n\n    function loadSegments(representation, type, range, loadingInfo, callback) {\n        checkSetConfigCall();\n        if (range && (range.start === undefined || range.end === undefined)) {\n            const parts = range ? range.toString().split('-') : null;\n            range = parts ? {start: parseFloat(parts[0]), end: parseFloat(parts[1])} : null;\n        }\n\n        callback = !callback ? onLoaded : callback;\n        let isoFile = null;\n        let sidx = null;\n        const hasRange = !!range;\n        const baseUrl = baseURLController.resolve(representation.path);\n        const info = {\n            init: false,\n            url: baseUrl ? baseUrl.url : undefined,\n            range: hasRange ? range : { start: 0, end: 1500 },\n            searching: !hasRange,\n            bytesLoaded: loadingInfo ? loadingInfo.bytesLoaded : 0,\n            bytesToLoad: 1500\n        };\n\n        const request = getFragmentRequest(info);\n\n        const onload = function (response) {\n            const extraBytes = info.bytesToLoad;\n            const loadedLength = response.byteLength;\n\n            info.bytesLoaded = info.range.end - info.range.start;\n            isoFile = boxParser.parse(response);\n            sidx = isoFile.getBox('sidx');\n\n            if (!sidx || !sidx.isComplete) {\n                if (sidx) {\n                    info.range.start = sidx.offset || info.range.start;\n                    info.range.end = info.range.start + (sidx.size || extraBytes);\n                } else if (loadedLength < info.bytesLoaded) {\n                    // if we have reached a search limit or if we have reached the end of the file we have to stop trying to find sidx\n                    callback(null, representation, type);\n                    return;\n                } else {\n                    const lastBox = isoFile.getLastBox();\n\n                    if (lastBox && lastBox.size) {\n                        info.range.start = lastBox.offset + lastBox.size;\n                        info.range.end = info.range.start + extraBytes;\n                    } else {\n                        info.range.end += extraBytes;\n                    }\n                }\n                loadSegments(representation, type, info.range, info, callback);\n            } else {\n                const ref = sidx.references;\n                let loadMultiSidx,\n                    segments;\n\n                if (ref !== null && ref !== undefined && ref.length > 0) {\n                    loadMultiSidx = (ref[0].reference_type === 1);\n                }\n\n                if (loadMultiSidx) {\n                    logger.debug('Initiate multiple SIDX load.');\n                    info.range.end = info.range.start + sidx.size;\n\n                    let j, len, ss, se, r;\n                    let segs = [];\n                    let count = 0;\n                    let offset = (sidx.offset || info.range.start) + sidx.size;\n                    const tmpCallback = function (result) {\n                        if (result) {\n                            segs = segs.concat(result);\n                            count++;\n\n                            if (count >= len) {\n                                callback(segs, representation, type);\n                            }\n                        } else {\n                            callback(null, representation, type);\n                        }\n                    };\n\n                    for (j = 0, len = ref.length; j < len; j++) {\n                        ss = offset;\n                        se = offset + ref[j].referenced_size - 1;\n                        offset = offset + ref[j].referenced_size;\n                        r = {start: ss, end: se};\n                        loadSegments(representation, null, r, info, tmpCallback);\n                    }\n\n                } else {\n                    logger.debug('Parsing segments from SIDX.');\n                    segments = getSegmentsForSidx(sidx, info);\n                    callback(segments, representation, type);\n                }\n            }\n        };\n\n        const onerror = function () {\n            callback(null, representation, type);\n        };\n\n        httpLoader.load({request: request, success: onload, error: onerror});\n        logger.debug('Perform SIDX load: ' + info.url);\n    }\n\n    function reset() {\n        httpLoader.abort();\n        httpLoader = null;\n        errHandler = null;\n        boxParser = null;\n        requestModifier = null;\n    }\n\n    function getSegmentsForSidx(sidx, info) {\n        const refs = sidx.references;\n        const len = refs.length;\n        const timescale = sidx.timescale;\n        let time = sidx.earliest_presentation_time;\n        let start = info.range.start + sidx.offset + sidx.first_offset + sidx.size;\n        const segments = [];\n        let segment,\n            end,\n            duration,\n            size;\n\n        for (let i = 0; i < len; i++) {\n            duration = refs[i].subsegment_duration;\n            size = refs[i].referenced_size;\n\n            segment = new Segment();\n            // note that we don't explicitly set segment.media as this will be\n            // computed when all BaseURLs are resolved later\n            segment.duration = duration;\n            segment.startTime = time;\n            segment.timescale = timescale;\n            end = start + size - 1;\n            segment.mediaRange = start + '-' + end;\n            segments.push(segment);\n            time += duration;\n            start += size;\n        }\n\n        return segments;\n    }\n\n    function getFragmentRequest(info) {\n        if (!info.url) {\n            return;\n        }\n\n        const request = new FragmentRequest();\n        request.type = info.init ? HTTPRequest.INIT_SEGMENT_TYPE : HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.url = info.url;\n        request.range = info.range.start + '-' + info.range.end;\n\n        return request;\n    }\n\n    function onLoaded(segments, representation, type) {\n        if (segments) {\n            eventBus.trigger(Events.SEGMENTS_LOADED, {segments: segments, representation: representation, mediaType: type});\n        } else {\n            eventBus.trigger(Events.SEGMENTS_LOADED, {segments: null, representation: representation, mediaType: type, error: new DashJSError(Errors.SEGMENT_BASE_LOADER_ERROR_CODE, Errors.SEGMENT_BASE_LOADER_ERROR_MESSAGE)});\n        }\n    }\n\n    instance = {\n        setConfig: setConfig,\n        initialize: initialize,\n        loadInitialization: loadInitialization,\n        loadSegments: loadSegments,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nSegmentBaseLoader.__dashjs_factory_name = 'SegmentBaseLoader';\nexport default FactoryMaker.getSingletonFactory(SegmentBaseLoader);\n"]}