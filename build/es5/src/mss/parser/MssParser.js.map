{"version":3,"sources":["../../../../../src/mss/parser/MssParser.js"],"names":["MssParser","config","BASE64","debug","constants","manifestModel","DEFAULT_TIME_SCALE","SUPPORTED_CODECS","ROLE","ACCESSIBILITY","samplingFrequencyIndex","mimeTypeMap","instance","logger","mediaPlayerModel","setup","getLogger","mapPeriod","smoothStreamingMedia","timescale","period","streams","adaptation","AdaptationSet_asArray","getElementsByTagName","i","length","mapAdaptationSet","push","AdaptationSet","streamIndex","adaptationSet","representations","segmentTemplate","qualityLevels","representation","segments","id","getAttribute","contentType","lang","mimeType","subType","maxWidth","maxHeight","role","schemeIdUri","value","Role","Role_asArray","accessibility","Accessibility","Accessibility_asArray","mapSegmentTemplate","BaseURL","Id","mapRepresentation","SegmentTemplate","Representation","Representation_asArray","SegmentTimeline","S_asArray","qualityLevel","type","fourCCValue","bandwidth","parseInt","width","height","indexOf","toUpperCase","warn","codecs","getH264Codec","getAACCodec","audioSamplingRate","audioChannels","STPP","codecPrivateData","toString","nalHeader","avcoti","exec","substr","undefined","samplingRate","objectType","codecPrivateDataHex","arr16","indexFreq","extensionSamplingFrequencyIndex","Uint8Array","Channels","Uint16Array","setAttribute","mediaUrl","streamIndexTimeScale","replace","parseFloat","media","mapSegmentTimeline","segmentTimeline","chunks","segment","prevSegment","tManifest","j","r","duration","t","d","S","getKIDFromProtectionHeader","protectionHeader","prHeader","wrmHeader","xmlReader","KID","decodeArray","firstChild","data","getWRMHeaderFromPRHeader","buffer","String","fromCharCode","apply","DOMParser","parseFromString","querySelector","textContent","convertUuidEndianness","recordCount","recordType","recordLength","recordValue","set","subarray","uuid","swapBytes","bytes","pos1","pos2","temp","createPRContentProtection","pro","__text","__prefix","pro_asArray","createWidevineContentProtection","wvCencHeader","pssh","encodeASCII","processManifest","xmlDoc","manifestLoadedTime","manifest","contentProtections","protection","adaptations","contentProtection","timestampOffset","startTime","protocol","profiles","dvrWindowLength","Infinity","timeShiftBufferDepth","mediaPresentationDuration","minBufferTime","getStableBufferTime","ttmlTimeIsRelative","availabilityStartTime","Date","getTime","refreshManifestOnSwitchTrack","doNotUpdateDVRWindowOnBufferUpdated","ignorePostponeTimePeriod","Period","Period_asArray","start","ContentProtection","ContentProtection_asArray","initialization","prevManifest","getValue","Math","min","max","presentationTimeOffset","floor","parseDOM","window","parser","Error","getMatchers","getIron","internalParse","performance","now","xmlParseTime","mss2dashTime","info","toPrecision","parse","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;;AAIA,SAASA,SAAT,CAAmBC,MAAnB,EAA2B;AACvBA,aAASA,UAAU,EAAnB;AACA,UAAMC,SAASD,OAAOC,MAAtB;AACA,UAAMC,QAAQF,OAAOE,KAArB;AACA,UAAMC,YAAYH,OAAOG,SAAzB;AACA,UAAMC,gBAAgBJ,OAAOI,aAA7B;;AAEA,UAAMC,qBAAqB,UAA3B;AACA,UAAMC,mBAAmB,CAAC,KAAD,EAAQ,MAAR,EAAgB,MAAhB,EAAwB,MAAxB,EAAgC,MAAhC,EAAwC,MAAxC,CAAzB;AACA;AACA,UAAMC,OAAO;AACT,gBAAQ,WADC;AAET,gBAAQ,WAFC,EAEY;AACrB,gBAAQ;AAHC,KAAb;AAKA,UAAMC,gBAAgB;AAClB,gBAAQ;AADU,KAAtB;AAGA,UAAMC,yBAAyB;AAC3B,eAAO,GADoB;AAE3B,eAAO,GAFoB;AAG3B,eAAO,GAHoB;AAI3B,eAAO,GAJoB;AAK3B,eAAO,GALoB;AAM3B,eAAO,GANoB;AAO3B,eAAO,GAPoB;AAQ3B,eAAO,GARoB;AAS3B,eAAO,GAToB;AAU3B,eAAO,GAVoB;AAW3B,eAAO,GAXoB;AAY3B,cAAM,GAZqB;AAa3B,cAAM;AAbqB,KAA/B;AAeA,UAAMC,cAAc;AAChB,iBAAS,WADO;AAEhB,iBAAS,WAFO;AAGhB,gBAAQ;AAHQ,KAApB;;AAMA,QAAIC,QAAJ,EACIC,MADJ,EAEIC,gBAFJ;;AAKA,aAASC,KAAT,GAAiB;AACbF,iBAASV,MAAMa,SAAN,CAAgBJ,QAAhB,CAAT;AACAE,2BAAmBb,OAAOa,gBAA1B;AACH;;AAED,aAASG,SAAT,CAAmBC,oBAAnB,EAAyCC,SAAzC,EAAoD;AAChD,cAAMC,SAAS,EAAf;AACA,YAAIC,OAAJ,EACIC,UADJ;;AAGA;AACAF,eAAOG,qBAAP,GAA+B,EAA/B;AACAF,kBAAUH,qBAAqBM,oBAArB,CAA0C,aAA1C,CAAV;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIJ,QAAQK,MAA5B,EAAoCD,GAApC,EAAyC;AACrCH,yBAAaK,iBAAiBN,QAAQI,CAAR,CAAjB,EAA6BN,SAA7B,CAAb;AACA,gBAAIG,eAAe,IAAnB,EAAyB;AACrBF,uBAAOG,qBAAP,CAA6BK,IAA7B,CAAkCN,UAAlC;AACH;AACJ;;AAED,YAAIF,OAAOG,qBAAP,CAA6BG,MAA7B,GAAsC,CAA1C,EAA6C;AACzCN,mBAAOS,aAAP,GAAwBT,OAAOG,qBAAP,CAA6BG,MAA7B,GAAsC,CAAvC,GAA4CN,OAAOG,qBAAnD,GAA2EH,OAAOG,qBAAP,CAA6B,CAA7B,CAAlG;AACH;;AAED,eAAOH,MAAP;AACH;;AAED,aAASO,gBAAT,CAA0BG,WAA1B,EAAuCX,SAAvC,EAAkD;AAC9C,cAAMY,gBAAgB,EAAtB;AACA,cAAMC,kBAAkB,EAAxB;AACA,YAAIC,eAAJ;AACA,YAAIC,aAAJ,EACIC,cADJ,EAEIC,QAFJ,EAGIX,CAHJ;;AAKAM,sBAAcM,EAAd,GAAmBP,YAAYQ,YAAZ,CAAyB,MAAzB,IAAmCR,YAAYQ,YAAZ,CAAyB,MAAzB,CAAnC,GAAsER,YAAYQ,YAAZ,CAAyB,MAAzB,CAAzF;AACAP,sBAAcQ,WAAd,GAA4BT,YAAYQ,YAAZ,CAAyB,MAAzB,CAA5B;AACAP,sBAAcS,IAAd,GAAqBV,YAAYQ,YAAZ,CAAyB,UAAzB,KAAwC,KAA7D;AACAP,sBAAcU,QAAd,GAAyB9B,YAAYoB,cAAcQ,WAA1B,CAAzB;AACAR,sBAAcW,OAAd,GAAwBZ,YAAYQ,YAAZ,CAAyB,SAAzB,CAAxB;AACAP,sBAAcY,QAAd,GAAyBb,YAAYQ,YAAZ,CAAyB,UAAzB,CAAzB;AACAP,sBAAca,SAAd,GAA0Bd,YAAYQ,YAAZ,CAAyB,WAAzB,CAA1B;;AAEA;AACA,YAAIP,cAAcW,OAAlB,EAA2B;AACvB,gBAAIlC,KAAKuB,cAAcW,OAAnB,CAAJ,EAAiC;AAC7B,oBAAIG,OAAO;AACPC,iCAAa,yBADN;AAEPC,2BAAOvC,KAAKuB,cAAcW,OAAnB;AAFA,iBAAX;AAIAX,8BAAciB,IAAd,GAAqBH,IAArB;AACAd,8BAAckB,YAAd,GAA6B,CAACJ,IAAD,CAA7B;AACH;AACD,gBAAIpC,cAAcsB,cAAcW,OAA5B,CAAJ,EAA0C;AACtC,oBAAIQ,gBAAgB;AAChBJ,iCAAa,yCADG;AAEhBC,2BAAOtC,cAAcsB,cAAcW,OAA5B;AAFS,iBAApB;AAIAX,8BAAcoB,aAAd,GAA8BD,aAA9B;AACAnB,8BAAcqB,qBAAd,GAAsC,CAACF,aAAD,CAAtC;AACH;AACJ;;AAED;AACAjB,0BAAkBoB,mBAAmBvB,WAAnB,EAAgCX,SAAhC,CAAlB;;AAEAe,wBAAgBJ,YAAYN,oBAAZ,CAAiC,cAAjC,CAAhB;AACA;AACA,aAAKC,IAAI,CAAT,EAAYA,IAAIS,cAAcR,MAA9B,EAAsCD,GAAtC,EAA2C;AACvC;AACAS,0BAAcT,CAAd,EAAiB6B,OAAjB,GAA2BvB,cAAcuB,OAAzC;AACApB,0BAAcT,CAAd,EAAiBgB,QAAjB,GAA4BV,cAAcU,QAA1C;;AAEA;AACAP,0BAAcT,CAAd,EAAiB8B,EAAjB,GAAsBxB,cAAcM,EAAd,GAAmB,GAAnB,GAAyBH,cAAcT,CAAd,EAAiBa,YAAjB,CAA8B,OAA9B,CAA/C;;AAEA;AACAH,6BAAiBqB,kBAAkBtB,cAAcT,CAAd,CAAlB,EAAoCK,WAApC,CAAjB;;AAEA,gBAAIK,mBAAmB,IAAvB,EAA6B;AACzB;AACAA,+BAAesB,eAAf,GAAiCxB,eAAjC;;AAEAD,gCAAgBJ,IAAhB,CAAqBO,cAArB;AACH;AACJ;;AAED,YAAIH,gBAAgBN,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B,mBAAO,IAAP;AACH;;AAEDK,sBAAc2B,cAAd,GAAgC1B,gBAAgBN,MAAhB,GAAyB,CAA1B,GAA+BM,eAA/B,GAAiDA,gBAAgB,CAAhB,CAAhF;AACAD,sBAAc4B,sBAAd,GAAuC3B,eAAvC;;AAEA;AACAD,sBAAc0B,eAAd,GAAgCxB,eAAhC;;AAEAG,mBAAWH,gBAAgB2B,eAAhB,CAAgCC,SAA3C;;AAEA,eAAO9B,aAAP;AACH;;AAED,aAASyB,iBAAT,CAA2BM,YAA3B,EAAyChC,WAAzC,EAAsD;AAClD,cAAMK,iBAAiB,EAAvB;AACA,cAAM4B,OAAOjC,YAAYQ,YAAZ,CAAyB,MAAzB,CAAb;AACA,YAAI0B,cAAc,IAAlB;;AAEA7B,uBAAeE,EAAf,GAAoByB,aAAaP,EAAjC;AACApB,uBAAe8B,SAAf,GAA2BC,SAASJ,aAAaxB,YAAb,CAA0B,SAA1B,CAAT,EAA+C,EAA/C,CAA3B;AACAH,uBAAeM,QAAf,GAA0BqB,aAAarB,QAAvC;AACAN,uBAAegC,KAAf,GAAuBD,SAASJ,aAAaxB,YAAb,CAA0B,UAA1B,CAAT,EAAgD,EAAhD,CAAvB;AACAH,uBAAeiC,MAAf,GAAwBF,SAASJ,aAAaxB,YAAb,CAA0B,WAA1B,CAAT,EAAiD,EAAjD,CAAxB;;AAEA0B,sBAAcF,aAAaxB,YAAb,CAA0B,QAA1B,CAAd;;AAEA;AACA,YAAI0B,gBAAgB,IAAhB,IAAwBA,gBAAgB,EAA5C,EAAgD;AAC5CA,0BAAclC,YAAYQ,YAAZ,CAAyB,QAAzB,CAAd;AACH;;AAED;AACA;AACA,YAAI0B,gBAAgB,IAAhB,IAAwBA,gBAAgB,EAA5C,EAAgD;AAC5C,gBAAID,SAAS,OAAb,EAAsB;AAClBC,8BAAc,KAAd;AACH,aAFD,MAEO,IAAID,SAAS,OAAb,EAAsB;AACzBlD,uBAAOV,KAAP,CAAa,2GAAb;AACA,uBAAO,IAAP;AACH;AACJ;;AAED;AACA,YAAII,iBAAiB8D,OAAjB,CAAyBL,YAAYM,WAAZ,EAAzB,MAAwD,CAAC,CAA7D,EAAgE;AAC5D;AACAzD,mBAAO0D,IAAP,CAAY,0BAA0BP,WAAtC;AACA,mBAAO,IAAP;AACH;;AAED;AACA,YAAIA,gBAAgB,MAAhB,IAA0BA,gBAAgB,MAA9C,EAAsD;AAClD7B,2BAAeqC,MAAf,GAAwBC,aAAaX,YAAb,CAAxB;AACH,SAFD,MAEO,IAAIE,YAAYK,OAAZ,CAAoB,KAApB,KAA8B,CAAlC,EAAqC;AACxClC,2BAAeqC,MAAf,GAAwBE,YAAYZ,YAAZ,EAA0BE,WAA1B,CAAxB;AACA7B,2BAAewC,iBAAf,GAAmCT,SAASJ,aAAaxB,YAAb,CAA0B,cAA1B,CAAT,EAAoD,EAApD,CAAnC;AACAH,2BAAeyC,aAAf,GAA+BV,SAASJ,aAAaxB,YAAb,CAA0B,UAA1B,CAAT,EAAgD,EAAhD,CAA/B;AACH,SAJM,MAIA,IAAI0B,YAAYK,OAAZ,CAAoB,MAApB,KAA+BL,YAAYK,OAAZ,CAAoB,MAApB,CAAnC,EAAgE;AACnElC,2BAAeqC,MAAf,GAAwBpE,UAAUyE,IAAlC;AACH;;AAED1C,uBAAe2C,gBAAf,GAAkC,KAAKhB,aAAaxB,YAAb,CAA0B,kBAA1B,CAAvC;AACAH,uBAAemB,OAAf,GAAyBQ,aAAaR,OAAtC;;AAEA,eAAOnB,cAAP;AACH;;AAED,aAASsC,YAAT,CAAsBX,YAAtB,EAAoC;AAChC,YAAIgB,mBAAmBhB,aAAaxB,YAAb,CAA0B,kBAA1B,EAA8CyC,QAA9C,EAAvB;AACA,YAAIC,SAAJ,EACIC,MADJ;;AAIA;AACA;AACA;AACAD,oBAAY,iBAAiBE,IAAjB,CAAsBJ,gBAAtB,CAAZ;AACA;AACAG,iBAASD,aAAaA,UAAU,CAAV,CAAb,GAA6BF,iBAAiBK,MAAjB,CAAwBL,iBAAiBT,OAAjB,CAAyBW,UAAU,CAAV,CAAzB,IAAyC,EAAjE,EAAqE,CAArE,CAA7B,GAAwGI,SAAjH;;AAEA,eAAO,UAAUH,MAAjB;AACH;;AAED,aAASP,WAAT,CAAqBZ,YAArB,EAAmCE,WAAnC,EAAgD;AAC5C,cAAMqB,eAAenB,SAASJ,aAAaxB,YAAb,CAA0B,cAA1B,CAAT,EAAoD,EAApD,CAArB;AACA,YAAIwC,mBAAmBhB,aAAaxB,YAAb,CAA0B,kBAA1B,EAA8CyC,QAA9C,EAAvB;AACA,YAAIO,aAAa,CAAjB;AACA,YAAIC,mBAAJ,EACIC,KADJ,EAEIC,SAFJ,EAGIC,+BAHJ;;AAKA;AACA;AACA,YAAI1B,gBAAgB,MAApB,EAA4B;AACxBsB,yBAAa,IAAb;AACH;AACD;AACA,YAAIR,qBAAqBM,SAArB,IAAkCN,qBAAqB,EAA3D,EAA+D;AAC3DQ,yBAAa,IAAb,CAD2D,CACxC;AACnBG,wBAAY/E,uBAAuB2E,YAAvB,CAAZ;AACA,gBAAIrB,gBAAgB,MAApB,EAA4B;AACxB;AACA;AACAsB,6BAAa,IAAb,CAHwB,CAGL;AACnBR,mCAAmB,IAAIa,UAAJ,CAAe,CAAf,CAAnB;AACAD,kDAAkChF,uBAAuB2E,eAAe,CAAtC,CAAlC,CALwB,CAKoD;AAC5E;AACA;AACAP,iCAAiB,CAAjB,IAAuBQ,cAAc,CAAf,GAAqBG,aAAa,CAAxD;AACAX,iCAAiB,CAAjB,IAAuBW,aAAa,CAAd,GAAoB3B,aAAa8B,QAAb,IAAyB,CAA7C,GAAmDF,mCAAmC,CAA5G;AACAZ,iCAAiB,CAAjB,IAAuBY,mCAAmC,CAApC,GAA0C,QAAQ,CAAxE,CAVwB,CAUoD;AAC5EZ,iCAAiB,CAAjB,IAAsB,GAAtB,CAXwB,CAWG;;AAE3BU,wBAAQ,IAAIK,WAAJ,CAAgB,CAAhB,CAAR;AACAL,sBAAM,CAAN,IAAW,CAACV,iBAAiB,CAAjB,KAAuB,CAAxB,IAA6BA,iBAAiB,CAAjB,CAAxC;AACAU,sBAAM,CAAN,IAAW,CAACV,iBAAiB,CAAjB,KAAuB,CAAxB,IAA6BA,iBAAiB,CAAjB,CAAxC;AACA;AACAS,sCAAsBC,MAAM,CAAN,EAAST,QAAT,CAAkB,EAAlB,CAAtB;AACAQ,sCAAsBC,MAAM,CAAN,EAAST,QAAT,CAAkB,EAAlB,IAAwBS,MAAM,CAAN,EAAST,QAAT,CAAkB,EAAlB,CAA9C;AAEH,aApBD,MAoBO;AACH;AACA;AACAD,mCAAmB,IAAIa,UAAJ,CAAe,CAAf,CAAnB;AACA;AACAb,iCAAiB,CAAjB,IAAuBQ,cAAc,CAAf,GAAqBG,aAAa,CAAxD;AACAX,iCAAiB,CAAjB,IAAuBW,aAAa,CAAd,GAAoBvB,SAASJ,aAAaxB,YAAb,CAA0B,UAA1B,CAAT,EAAgD,EAAhD,KAAuD,CAAjG;AACA;AACAkD,wBAAQ,IAAIK,WAAJ,CAAgB,CAAhB,CAAR;AACAL,sBAAM,CAAN,IAAW,CAACV,iBAAiB,CAAjB,KAAuB,CAAxB,IAA6BA,iBAAiB,CAAjB,CAAxC;AACA;AACAS,sCAAsBC,MAAM,CAAN,EAAST,QAAT,CAAkB,EAAlB,CAAtB;AACH;;AAEDD,+BAAmB,KAAKS,mBAAxB;AACAT,+BAAmBA,iBAAiBR,WAAjB,EAAnB;AACAR,yBAAagC,YAAb,CAA0B,kBAA1B,EAA8ChB,gBAA9C;AACH,SAxCD,MAwCO,IAAIQ,eAAe,CAAnB,EAAsB;AACzBA,yBAAa,CAACpB,SAASY,iBAAiBK,MAAjB,CAAwB,CAAxB,EAA2B,CAA3B,CAAT,EAAwC,EAAxC,IAA8C,IAA/C,KAAwD,CAArE;AACH;;AAED,eAAO,aAAaG,UAApB;AACH;;AAED,aAASjC,kBAAT,CAA4BvB,WAA5B,EAAyCX,SAAzC,EAAoD;AAChD,cAAMc,kBAAkB,EAAxB;AACA,YAAI8D,QAAJ,EACIC,oBADJ;;AAGAD,mBAAWjE,YAAYQ,YAAZ,CAAyB,KAAzB,EAAgC2D,OAAhC,CAAwC,WAAxC,EAAqD,aAArD,CAAX;AACAF,mBAAWA,SAASE,OAAT,CAAiB,cAAjB,EAAiC,QAAjC,CAAX;;AAEAD,+BAAuBlE,YAAYQ,YAAZ,CAAyB,WAAzB,CAAvB;AACA0D,+BAAuBA,uBAAuBE,WAAWF,oBAAX,CAAvB,GAA0D7E,SAAjF;;AAEAc,wBAAgBkE,KAAhB,GAAwBJ,QAAxB;AACA9D,wBAAgBd,SAAhB,GAA4B6E,oBAA5B;;AAEA/D,wBAAgB2B,eAAhB,GAAkCwC,mBAAmBtE,WAAnB,EAAgCG,gBAAgBd,SAAhD,CAAlC;;AAEA,eAAOc,eAAP;AACH;;AAED,aAASmE,kBAAT,CAA4BtE,WAA5B,EAAyCX,SAAzC,EAAoD;AAChD,cAAMkF,kBAAkB,EAAxB;AACA,cAAMC,SAASxE,YAAYN,oBAAZ,CAAiC,GAAjC,CAAf;AACA,cAAMY,WAAW,EAAjB;AACA,YAAImE,OAAJ,EACIC,WADJ,EAEIC,SAFJ,EAGIhF,CAHJ,EAGMiF,CAHN,EAGQC,CAHR;AAIA,YAAIC,WAAW,CAAf;;AAEA,aAAKnF,IAAI,CAAT,EAAYA,IAAI6E,OAAO5E,MAAvB,EAA+BD,GAA/B,EAAoC;AAChC8E,sBAAU,EAAV;;AAEA;AACAE,wBAAYH,OAAO7E,CAAP,EAAUa,YAAV,CAAuB,GAAvB,CAAZ;;AAEA;AACA;AACAiE,oBAAQE,SAAR,GAAoBP,WAAWO,SAAX,CAApB;AACAF,oBAAQM,CAAR,GAAYX,WAAWO,SAAX,CAAZ;;AAEA;AACAF,oBAAQO,CAAR,GAAYZ,WAAWI,OAAO7E,CAAP,EAAUa,YAAV,CAAuB,GAAvB,CAAX,CAAZ;;AAEA;AACA,gBAAKb,MAAM,CAAP,IAAa,CAAC8E,QAAQM,CAA1B,EAA6B;AACzBN,wBAAQM,CAAR,GAAY,CAAZ;AACH;;AAED,gBAAIpF,IAAI,CAAR,EAAW;AACP+E,8BAAcpE,SAASA,SAASV,MAAT,GAAkB,CAA3B,CAAd;AACA;AACA,oBAAI,CAAC8E,YAAYM,CAAjB,EAAoB;AAChB,wBAAIN,YAAYC,SAAhB,EAA2B;AACvBD,oCAAYM,CAAZ,GAAgBZ,WAAWO,SAAX,IAAwBP,WAAWM,YAAYC,SAAvB,CAAxC;AACH,qBAFD,MAEO;AACHD,oCAAYM,CAAZ,GAAgBP,QAAQM,CAAR,GAAYL,YAAYK,CAAxC;AACH;AACDD,gCAAYJ,YAAYM,CAAxB;AACH;AACD;AACA,oBAAI,CAACP,QAAQM,CAAb,EAAgB;AACZ,wBAAIL,YAAYC,SAAhB,EAA2B;AACvBF,gCAAQE,SAAR,GAAoBP,WAAWM,YAAYC,SAAvB,IAAoCD,YAAYM,CAApE;AACAP,gCAAQM,CAAR,GAAYX,WAAWK,QAAQE,SAAnB,CAAZ;AACH,qBAHD,MAGO;AACHF,gCAAQM,CAAR,GAAYL,YAAYK,CAAZ,GAAgBL,YAAYM,CAAxC;AACH;AACJ;AACJ;;AAED,gBAAIP,QAAQO,CAAZ,EAAe;AACXF,4BAAYL,QAAQO,CAApB;AACH;;AAED;AACA1E,qBAASR,IAAT,CAAc2E,OAAd;;AAEA;AACAI,gBAAIT,WAAWI,OAAO7E,CAAP,EAAUa,YAAV,CAAuB,GAAvB,CAAX,CAAJ;AACA,gBAAIqE,CAAJ,EAAO;;AAEH,qBAAKD,IAAI,CAAT,EAAYA,IAAKC,IAAI,CAArB,EAAyBD,GAAzB,EAA8B;AAC1BF,kCAAcpE,SAASA,SAASV,MAAT,GAAkB,CAA3B,CAAd;AACA6E,8BAAU,EAAV;AACAA,4BAAQM,CAAR,GAAYL,YAAYK,CAAZ,GAAgBL,YAAYM,CAAxC;AACAP,4BAAQO,CAAR,GAAYN,YAAYM,CAAxB;AACA,wBAAIN,YAAYC,SAAhB,EAA2B;AACvBF,gCAAQE,SAAR,GAAqBP,WAAWM,YAAYC,SAAvB,IAAoCD,YAAYM,CAArE;AACH;AACDF,gCAAYL,QAAQO,CAApB;AACA1E,6BAASR,IAAT,CAAc2E,OAAd;AACH;AACJ;AACJ;;AAEDF,wBAAgBU,CAAhB,GAAoB3E,QAApB;AACAiE,wBAAgBxC,SAAhB,GAA4BzB,QAA5B;AACAiE,wBAAgBO,QAAhB,GAA2BA,WAAWzF,SAAtC;;AAEA,eAAOkF,eAAP;AACH;;AAED,aAASW,0BAAT,CAAoCC,gBAApC,EAAsD;AAClD,YAAIC,QAAJ,EACIC,SADJ,EAEIC,SAFJ,EAGIC,GAHJ;;AAKA;AACAH,mBAAWhH,OAAOoH,WAAP,CAAmBL,iBAAiBM,UAAjB,CAA4BC,IAA/C,CAAX;;AAEA;AACAL,oBAAYM,yBAAyBP,QAAzB,CAAZ;;AAEA;AACAC,oBAAY,IAAItB,WAAJ,CAAgBsB,UAAUO,MAA1B,CAAZ;;AAEA;AACAP,oBAAYQ,OAAOC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgCV,SAAhC,CAAZ;;AAEA;AACAC,oBAAa,IAAIU,SAAJ,EAAD,CAAkBC,eAAlB,CAAkCZ,SAAlC,EAA6C,iBAA7C,CAAZ;AACAE,cAAMD,UAAUY,aAAV,CAAwB,KAAxB,EAA+BC,WAArC;;AAEA;AACAZ,cAAMnH,OAAOoH,WAAP,CAAmBD,GAAnB,CAAN;;AAEA;AACAa,8BAAsBb,GAAtB;;AAEA,eAAOA,GAAP;AACH;;AAED,aAASI,wBAAT,CAAkCP,QAAlC,EAA4C;AACxC,YAAIxF,MAAJ,EACIyG,WADJ,EAEIC,UAFJ,EAGIC,YAHJ,EAIIC,WAJJ;AAKA,YAAI7G,IAAI,CAAR;;AAEA;;AAEA;AACAC,iBAAS,CAACwF,SAASzF,IAAI,CAAb,KAAmB,EAApB,KAA2ByF,SAASzF,IAAI,CAAb,KAAmB,EAA9C,KAAqDyF,SAASzF,IAAI,CAAb,KAAmB,CAAxE,IAA6EyF,SAASzF,CAAT,CAAtF;AACAA,aAAK,CAAL;;AAEA;AACA0G,sBAAc,CAACjB,SAASzF,IAAI,CAAb,KAAmB,CAApB,IAAyByF,SAASzF,CAAT,CAAvC;AACAA,aAAK,CAAL;;AAEA;AACA,eAAOA,IAAIyF,SAASxF,MAApB,EAA4B;AACxB;AACA0G,yBAAa,CAAClB,SAASzF,IAAI,CAAb,KAAmB,CAApB,IAAyByF,SAASzF,CAAT,CAAtC;AACAA,iBAAK,CAAL;;AAEA;AACA,gBAAI2G,eAAe,IAAnB,EAAyB;;AAErB;AACAC,+BAAe,CAACnB,SAASzF,IAAI,CAAb,KAAmB,CAApB,IAAyByF,SAASzF,CAAT,CAAxC;AACAA,qBAAK,CAAL;;AAEA;AACA6G,8BAAc,IAAI3C,UAAJ,CAAe0C,YAAf,CAAd;AACAC,4BAAYC,GAAZ,CAAgBrB,SAASsB,QAAT,CAAkB/G,CAAlB,EAAqBA,IAAI4G,YAAzB,CAAhB;AACA,uBAAOC,WAAP;AACH;AACJ;;AAED,eAAO,IAAP;AACH;;AAED,aAASJ,qBAAT,CAA+BO,IAA/B,EAAqC;AACjCC,kBAAUD,IAAV,EAAgB,CAAhB,EAAmB,CAAnB;AACAC,kBAAUD,IAAV,EAAgB,CAAhB,EAAmB,CAAnB;AACAC,kBAAUD,IAAV,EAAgB,CAAhB,EAAmB,CAAnB;AACAC,kBAAUD,IAAV,EAAgB,CAAhB,EAAmB,CAAnB;AACH;;AAED,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AAClC,cAAMC,OAAOH,MAAMC,IAAN,CAAb;AACAD,cAAMC,IAAN,IAAcD,MAAME,IAAN,CAAd;AACAF,cAAME,IAAN,IAAcC,IAAd;AACH;;AAGD,aAASC,yBAAT,CAAmC9B,gBAAnC,EAAqD;AACjD,YAAI+B,MAAM;AACNC,oBAAQhC,iBAAiBM,UAAjB,CAA4BC,IAD9B;AAEN0B,sBAAU;AAFJ,SAAV;AAIA,eAAO;AACHpG,yBAAa,+CADV;AAEHC,mBAAO,yBAFJ;AAGHiG,iBAAKA,GAHF;AAIHG,yBAAaH;AAJV,SAAP;AAMH;;AAED,aAASI,+BAAT,CAAyCnC,gBAAzC,EAA2DI,GAA3D,EAAgE;AAC5D;AACA,cAAMgC,eAAe,IAAI1D,UAAJ,CAAe,IAAI0B,IAAI3F,MAAvB,CAArB;AACA2H,qBAAa,CAAb,IAAkB,IAAlB;AACAA,qBAAa,CAAb,IAAkB,IAAlB;AACAA,qBAAad,GAAb,CAAiBlB,GAAjB,EAAsB,CAAtB;;AAEA;AACA,cAAM3F,SAAS,GAAG,yCAAH,GAA+C,EAA/C,CAAkD,cAAlD,GAAmE,CAAnE,CAAqE,iBAArE,GAAyF2H,aAAa3H,MAArH;AACA,YAAI4H,OAAO,IAAI3D,UAAJ,CAAejE,MAAf,CAAX;AACA,YAAID,IAAI,CAAR;;AAEA;AACA6H,aAAK7H,GAAL,IAAY,CAACC,SAAS,UAAV,KAAyB,EAArC;AACA4H,aAAK7H,GAAL,IAAY,CAACC,SAAS,UAAV,KAAyB,EAArC;AACA4H,aAAK7H,GAAL,IAAY,CAACC,SAAS,UAAV,KAAyB,CAArC;AACA4H,aAAK7H,GAAL,IAAaC,SAAS,UAAtB;;AAEA;AACA4H,aAAKf,GAAL,CAAS,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAT,EAA2D9G,CAA3D;AACAA,aAAK,CAAL;;AAEA;AACA6H,aAAKf,GAAL,CAAS,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,IAAtC,EAA4C,IAA5C,EAAkD,IAAlD,EAAwD,IAAxD,EAA8D,IAA9D,EAAoE,IAApE,EAA0E,IAA1E,EAAgF,IAAhF,EAAsF,IAAtF,EAA4F,IAA5F,CAAT,EAA4G9G,CAA5G;AACAA,aAAK,EAAL;;AAEA;AACA6H,aAAK7H,GAAL,IAAY,CAAC4H,aAAa3H,MAAb,GAAsB,UAAvB,KAAsC,EAAlD;AACA4H,aAAK7H,GAAL,IAAY,CAAC4H,aAAa3H,MAAb,GAAsB,UAAvB,KAAsC,EAAlD;AACA4H,aAAK7H,GAAL,IAAY,CAAC4H,aAAa3H,MAAb,GAAsB,UAAvB,KAAsC,CAAlD;AACA4H,aAAK7H,GAAL,IAAa4H,aAAa3H,MAAb,GAAsB,UAAnC;;AAEA;AACA4H,aAAKf,GAAL,CAASc,YAAT,EAAuB5H,CAAvB;;AAEA;AACA6H,eAAO3B,OAAOC,YAAP,CAAoBC,KAApB,CAA0B,IAA1B,EAAgCyB,IAAhC,CAAP;AACAA,eAAOpJ,OAAOqJ,WAAP,CAAmBD,IAAnB,CAAP;;AAEA,eAAO;AACHxG,yBAAa,+CADV;AAEHC,mBAAO,oBAFJ;AAGHuG,kBAAM;AACFL,wBAAQK;AADN;AAHH,SAAP;AAOH;;AAED,aAASE,eAAT,CAAyBC,MAAzB,EAAiCC,kBAAjC,EAAqD;AACjD,cAAMC,WAAW,EAAjB;AACA,cAAMC,qBAAqB,EAA3B;AACA,cAAM1I,uBAAuBuI,OAAOjI,oBAAP,CAA4B,sBAA5B,EAAoD,CAApD,CAA7B;AACA,cAAMqI,aAAaJ,OAAOjI,oBAAP,CAA4B,YAA5B,EAA0C,CAA1C,CAAnB;AACA,YAAIyF,mBAAmB,IAAvB;AACA,YAAI7F,MAAJ,EACI0I,WADJ,EAEIC,iBAFJ,EAGI1C,GAHJ,EAII2C,eAJJ,EAKIC,SALJ,EAMI7H,QANJ,EAOIjB,SAPJ,EAQIM,CARJ,EAQOiF,CARP;;AAUA;AACAiD,iBAASO,QAAT,GAAoB,KAApB;AACAP,iBAASQ,QAAT,GAAoB,uCAApB;AACAR,iBAAS5F,IAAT,GAAgB7C,qBAAqBoB,YAArB,CAAkC,QAAlC,MAAgD,MAAhD,GAAyD,SAAzD,GAAqE,QAArF;AACAnB,oBAAaD,qBAAqBoB,YAArB,CAAkC,WAAlC,CAAb;AACAqH,iBAASxI,SAAT,GAAqBA,YAAY+E,WAAW/E,SAAX,CAAZ,GAAoCb,kBAAzD;AACA,YAAI8J,kBAAkBlE,WAAWhF,qBAAqBoB,YAArB,CAAkC,iBAAlC,CAAX,CAAtB;AACA,YAAI8H,oBAAoB,CAApB,IAAyBlJ,qBAAqBoB,YAArB,CAAkC,SAAlC,MAAiD,MAA9E,EAAsF;AAClF8H,8BAAkBC,QAAlB;AACH;AACD,YAAID,kBAAkB,CAAtB,EAAyB;AACrBT,qBAASW,oBAAT,GAAgCF,kBAAkBT,SAASxI,SAA3D;AACH;;AAED,YAAIyF,WAAWV,WAAWhF,qBAAqBoB,YAArB,CAAkC,UAAlC,CAAX,CAAf;AACAqH,iBAASY,yBAAT,GAAsC3D,aAAa,CAAd,GAAmByD,QAAnB,GAA8BzD,WAAW+C,SAASxI,SAAvF;AACAwI,iBAASa,aAAT,GAAyB1J,iBAAiB2J,mBAAjB,EAAzB;AACAd,iBAASe,kBAAT,GAA8B,IAA9B;;AAEA;AACA,YAAIf,SAAS5F,IAAT,KAAkB,SAAlB,IAA+B6C,WAAW,CAA9C,EAAiD;AAC7C+C,qBAAS5F,IAAT,GAAgB,QAAhB;AACA;AACA4F,qBAASW,oBAAT,GAAgC1D,WAAW+C,SAASxI,SAApD;AACA;AACH;;AAED;AACA,YAAIwI,SAAS5F,IAAT,KAAkB,SAAlB,IAAgC4F,SAASW,oBAAT,GAAgCD,QAApE,EAA8E;AAC1EV,qBAASgB,qBAAT,GAAiC,IAAIC,IAAJ,CAASlB,mBAAmBmB,OAAnB,KAAgClB,SAASW,oBAAT,GAAgC,IAAzE,CAAjC;AACAX,qBAASmB,4BAAT,GAAwC,IAAxC;AACAnB,qBAASoB,mCAAT,GAA+C,IAA/C,CAH0E,CAGrB;AACrDpB,qBAASqB,wBAAT,GAAoC,IAApC,CAJ0E,CAIhC;AAC7C;;AAED;AACArB,iBAASsB,MAAT,GAAkBhK,UAAUC,oBAAV,EAAgCyI,SAASxI,SAAzC,CAAlB;AACAwI,iBAASuB,cAAT,GAA0B,CAACvB,SAASsB,MAAV,CAA1B;;AAEA;AACA7J,iBAASuI,SAASsB,MAAlB;AACA7J,eAAO+J,KAAP,GAAe,CAAf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAItB,eAAezE,SAAnB,EAA8B;AAC1B6B,+BAAmBwC,OAAOjI,oBAAP,CAA4B,kBAA5B,EAAgD,CAAhD,CAAnB;;AAEA;AACA;AACAyF,6BAAiBM,UAAjB,CAA4BC,IAA5B,GAAmCP,iBAAiBM,UAAjB,CAA4BC,IAA5B,CAAiCvB,OAAjC,CAAyC,QAAzC,EAAmD,EAAnD,CAAnC;;AAEA;AACAoB,kBAAML,2BAA2BC,gBAA3B,CAAN;;AAEA;AACA8C,gCAAoBhB,0BAA0B9B,gBAA1B,CAApB;AACA8C,8BAAkB,kBAAlB,IAAwC1C,GAAxC;AACAuC,+BAAmBhI,IAAnB,CAAwBmI,iBAAxB;;AAEA;AACAA,gCAAoBX,gCAAgCnC,gBAAhC,EAAkDI,GAAlD,CAApB;AACA0C,8BAAkB,kBAAlB,IAAwC1C,GAAxC;AACAuC,+BAAmBhI,IAAnB,CAAwBmI,iBAAxB;;AAEAJ,qBAASyB,iBAAT,GAA6BxB,kBAA7B;AACAD,qBAAS0B,yBAAT,GAAqCzB,kBAArC;AACH;;AAEDE,sBAAc1I,OAAOG,qBAArB;;AAEA,aAAKE,IAAI,CAAT,EAAYA,IAAIqI,YAAYpI,MAA5B,EAAoCD,KAAK,CAAzC,EAA4C;AACxCqI,wBAAYrI,CAAZ,EAAegC,eAAf,CAA+B6H,cAA/B,GAAgD,aAAhD;AACA;AACA,gBAAI3B,SAASyB,iBAAT,KAA+BhG,SAAnC,EAA8C;AAC1C0E,4BAAYrI,CAAZ,EAAe2J,iBAAf,GAAmCzB,SAASyB,iBAA5C;AACAtB,4BAAYrI,CAAZ,EAAe4J,yBAAf,GAA2C1B,SAAS0B,yBAApD;AACH;;AAED,gBAAI1B,SAAS5F,IAAT,KAAkB,SAAtB,EAAiC;AAC7B;AACA,oBAAI4F,SAASW,oBAAT,KAAkCD,QAAtC,EAAgD;AAC5CV,6BAASgB,qBAAT,GAAiC,IAAIC,IAAJ,CAASlB,mBAAmBmB,OAAnB,KAAgCf,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CgD,QAA/C,GAA0D,IAAnG,CAAjC;AACH;AACD;AACA,oBAAI+C,SAASW,oBAAT,GAAgC,CAAhC,IACAX,SAASW,oBAAT,KAAkCD,QADlC,IAEAP,YAAYrI,CAAZ,EAAec,WAAf,KAA+B,OAF/B,IAGAoH,SAASW,oBAAT,GAAgCR,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CgD,QAHnF,EAG6F;AACzF+C,6BAASW,oBAAT,GAAgCR,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CgD,QAA/E;AACH;AACJ;AACJ;;AAED,YAAI+C,SAASW,oBAAT,GAAgCX,SAASa,aAA7C,EAA4D;AACxDb,qBAASa,aAAT,GAAyBb,SAASW,oBAAlC;AACH;;AAED;AACA,eAAOX,SAASyB,iBAAhB;AACA,eAAOzB,SAAS0B,yBAAhB;;AAEA;AACA;AACA;AACA,YAAI1B,SAAS5F,IAAT,KAAkB,QAAtB,EAAgC;AAC5B;AACA;AACA,gBAAIwH,eAAelL,cAAcmL,QAAd,EAAnB;AACA,gBAAID,gBAAgBA,aAAavB,eAAjC,EAAkD;AAC9CA,kCAAkBuB,aAAavB,eAA/B;AACH,aAFD,MAEO;AACH,qBAAKvI,IAAI,CAAT,EAAYA,IAAIqI,YAAYpI,MAA5B,EAAoCD,GAApC,EAAyC;AACrC,wBAAIqI,YAAYrI,CAAZ,EAAec,WAAf,KAA+B,OAA/B,IAA0CuH,YAAYrI,CAAZ,EAAec,WAAf,KAA+B,OAA7E,EAAsF;AAClFH,mCAAW0H,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CC,SAA1D;AACAoG,oCAAY7H,SAAS,CAAT,EAAYyE,CAAZ,GAAgBiD,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BtC,SAA3D;AACA,4BAAI6I,oBAAoB5E,SAAxB,EAAmC;AAC/B4E,8CAAkBC,SAAlB;AACH;AACDD,0CAAkByB,KAAKC,GAAL,CAAS1B,eAAT,EAA0BC,SAA1B,CAAlB;AACA;AACA;AACAN,iCAASY,yBAAT,GAAqCkB,KAAKC,GAAL,CAAS/B,SAASY,yBAAlB,EAA6CT,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CgD,QAA5F,CAArC;AACH;AACJ;AACJ;AACD;AACA,gBAAIoD,kBAAkB,CAAtB,EAAyB;AACrBL,yBAASK,eAAT,GAA2BA,eAA3B;AACA,qBAAKvI,IAAI,CAAT,EAAYA,IAAIqI,YAAYpI,MAA5B,EAAoCD,GAApC,EAAyC;AACrCW,+BAAW0H,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BG,eAA/B,CAA+CC,SAA1D;AACA,yBAAK6C,IAAI,CAAT,EAAYA,IAAItE,SAASV,MAAzB,EAAiCgF,GAAjC,EAAsC;AAClC,4BAAI,CAACtE,SAASsE,CAAT,EAAYD,SAAjB,EAA4B;AACxBrE,qCAASsE,CAAT,EAAYD,SAAZ,GAAwBrE,SAASsE,CAAT,EAAYG,CAApC;AACH;AACDzE,iCAASsE,CAAT,EAAYG,CAAZ,IAAkBmD,kBAAkBF,YAAYrI,CAAZ,EAAegC,eAAf,CAA+BtC,SAAnE;AACH;AACD,wBAAI2I,YAAYrI,CAAZ,EAAec,WAAf,KAA+B,OAA/B,IAA0CuH,YAAYrI,CAAZ,EAAec,WAAf,KAA+B,OAA7E,EAAsF;AAClFnB,+BAAO+J,KAAP,GAAeM,KAAKE,GAAL,CAASvJ,SAAS,CAAT,EAAYyE,CAArB,EAAwBzF,OAAO+J,KAA/B,CAAf;AACArB,oCAAYrI,CAAZ,EAAegC,eAAf,CAA+BmI,sBAA/B,GAAwDxK,OAAO+J,KAA/D;AACH;AACJ;AACD/J,uBAAO+J,KAAP,IAAgBxB,SAASxI,SAAzB;AACH;AACJ;;AAED;AACA;AACAwI,iBAASY,yBAAT,GAAqCkB,KAAKI,KAAL,CAAWlC,SAASY,yBAAT,GAAqC,IAAhD,IAAwD,IAA7F;AACAnJ,eAAOwF,QAAP,GAAkB+C,SAASY,yBAA3B;;AAEA,eAAOZ,QAAP;AACH;;AAED,aAASmC,QAAT,CAAkBtE,IAAlB,EAAwB;AACpB,YAAIiC,SAAS,IAAb;;AAEA,YAAIsC,OAAOjE,SAAX,EAAsB;AAClB,kBAAMkE,SAAS,IAAID,OAAOjE,SAAX,EAAf;;AAEA2B,qBAASuC,OAAOjE,eAAP,CAAuBP,IAAvB,EAA6B,UAA7B,CAAT;AACA,gBAAIiC,OAAOjI,oBAAP,CAA4B,aAA5B,EAA2CE,MAA3C,GAAoD,CAAxD,EAA2D;AACvD,sBAAM,IAAIuK,KAAJ,CAAU,6BAAV,CAAN;AACH;AACJ;;AAED,eAAOxC,MAAP;AACH;;AAED,aAASyC,WAAT,GAAuB;AACnB,eAAO,IAAP;AACH;;AAED,aAASC,OAAT,GAAmB;AACf,eAAO,IAAP;AACH;;AAED,aAASC,aAAT,CAAuB5E,IAAvB,EAA6B;AACzB,YAAIiC,SAAS,IAAb;AACA,YAAIE,WAAW,IAAf;;AAEA,cAAMM,YAAY8B,OAAOM,WAAP,CAAmBC,GAAnB,EAAlB;;AAEA;AACA7C,iBAASqC,SAAStE,IAAT,CAAT;;AAEA,cAAM+E,eAAeR,OAAOM,WAAP,CAAmBC,GAAnB,EAArB;;AAEA,YAAI7C,WAAW,IAAf,EAAqB;AACjB,mBAAO,IAAP;AACH;;AAED;AACAE,mBAAWH,gBAAgBC,MAAhB,EAAwB,IAAImB,IAAJ,EAAxB,CAAX;;AAEA,cAAM4B,eAAeT,OAAOM,WAAP,CAAmBC,GAAnB,EAArB;;AAEAzL,eAAO4L,IAAP,CAAY,oCAAoC,CAACF,eAAetC,SAAhB,EAA2ByC,WAA3B,CAAuC,CAAvC,CAApC,GAAgF,gBAAhF,GAAmG,CAACF,eAAeD,YAAhB,EAA8BG,WAA9B,CAA0C,CAA1C,CAAnG,GAAkJ,aAAlJ,GAAkK,CAAC,CAACF,eAAevC,SAAhB,IAA6B,IAA9B,EAAoCyC,WAApC,CAAgD,CAAhD,CAAlK,GAAuN,IAAnO;;AAEA,eAAO/C,QAAP;AACH;;AAED/I,eAAW;AACP+L,eAAOP,aADA;AAEPF,qBAAaA,WAFN;AAGPC,iBAASA;AAHF,KAAX;;AAMApL;;AAEA,WAAOH,QAAP;AACH;;AAEDZ,UAAU4M,qBAAV,GAAkC,WAAlC;AACA,eAAeC,OAAOC,YAAP,CAAoBC,eAApB,CAAoC/M,SAApC,CAAf,C,CAA+D","file":"MssParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssParser\n * @param {Object} config object\n */\nfunction MssParser(config) {\n    config = config || {};\n    const BASE64 = config.BASE64;\n    const debug = config.debug;\n    const constants = config.constants;\n    const manifestModel = config.manifestModel;\n\n    const DEFAULT_TIME_SCALE = 10000000.0;\n    const SUPPORTED_CODECS = ['AAC', 'AACL', 'AVC1', 'H264', 'TTML', 'DFXP'];\n    // MPEG-DASH Role and accessibility mapping according to ETSI TS 103 285 v1.1.1 (section 7.1.2)\n    const ROLE = {\n        'SUBT': 'alternate',\n        'CAPT': 'alternate', // 'CAPT' is commonly equivalent to 'SUBT'\n        'DESC': 'main'\n    };\n    const ACCESSIBILITY = {\n        'DESC': '2'\n    };\n    const samplingFrequencyIndex = {\n        96000: 0x0,\n        88200: 0x1,\n        64000: 0x2,\n        48000: 0x3,\n        44100: 0x4,\n        32000: 0x5,\n        24000: 0x6,\n        22050: 0x7,\n        16000: 0x8,\n        12000: 0x9,\n        11025: 0xA,\n        8000: 0xB,\n        7350: 0xC\n    };\n    const mimeTypeMap = {\n        'video': 'video/mp4',\n        'audio': 'audio/mp4',\n        'text': 'application/mp4'\n    };\n\n    let instance,\n        logger,\n        mediaPlayerModel;\n\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        mediaPlayerModel = config.mediaPlayerModel;\n    }\n\n    function mapPeriod(smoothStreamingMedia, timescale) {\n        const period = {};\n        let streams,\n            adaptation;\n\n        // For each StreamIndex node, create an AdaptationSet element\n        period.AdaptationSet_asArray = [];\n        streams = smoothStreamingMedia.getElementsByTagName('StreamIndex');\n        for (let i = 0; i < streams.length; i++) {\n            adaptation = mapAdaptationSet(streams[i], timescale);\n            if (adaptation !== null) {\n                period.AdaptationSet_asArray.push(adaptation);\n            }\n        }\n\n        if (period.AdaptationSet_asArray.length > 0) {\n            period.AdaptationSet = (period.AdaptationSet_asArray.length > 1) ? period.AdaptationSet_asArray : period.AdaptationSet_asArray[0];\n        }\n\n        return period;\n    }\n\n    function mapAdaptationSet(streamIndex, timescale) {\n        const adaptationSet = {};\n        const representations = [];\n        let segmentTemplate;\n        let qualityLevels,\n            representation,\n            segments,\n            i;\n\n        adaptationSet.id = streamIndex.getAttribute('Name') ? streamIndex.getAttribute('Name') : streamIndex.getAttribute('Type');\n        adaptationSet.contentType = streamIndex.getAttribute('Type');\n        adaptationSet.lang = streamIndex.getAttribute('Language') || 'und';\n        adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType];\n        adaptationSet.subType = streamIndex.getAttribute('Subtype');\n        adaptationSet.maxWidth = streamIndex.getAttribute('MaxWidth');\n        adaptationSet.maxHeight = streamIndex.getAttribute('MaxHeight');\n\n        // Map subTypes to MPEG-DASH AdaptationSet role and accessibility (see ETSI TS 103 285 v1.1.1, section 7.1.2)\n        if (adaptationSet.subType) {\n            if (ROLE[adaptationSet.subType]) {\n                let role = {\n                    schemeIdUri: 'urn:mpeg:dash:role:2011',\n                    value: ROLE[adaptationSet.subType]\n                };\n                adaptationSet.Role = role;\n                adaptationSet.Role_asArray = [role];\n            }\n            if (ACCESSIBILITY[adaptationSet.subType]) {\n                let accessibility = {\n                    schemeIdUri: 'urn:tva:metadata:cs:AudioPurposeCS:2007',\n                    value: ACCESSIBILITY[adaptationSet.subType]\n                };\n                adaptationSet.Accessibility = accessibility;\n                adaptationSet.Accessibility_asArray = [accessibility];\n            }\n        }\n\n        // Create a SegmentTemplate with a SegmentTimeline\n        segmentTemplate = mapSegmentTemplate(streamIndex, timescale);\n\n        qualityLevels = streamIndex.getElementsByTagName('QualityLevel');\n        // For each QualityLevel node, create a Representation element\n        for (i = 0; i < qualityLevels.length; i++) {\n            // Propagate BaseURL and mimeType\n            qualityLevels[i].BaseURL = adaptationSet.BaseURL;\n            qualityLevels[i].mimeType = adaptationSet.mimeType;\n\n            // Set quality level id\n            qualityLevels[i].Id = adaptationSet.id + '_' + qualityLevels[i].getAttribute('Index');\n\n            // Map Representation to QualityLevel\n            representation = mapRepresentation(qualityLevels[i], streamIndex);\n\n            if (representation !== null) {\n                // Copy SegmentTemplate into Representation\n                representation.SegmentTemplate = segmentTemplate;\n\n                representations.push(representation);\n            }\n        }\n\n        if (representations.length === 0) {\n            return null;\n        }\n\n        adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];\n        adaptationSet.Representation_asArray = representations;\n\n        // Set SegmentTemplate\n        adaptationSet.SegmentTemplate = segmentTemplate;\n\n        segments = segmentTemplate.SegmentTimeline.S_asArray;\n\n        return adaptationSet;\n    }\n\n    function mapRepresentation(qualityLevel, streamIndex) {\n        const representation = {};\n        const type = streamIndex.getAttribute('Type');\n        let fourCCValue = null;\n\n        representation.id = qualityLevel.Id;\n        representation.bandwidth = parseInt(qualityLevel.getAttribute('Bitrate'), 10);\n        representation.mimeType = qualityLevel.mimeType;\n        representation.width = parseInt(qualityLevel.getAttribute('MaxWidth'), 10);\n        representation.height = parseInt(qualityLevel.getAttribute('MaxHeight'), 10);\n\n        fourCCValue = qualityLevel.getAttribute('FourCC');\n\n        // If FourCC not defined at QualityLevel level, then get it from StreamIndex level\n        if (fourCCValue === null || fourCCValue === '') {\n            fourCCValue = streamIndex.getAttribute('FourCC');\n        }\n\n        // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx),\n        // then we consider the stream is an audio AAC stream\n        if (fourCCValue === null || fourCCValue === '') {\n            if (type === 'audio') {\n                fourCCValue = 'AAC';\n            } else if (type === 'video') {\n                logger.debug('FourCC is not defined whereas it is required for a QualityLevel element for a StreamIndex of type \"video\"');\n                return null;\n            }\n        }\n\n        // Check if codec is supported\n        if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) {\n            // Do not send warning\n            logger.warn('Codec not supported: ' + fourCCValue);\n            return null;\n        }\n\n        // Get codecs value according to FourCC field\n        if (fourCCValue === 'H264' || fourCCValue === 'AVC1') {\n            representation.codecs = getH264Codec(qualityLevel);\n        } else if (fourCCValue.indexOf('AAC') >= 0) {\n            representation.codecs = getAACCodec(qualityLevel, fourCCValue);\n            representation.audioSamplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n            representation.audioChannels = parseInt(qualityLevel.getAttribute('Channels'), 10);\n        } else if (fourCCValue.indexOf('TTML') || fourCCValue.indexOf('DFXP')) {\n            representation.codecs = constants.STPP;\n        }\n\n        representation.codecPrivateData = '' + qualityLevel.getAttribute('CodecPrivateData');\n        representation.BaseURL = qualityLevel.BaseURL;\n\n        return representation;\n    }\n\n    function getH264Codec(qualityLevel) {\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let nalHeader,\n            avcoti;\n\n\n        // Extract from the CodecPrivateData field the hexadecimal representation of the following\n        // three bytes in the sequence parameter set NAL unit.\n        // => Find the SPS nal header\n        nalHeader = /00000001[0-9]7/.exec(codecPrivateData);\n        // => Find the 6 characters after the SPS nalHeader (if it exists)\n        avcoti = nalHeader && nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined;\n\n        return 'avc1.' + avcoti;\n    }\n\n    function getAACCodec(qualityLevel, fourCCValue) {\n        const samplingRate = parseInt(qualityLevel.getAttribute('SamplingRate'), 10);\n        let codecPrivateData = qualityLevel.getAttribute('CodecPrivateData').toString();\n        let objectType = 0;\n        let codecPrivateDataHex,\n            arr16,\n            indexFreq,\n            extensionSamplingFrequencyIndex;\n\n        //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC\n        //set objectType to 5 => strange, it should be 2\n        if (fourCCValue === 'AACH') {\n            objectType = 0x05;\n        }\n        //if codecPrivateData is empty, build it :\n        if (codecPrivateData === undefined || codecPrivateData === '') {\n            objectType = 0x02; //AAC Main Low Complexity => object Type = 2\n            indexFreq = samplingFrequencyIndex[samplingRate];\n            if (fourCCValue === 'AACH') {\n                // 4 bytes :     XXXXX         XXXX          XXXX             XXXX                  XXXXX      XXX   XXXXXXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'Extens Sampl Freq'  'ObjectType'  'GAS' 'alignment = 0'\n                objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR\n                codecPrivateData = new Uint8Array(4);\n                extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence\n                // equals to SamplingRate*2\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (qualityLevel.Channels << 3) | (extensionSamplingFrequencyIndex >> 1);\n                codecPrivateData[2] = (extensionSamplingFrequencyIndex << 7) | (0x02 << 2); // origin object type equals to 2 => AAC Main Low Complexity\n                codecPrivateData[3] = 0x0; //alignment bits\n\n                arr16 = new Uint16Array(2);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n                codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16);\n\n            } else {\n                // 2 bytes :     XXXXX         XXXX          XXXX              XXX\n                //           ' ObjectType' 'Freq Index' 'Channels value'   'GAS = 000'\n                codecPrivateData = new Uint8Array(2);\n                //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                codecPrivateData[1] = (indexFreq << 7) | (parseInt(qualityLevel.getAttribute('Channels'), 10) << 3);\n                // put the 2 bytes in an 16 bits array\n                arr16 = new Uint16Array(1);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                //convert decimal to hex value\n                codecPrivateDataHex = arr16[0].toString(16);\n            }\n\n            codecPrivateData = '' + codecPrivateDataHex;\n            codecPrivateData = codecPrivateData.toUpperCase();\n            qualityLevel.setAttribute('CodecPrivateData', codecPrivateData);\n        } else if (objectType === 0) {\n            objectType = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;\n        }\n\n        return 'mp4a.40.' + objectType;\n    }\n\n    function mapSegmentTemplate(streamIndex, timescale) {\n        const segmentTemplate = {};\n        let mediaUrl,\n            streamIndexTimeScale;\n\n        mediaUrl = streamIndex.getAttribute('Url').replace('{bitrate}', '$Bandwidth$');\n        mediaUrl = mediaUrl.replace('{start time}', '$Time$');\n\n        streamIndexTimeScale = streamIndex.getAttribute('TimeScale');\n        streamIndexTimeScale = streamIndexTimeScale ? parseFloat(streamIndexTimeScale) : timescale;\n\n        segmentTemplate.media = mediaUrl;\n        segmentTemplate.timescale = streamIndexTimeScale;\n\n        segmentTemplate.SegmentTimeline = mapSegmentTimeline(streamIndex, segmentTemplate.timescale);\n\n        return segmentTemplate;\n    }\n\n    function mapSegmentTimeline(streamIndex, timescale) {\n        const segmentTimeline = {};\n        const chunks = streamIndex.getElementsByTagName('c');\n        const segments = [];\n        let segment,\n            prevSegment,\n            tManifest,\n            i,j,r;\n        let duration = 0;\n\n        for (i = 0; i < chunks.length; i++) {\n            segment = {};\n\n            // Get time 't' attribute value\n            tManifest = chunks[i].getAttribute('t');\n\n            // => segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)\n            // => segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)\n            segment.tManifest = parseFloat(tManifest);\n            segment.t = parseFloat(tManifest);\n\n            // Get duration 'd' attribute value\n            segment.d = parseFloat(chunks[i].getAttribute('d'));\n\n            // If 't' not defined for first segment then t=0\n            if ((i === 0) && !segment.t) {\n                segment.t = 0;\n            }\n\n            if (i > 0) {\n                prevSegment = segments[segments.length - 1];\n                // Update previous segment duration if not defined\n                if (!prevSegment.d) {\n                    if (prevSegment.tManifest) {\n                        prevSegment.d = parseFloat(tManifest) - parseFloat(prevSegment.tManifest);\n                    } else {\n                        prevSegment.d = segment.t - prevSegment.t;\n                    }\n                    duration += prevSegment.d;\n                }\n                // Set segment absolute timestamp if not set in manifest\n                if (!segment.t) {\n                    if (prevSegment.tManifest) {\n                        segment.tManifest = parseFloat(prevSegment.tManifest) + prevSegment.d;\n                        segment.t = parseFloat(segment.tManifest);\n                    } else {\n                        segment.t = prevSegment.t + prevSegment.d;\n                    }\n                }\n            }\n\n            if (segment.d) {\n                duration += segment.d;\n            }\n\n            // Create new segment\n            segments.push(segment);\n\n            // Support for 'r' attribute (i.e. \"repeat\" as in MPEG-DASH)\n            r = parseFloat(chunks[i].getAttribute('r'));\n            if (r) {\n\n                for (j = 0; j < (r - 1); j++) {\n                    prevSegment = segments[segments.length - 1];\n                    segment = {};\n                    segment.t = prevSegment.t + prevSegment.d;\n                    segment.d = prevSegment.d;\n                    if (prevSegment.tManifest) {\n                        segment.tManifest  = parseFloat(prevSegment.tManifest) + prevSegment.d;\n                    }\n                    duration += segment.d;\n                    segments.push(segment);\n                }\n            }\n        }\n\n        segmentTimeline.S = segments;\n        segmentTimeline.S_asArray = segments;\n        segmentTimeline.duration = duration / timescale;\n\n        return segmentTimeline;\n    }\n\n    function getKIDFromProtectionHeader(protectionHeader) {\n        let prHeader,\n            wrmHeader,\n            xmlReader,\n            KID;\n\n        // Get PlayReady header as byte array (base64 decoded)\n        prHeader = BASE64.decodeArray(protectionHeader.firstChild.data);\n\n        // Get Right Management header (WRMHEADER) from PlayReady header\n        wrmHeader = getWRMHeaderFromPRHeader(prHeader);\n\n        // Convert from multi-byte to unicode\n        wrmHeader = new Uint16Array(wrmHeader.buffer);\n\n        // Convert to string\n        wrmHeader = String.fromCharCode.apply(null, wrmHeader);\n\n        // Parse <WRMHeader> to get KID field value\n        xmlReader = (new DOMParser()).parseFromString(wrmHeader, 'application/xml');\n        KID = xmlReader.querySelector('KID').textContent;\n\n        // Get KID (base64 decoded) as byte array\n        KID = BASE64.decodeArray(KID);\n\n        // Convert UUID from little-endian to big-endian\n        convertUuidEndianness(KID);\n\n        return KID;\n    }\n\n    function getWRMHeaderFromPRHeader(prHeader) {\n        let length,\n            recordCount,\n            recordType,\n            recordLength,\n            recordValue;\n        let i = 0;\n\n        // Parse PlayReady header\n\n        // Length - 32 bits (LE format)\n        length = (prHeader[i + 3] << 24) + (prHeader[i + 2] << 16) + (prHeader[i + 1] << 8) + prHeader[i];\n        i += 4;\n\n        // Record count - 16 bits (LE format)\n        recordCount = (prHeader[i + 1] << 8) + prHeader[i];\n        i += 2;\n\n        // Parse records\n        while (i < prHeader.length) {\n            // Record type - 16 bits (LE format)\n            recordType = (prHeader[i + 1] << 8) + prHeader[i];\n            i += 2;\n\n            // Check if Rights Management header (record type = 0x01)\n            if (recordType === 0x01) {\n\n                // Record length - 16 bits (LE format)\n                recordLength = (prHeader[i + 1] << 8) + prHeader[i];\n                i += 2;\n\n                // Record value => contains <WRMHEADER>\n                recordValue = new Uint8Array(recordLength);\n                recordValue.set(prHeader.subarray(i, i + recordLength));\n                return recordValue;\n            }\n        }\n\n        return null;\n    }\n\n    function convertUuidEndianness(uuid) {\n        swapBytes(uuid, 0, 3);\n        swapBytes(uuid, 1, 2);\n        swapBytes(uuid, 4, 5);\n        swapBytes(uuid, 6, 7);\n    }\n\n    function swapBytes(bytes, pos1, pos2) {\n        const temp = bytes[pos1];\n        bytes[pos1] = bytes[pos2];\n        bytes[pos2] = temp;\n    }\n\n\n    function createPRContentProtection(protectionHeader) {\n        let pro = {\n            __text: protectionHeader.firstChild.data,\n            __prefix: 'mspr'\n        };\n        return {\n            schemeIdUri: 'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95',\n            value: 'com.microsoft.playready',\n            pro: pro,\n            pro_asArray: pro\n        };\n    }\n\n    function createWidevineContentProtection(protectionHeader, KID) {\n        // Create Widevine CENC header (Protocol Buffer) with KID value\n        const wvCencHeader = new Uint8Array(2 + KID.length);\n        wvCencHeader[0] = 0x12;\n        wvCencHeader[1] = 0x10;\n        wvCencHeader.set(KID, 2);\n\n        // Create a pssh box\n        const length = 12 /* box length, type, version and flags */ + 16 /* SystemID */ + 4 /* data length */ + wvCencHeader.length;\n        let pssh = new Uint8Array(length);\n        let i = 0;\n\n        // Set box length value\n        pssh[i++] = (length & 0xFF000000) >> 24;\n        pssh[i++] = (length & 0x00FF0000) >> 16;\n        pssh[i++] = (length & 0x0000FF00) >> 8;\n        pssh[i++] = (length & 0x000000FF);\n\n        // Set type ('pssh'), version (0) and flags (0)\n        pssh.set([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00], i);\n        i += 8;\n\n        // Set SystemID ('edef8ba9-79d6-4ace-a3c8-27dcd51d21ed')\n        pssh.set([0xed, 0xef, 0x8b, 0xa9,  0x79, 0xd6, 0x4a, 0xce, 0xa3, 0xc8, 0x27, 0xdc, 0xd5, 0x1d, 0x21, 0xed], i);\n        i += 16;\n\n        // Set data length value\n        pssh[i++] = (wvCencHeader.length & 0xFF000000) >> 24;\n        pssh[i++] = (wvCencHeader.length & 0x00FF0000) >> 16;\n        pssh[i++] = (wvCencHeader.length & 0x0000FF00) >> 8;\n        pssh[i++] = (wvCencHeader.length & 0x000000FF);\n\n        // Copy Widevine CENC header\n        pssh.set(wvCencHeader, i);\n\n        // Convert to BASE64 string\n        pssh = String.fromCharCode.apply(null, pssh);\n        pssh = BASE64.encodeASCII(pssh);\n\n        return {\n            schemeIdUri: 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed',\n            value: 'com.widevine.alpha',\n            pssh: {\n                __text: pssh\n            }\n        };\n    }\n\n    function processManifest(xmlDoc, manifestLoadedTime) {\n        const manifest = {};\n        const contentProtections = [];\n        const smoothStreamingMedia = xmlDoc.getElementsByTagName('SmoothStreamingMedia')[0];\n        const protection = xmlDoc.getElementsByTagName('Protection')[0];\n        let protectionHeader = null;\n        let period,\n            adaptations,\n            contentProtection,\n            KID,\n            timestampOffset,\n            startTime,\n            segments,\n            timescale,\n            i, j;\n\n        // Set manifest node properties\n        manifest.protocol = 'MSS';\n        manifest.profiles = 'urn:mpeg:dash:profile:isoff-live:2011';\n        manifest.type = smoothStreamingMedia.getAttribute('IsLive') === 'TRUE' ? 'dynamic' : 'static';\n        timescale =  smoothStreamingMedia.getAttribute('TimeScale');\n        manifest.timescale = timescale ? parseFloat(timescale) : DEFAULT_TIME_SCALE;\n        let dvrWindowLength = parseFloat(smoothStreamingMedia.getAttribute('DVRWindowLength'));\n        if (dvrWindowLength === 0 && smoothStreamingMedia.getAttribute('CanSeek') === 'TRUE') {\n            dvrWindowLength = Infinity;\n        }\n        if (dvrWindowLength > 0) {\n            manifest.timeShiftBufferDepth = dvrWindowLength / manifest.timescale;\n        }\n\n        let duration = parseFloat(smoothStreamingMedia.getAttribute('Duration'));\n        manifest.mediaPresentationDuration = (duration === 0) ? Infinity : duration / manifest.timescale;\n        manifest.minBufferTime = mediaPlayerModel.getStableBufferTime();\n        manifest.ttmlTimeIsRelative = true;\n\n        // Live manifest with Duration = start-over\n        if (manifest.type === 'dynamic' && duration > 0) {\n            manifest.type = 'static';\n            // We set timeShiftBufferDepth to initial duration, to be used by MssFragmentController to update segment timeline\n            manifest.timeShiftBufferDepth = duration / manifest.timescale;\n            // Duration will be set according to current segment timeline duration (see below)\n        }\n\n        // In case of live streams, set availabilityStartTime property according to DVRWindowLength\n        if (manifest.type === 'dynamic'  && manifest.timeShiftBufferDepth < Infinity) {\n            manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (manifest.timeShiftBufferDepth * 1000));\n            manifest.refreshManifestOnSwitchTrack = true;\n            manifest.doNotUpdateDVRWindowOnBufferUpdated = true; // DVRWindow is update by MssFragmentMoofPocessor based on tfrf boxes\n            manifest.ignorePostponeTimePeriod = true; // Never update manifest\n        }\n\n        // Map period node to manifest root node\n        manifest.Period = mapPeriod(smoothStreamingMedia, manifest.timescale);\n        manifest.Period_asArray = [manifest.Period];\n\n        // Initialize period start time\n        period = manifest.Period;\n        period.start = 0;\n\n        // Uncomment to test live to static manifests\n        // if (manifest.type !== 'static') {\n        //     manifest.type = 'static';\n        //     manifest.mediaPresentationDuration = manifest.timeShiftBufferDepth;\n        //     manifest.timeShiftBufferDepth = null;\n        // }\n\n        // ContentProtection node\n        if (protection !== undefined) {\n            protectionHeader = xmlDoc.getElementsByTagName('ProtectionHeader')[0];\n\n            // Some packagers put newlines into the ProtectionHeader base64 string, which is not good\n            // because this cannot be correctly parsed. Let's just filter out any newlines found in there.\n            protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\\n|\\r/g, '');\n\n            // Get KID (in CENC format) from protection header\n            KID = getKIDFromProtectionHeader(protectionHeader);\n\n            // Create ContentProtection for PlayReady\n            contentProtection = createPRContentProtection(protectionHeader);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            // Create ContentProtection for Widevine (as a CENC protection)\n            contentProtection = createWidevineContentProtection(protectionHeader, KID);\n            contentProtection['cenc:default_KID'] = KID;\n            contentProtections.push(contentProtection);\n\n            manifest.ContentProtection = contentProtections;\n            manifest.ContentProtection_asArray = contentProtections;\n        }\n\n        adaptations = period.AdaptationSet_asArray;\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            adaptations[i].SegmentTemplate.initialization = '$Bandwidth$';\n            // Propagate content protection information into each adaptation\n            if (manifest.ContentProtection !== undefined) {\n                adaptations[i].ContentProtection = manifest.ContentProtection;\n                adaptations[i].ContentProtection_asArray = manifest.ContentProtection_asArray;\n            }\n\n            if (manifest.type === 'dynamic') {\n                // Set availabilityStartTime for infinite DVR Window from segment timeline duration\n                if (manifest.timeShiftBufferDepth === Infinity) {\n                    manifest.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (adaptations[i].SegmentTemplate.SegmentTimeline.duration * 1000));\n                }\n                // Match timeShiftBufferDepth to video segment timeline duration\n                if (manifest.timeShiftBufferDepth > 0 &&\n                    manifest.timeShiftBufferDepth !== Infinity &&\n                    adaptations[i].contentType === 'video' &&\n                    manifest.timeShiftBufferDepth > adaptations[i].SegmentTemplate.SegmentTimeline.duration) {\n                    manifest.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration;\n                }\n            }\n        }\n\n        if (manifest.timeShiftBufferDepth < manifest.minBufferTime) {\n            manifest.minBufferTime = manifest.timeShiftBufferDepth;\n        }\n\n        // Delete Content Protection under root manifest node\n        delete manifest.ContentProtection;\n        delete manifest.ContentProtection_asArray;\n\n        // In case of VOD streams, check if start time is greater than 0\n        // Then determine timestamp offset according to higher audio/video start time\n        // (use case = live stream delinearization)\n        if (manifest.type === 'static') {\n            // In case of start-over stream and manifest reloading (due to track switch)\n            // we consider previous timestampOffset to keep timelines synchronized\n            var prevManifest = manifestModel.getValue();\n            if (prevManifest && prevManifest.timestampOffset) {\n                timestampOffset = prevManifest.timestampOffset;\n            } else {\n                for (i = 0; i < adaptations.length; i++) {\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                        startTime = segments[0].t / adaptations[i].SegmentTemplate.timescale;\n                        if (timestampOffset === undefined) {\n                            timestampOffset = startTime;\n                        }\n                        timestampOffset = Math.min(timestampOffset, startTime);\n                        // Correct content duration according to minimum adaptation's segment timeline duration\n                        // in order to force <video> element sending 'ended' event\n                        manifest.mediaPresentationDuration = Math.min(manifest.mediaPresentationDuration, adaptations[i].SegmentTemplate.SegmentTimeline.duration);\n                    }\n                }\n            }\n            // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0)\n            if (timestampOffset > 0) {\n                manifest.timestampOffset = timestampOffset;\n                for (i = 0; i < adaptations.length; i++) {\n                    segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                    for (j = 0; j < segments.length; j++) {\n                        if (!segments[j].tManifest) {\n                            segments[j].tManifest = segments[j].t;\n                        }\n                        segments[j].t -= (timestampOffset * adaptations[i].SegmentTemplate.timescale);\n                    }\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        period.start = Math.max(segments[0].t, period.start);\n                        adaptations[i].SegmentTemplate.presentationTimeOffset = period.start;\n                    }\n                }\n                period.start /= manifest.timescale;\n            }\n        }\n\n        // Floor the duration to get around precision differences between segments timestamps and MSE buffer timestamps\n        // and the avoid 'ended' event not being raised\n        manifest.mediaPresentationDuration = Math.floor(manifest.mediaPresentationDuration * 1000) / 1000;\n        period.duration = manifest.mediaPresentationDuration;\n\n        return manifest;\n    }\n\n    function parseDOM(data) {\n        let xmlDoc = null;\n\n        if (window.DOMParser) {\n            const parser = new window.DOMParser();\n\n            xmlDoc = parser.parseFromString(data, 'text/xml');\n            if (xmlDoc.getElementsByTagName('parsererror').length > 0) {\n                throw new Error('parsing the manifest failed');\n            }\n        }\n\n        return xmlDoc;\n    }\n\n    function getMatchers() {\n        return null;\n    }\n\n    function getIron() {\n        return null;\n    }\n\n    function internalParse(data) {\n        let xmlDoc = null;\n        let manifest = null;\n\n        const startTime = window.performance.now();\n\n        // Parse the MSS XML manifest\n        xmlDoc = parseDOM(data);\n\n        const xmlParseTime = window.performance.now();\n\n        if (xmlDoc === null) {\n            return null;\n        }\n\n        // Convert MSS manifest into DASH manifest\n        manifest = processManifest(xmlDoc, new Date());\n\n        const mss2dashTime = window.performance.now();\n\n        logger.info('Parsing complete: (xmlParsing: ' + (xmlParseTime - startTime).toPrecision(3) + 'ms, mss2dash: ' + (mss2dashTime - xmlParseTime).toPrecision(3) + 'ms, total: ' + ((mss2dashTime - startTime) / 1000).toPrecision(3) + 's)');\n\n        return manifest;\n    }\n\n    instance = {\n        parse: internalParse,\n        getMatchers: getMatchers,\n        getIron: getIron\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssParser.__dashjs_factory_name = 'MssParser';\nexport default dashjs.FactoryMaker.getClassFactory(MssParser); /* jshint ignore:line */\n"]}