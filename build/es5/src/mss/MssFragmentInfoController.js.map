{"version":3,"sources":["../../../../src/mss/MssFragmentInfoController.js"],"names":["MssEvents","MSSFragmentMoofProcessor","FragmentRequest","MssFragmentInfoController","config","context","instance","logger","fragmentModel","started","type","bufferTimeout","startTime","startFragmentTime","index","streamProcessor","eventBus","metricsModel","playbackController","ISOBoxer","baseURLController","debug","controllerType","setup","getLogger","initialize","registerExternalController","getType","getFragmentModel","doStart","on","FRAGMENT_INFO_LOADING_COMPLETED","onFragmentInfoLoadedCompleted","Date","getTime","loadNextFragmentInfo","doStop","off","clearTimeout","reset","unregisterExternalController","representation","getCurrentRepresentation","manifest","adaptation","period","mpd","Period_asArray","AdaptationSet_asArray","segments","SegmentTemplate","SegmentTimeline","S_asArray","segment","length","t","timescale","request","getRequestForSegment","requestFragment","call","delayLoadNextFragmentInfo","delay","setTimeout","mediaType","duration","d","quality","mediaInfo","getMediaInfo","adaptationIndex","representationId","id","url","resolve","path","media","replace","bandwidth","tManifest","representationController","getRepresentationController","isFragmentLoadedOrPending","executeRequest","e","fragmentInfo","response","error","deltaFragmentTime","deltaTime","mssFragmentMoofProcessor","create","updateSegmentList","Math","max","fatal","start","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BA,MAAOA,UAAP,KAAsB,aAAtB,CACA,MAAOC,yBAAP,KAAqC,4BAArC,CACA,MAAOC,gBAAP,KAA4B,iCAA5B,CAEA,QAASC,0BAAT,CAAmCC,MAAnC,CAA2C,CAEvCA,OAASA,QAAU,EAAnB,CACA,KAAMC,SAAU,KAAKA,OAArB,CAEA,GAAIC,SAAJ,CACIC,MADJ,CAEIC,aAFJ,CAGIC,OAHJ,CAIIC,IAJJ,CAKIC,aALJ,CAMIC,SANJ,CAOIC,iBAPJ,CAQIC,KARJ,CAUA,KAAMC,iBAAkBX,OAAOW,eAA/B,CACA,KAAMC,UAAWZ,OAAOY,QAAxB,CACA,KAAMC,cAAeb,OAAOa,YAA5B,CACA,KAAMC,oBAAqBd,OAAOc,kBAAlC,CACA,KAAMC,UAAWf,OAAOe,QAAxB,CACA,KAAMC,mBAAoBhB,OAAOgB,iBAAjC,CACA,KAAMC,OAAQjB,OAAOiB,KAArB,CACA,KAAMC,gBAAiB,2BAAvB,CAEA,QAASC,MAAT,EAAiB,CACbhB,OAASc,MAAMG,SAAN,CAAgBlB,QAAhB,CAAT,CACH,CAED,QAASmB,WAAT,EAAsB,CAClBhB,QAAU,KAAV,CAEAG,UAAY,IAAZ,CACAC,kBAAoB,IAApB,CAEA;AACAE,gBAAgBW,0BAAhB,CAA2CpB,QAA3C,EACAI,KAAOK,gBAAgBY,OAAhB,EAAP,CACAnB,cAAgBO,gBAAgBa,gBAAhB,EAAhB,CACH,CAED,QAASC,QAAT,EAAmB,CACf,GAAIpB,UAAY,IAAhB,CAAsB,CAClB,OACH,CAEDF,OAAOc,KAAP,CAAa,UAAb,EAEAL,SAASc,EAAT,CAAY9B,UAAU+B,+BAAtB,CAAuDC,6BAAvD,CAAsF1B,QAAtF,EAEAG,QAAU,IAAV,CACAG,UAAY,GAAIqB,KAAJ,GAAWC,OAAX,EAAZ,CACApB,MAAQ,CAAR,CAEAqB,uBACH,CAED,QAASC,OAAT,EAAkB,CACd,GAAI,CAAC3B,OAAL,CAAc,CACV,OACH,CACDF,OAAOc,KAAP,CAAa,SAAb,EAEAL,SAASqB,GAAT,CAAarC,UAAU+B,+BAAvB,CAAwDC,6BAAxD,CAAuF1B,QAAvF,EAEA;AACAgC,aAAa3B,aAAb,EACAF,QAAU,KAAV,CAEAG,UAAY,IAAZ,CACAC,kBAAoB,IAApB,CACH,CAED,QAAS0B,MAAT,EAAiB,CACbH,SACArB,gBAAgByB,4BAAhB,CAA6ClC,QAA7C,EACH,CAED,QAAS6B,qBAAT,EAAgC,CAC5B;AACA,GAAI,CAAC1B,OAAL,CAAc,CACV,OACH,CAED;AACA,KAAMgC,gBAAiBC,0BAAvB,CACA,KAAMC,UAAWF,eAAeG,UAAf,CAA0BC,MAA1B,CAAiCC,GAAjC,CAAqCH,QAAtD,CACA,KAAMC,YAAaD,SAASI,cAAT,CAAwBN,eAAeG,UAAf,CAA0BC,MAA1B,CAAiC/B,KAAzD,EAAgEkC,qBAAhE,CAAsFP,eAAeG,UAAf,CAA0B9B,KAAhH,CAAnB,CACA,KAAMmC,UAAWL,WAAWM,eAAX,CAA2BC,eAA3B,CAA2CC,SAA5D,CACA,KAAMC,SAAUJ,SAASA,SAASK,MAAT,CAAkB,CAA3B,CAAhB,CAEA/C,OAAOc,KAAP,CAAa,uBAA0BgC,QAAQE,CAAR,CAAYX,WAAWM,eAAX,CAA2BM,SAA9E,EAEA;AACA,KAAMC,SAAUC,qBAAqBd,UAArB,CAAiCH,cAAjC,CAAiDY,OAAjD,CAAhB,CAEA;AACAM,gBAAgBC,IAAhB,CAAqB,IAArB,CAA2BH,OAA3B,EACH,CAED,QAASI,0BAAT,CAAmCC,KAAnC,CAA0C,CACtCxB,aAAa3B,aAAb,EACAA,cAAgBoD,WAAW,UAAY,CACnCpD,cAAgB,IAAhB,CACAwB,uBACH,CAHe,CAGb2B,MAAQ,IAHK,CAAhB,CAIH,CAED,QAASJ,qBAAT,CAA8Bd,UAA9B,CAA0CH,cAA1C,CAA0DY,OAA1D,CAAmE,CAC/D,GAAIG,WAAYZ,WAAWM,eAAX,CAA2BM,SAA3C,CACA,GAAIC,SAAU,GAAIvD,gBAAJ,EAAd,CAEAuD,QAAQO,SAAR,CAAoBtD,IAApB,CACA+C,QAAQ/C,IAAR,CAAe,qBAAf,CACA;AACA+C,QAAQ7C,SAAR,CAAoByC,QAAQE,CAAR,CAAYC,SAAhC,CACAC,QAAQQ,QAAR,CAAmBZ,QAAQa,CAAR,CAAYV,SAA/B,CACAC,QAAQD,SAAR,CAAoBA,SAApB,CACA;AACA;AACA;AACAC,QAAQU,OAAR,CAAkB1B,eAAe3B,KAAjC,CACA2C,QAAQ3C,KAAR,CAAgBA,OAAhB,CACA2C,QAAQW,SAAR,CAAoBrD,gBAAgBsD,YAAhB,EAApB,CACAZ,QAAQa,eAAR,CAA0B7B,eAAeG,UAAf,CAA0B9B,KAApD,CACA2C,QAAQc,gBAAR,CAA2B9B,eAAe+B,EAA1C,CACAf,QAAQgB,GAAR,CAAcrD,kBAAkBsD,OAAlB,CAA0BjC,eAAekC,IAAzC,EAA+CF,GAA/C,CAAqD7B,WAAWM,eAAX,CAA2B0B,KAA9F,CACAnB,QAAQgB,GAAR,CAAchB,QAAQgB,GAAR,CAAYI,OAAZ,CAAoB,aAApB,CAAmCpC,eAAeqC,SAAlD,CAAd,CACArB,QAAQgB,GAAR,CAAchB,QAAQgB,GAAR,CAAYI,OAAZ,CAAoB,QAApB,CAA8BxB,QAAQ0B,SAAR,CAAoB1B,QAAQ0B,SAA5B,CAAwC1B,QAAQE,CAA9E,CAAd,CACAE,QAAQgB,GAAR,CAAchB,QAAQgB,GAAR,CAAYI,OAAZ,CAAoB,aAApB,CAAmC,gBAAnC,CAAd,CAEA,MAAOpB,QAAP,CACH,CAED,QAASf,yBAAT,EAAoC,CAChC,KAAMsC,0BAA2BjE,gBAAgBkE,2BAAhB,EAAjC,CACA,KAAMxC,gBAAiBuC,yBAAyBtC,wBAAzB,EAAvB,CAEA,MAAOD,eAAP,CACH,CAED,QAASkB,gBAAT,CAAyBF,OAAzB,CAAkC,CAE9BlD,OAAOc,KAAP,CAAa,2BAA6BoC,QAAQ7C,SAAlD,EACA,GAAIG,gBAAgBa,gBAAhB,GAAmCsD,yBAAnC,CAA6DzB,OAA7D,CAAJ,CAA2E,CACvE;AACAlD,OAAOc,KAAP,CAAa,mBAAb,EACA,OACH,CAEDb,cAAc2E,cAAd,CAA6B1B,OAA7B,EACH,CAED,QAASzB,8BAAT,CAAuCoD,CAAvC,CAA0C,CACtC,GAAIA,EAAErE,eAAF,GAAsBA,eAA1B,CAA2C,CACvC,OACH,CAED,KAAM0C,SAAU2B,EAAEC,YAAF,CAAe5B,OAA/B,CACA,GAAI,CAAC2B,EAAEC,YAAF,CAAeC,QAApB,CAA8B,CAC1B/E,OAAOgF,KAAP,CAAa,YAAb,CAA2B9B,QAAQgB,GAAnC,EACA,OACH,CAED,GAAIe,kBAAJ,CACIC,SADJ,CAGAlF,OAAOc,KAAP,CAAa,uBAAb,CAAsCoC,QAAQgB,GAA9C,EAEA,GAAI,CAAC5D,iBAAL,CAAwB,CACpBA,kBAAoB4C,QAAQ7C,SAA5B,CACH,CAED,GAAI,CACA;AACA,KAAM8E,0BAA2BzF,yBAAyBI,OAAzB,EAAkCsF,MAAlC,CAAyC,CACtE1E,aAAcA,YADwD,CAEtEC,mBAAoBA,kBAFkD,CAGtEC,SAAUA,QAH4D,CAItEH,SAAUA,QAJ4D,CAKtEK,MAAOA,KAL+D,CAAzC,CAAjC,CAOAqE,yBAAyBE,iBAAzB,CAA2CR,EAAEC,YAA7C,CAA2DtE,eAA3D,EAEA0E,UAAY,CAAC,GAAIxD,KAAJ,GAAWC,OAAX,GAAuBtB,SAAxB,EAAqC,IAAjD,CACA4E,kBAAqB/B,QAAQ7C,SAAR,CAAoB6C,QAAQQ,QAA7B,CAAyCpD,iBAA7D,CACAgD,0BAA0BgC,KAAKC,GAAL,CAAS,CAAT,CAAaN,kBAAoBC,SAAjC,CAA1B,EACH,CAAC,MAAOL,CAAP,CAAU,CACR7E,OAAOwF,KAAP,CAAa,wDAAb,EACH,CACJ,CAED,QAASpE,QAAT,EAAmB,CACf,MAAOjB,KAAP,CACH,CAEDJ,SAAW,CACPmB,WAAYA,UADL,CAEPH,eAAgBA,cAFT,CAGP0E,MAAOnE,OAHA,CAIPF,QAASA,OAJF,CAKPY,MAAOA,KALA,CAAX,CAQAhB,QAEA,MAAOjB,SAAP,CACH,CAEDH,0BAA0B8F,qBAA1B,CAAkD,2BAAlD,CACA,cAAeC,QAAOC,YAAP,CAAoBC,eAApB,CAAoCjG,yBAApC,CAAf,CAA+E","file":"MssFragmentInfoController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport MssEvents from './MssEvents';\nimport MSSFragmentMoofProcessor from './MssFragmentMoofProcessor';\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\n\nfunction MssFragmentInfoController(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    let instance,\n        logger,\n        fragmentModel,\n        started,\n        type,\n        bufferTimeout,\n        startTime,\n        startFragmentTime,\n        index;\n\n    const streamProcessor = config.streamProcessor;\n    const eventBus = config.eventBus;\n    const metricsModel = config.metricsModel;\n    const playbackController = config.playbackController;\n    const ISOBoxer = config.ISOBoxer;\n    const baseURLController = config.baseURLController;\n    const debug = config.debug;\n    const controllerType = 'MssFragmentInfoController';\n\n    function setup() {\n        logger = debug.getLogger(instance);\n    }\n\n    function initialize() {\n        started = false;\n\n        startTime = null;\n        startFragmentTime = null;\n\n        // Register to StreamProcessor as external controller\n        streamProcessor.registerExternalController(instance);\n        type = streamProcessor.getType();\n        fragmentModel = streamProcessor.getFragmentModel();\n    }\n\n    function doStart() {\n        if (started === true) {\n            return;\n        }\n\n        logger.debug('Do start');\n\n        eventBus.on(MssEvents.FRAGMENT_INFO_LOADING_COMPLETED, onFragmentInfoLoadedCompleted, instance);\n\n        started = true;\n        startTime = new Date().getTime();\n        index = 0;\n\n        loadNextFragmentInfo();\n    }\n\n    function doStop() {\n        if (!started) {\n            return;\n        }\n        logger.debug('Do stop');\n\n        eventBus.off(MssEvents.FRAGMENT_INFO_LOADING_COMPLETED, onFragmentInfoLoadedCompleted, instance);\n\n        // Stop buffering process\n        clearTimeout(bufferTimeout);\n        started = false;\n\n        startTime = null;\n        startFragmentTime = null;\n    }\n\n    function reset() {\n        doStop();\n        streamProcessor.unregisterExternalController(instance);\n    }\n\n    function loadNextFragmentInfo() {\n        // Check if running state\n        if (!started) {\n            return;\n        }\n\n        // Get last segment from SegmentTimeline\n        const representation = getCurrentRepresentation();\n        const manifest = representation.adaptation.period.mpd.manifest;\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S_asArray;\n        const segment = segments[segments.length - 1];\n\n        logger.debug('Last fragment time: ' + (segment.t / adaptation.SegmentTemplate.timescale));\n\n        // Generate segment request\n        const request = getRequestForSegment(adaptation, representation, segment);\n\n        // Send segment request\n        requestFragment.call(this, request);\n    }\n\n    function delayLoadNextFragmentInfo(delay) {\n        clearTimeout(bufferTimeout);\n        bufferTimeout = setTimeout(function () {\n            bufferTimeout = null;\n            loadNextFragmentInfo();\n        }, delay * 1000);\n    }\n\n    function getRequestForSegment(adaptation, representation, segment) {\n        let timescale = adaptation.SegmentTemplate.timescale;\n        let request = new FragmentRequest();\n\n        request.mediaType = type;\n        request.type = 'FragmentInfoSegment';\n        // request.range = segment.mediaRange;\n        request.startTime = segment.t / timescale;\n        request.duration = segment.d / timescale;\n        request.timescale = timescale;\n        // request.availabilityStartTime = segment.availabilityStartTime;\n        // request.availabilityEndTime = segment.availabilityEndTime;\n        // request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = index++;\n        request.mediaInfo = streamProcessor.getMediaInfo();\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n        request.url = baseURLController.resolve(representation.path).url + adaptation.SegmentTemplate.media;\n        request.url = request.url.replace('$Bandwidth$', representation.bandwidth);\n        request.url = request.url.replace('$Time$', segment.tManifest ? segment.tManifest : segment.t);\n        request.url = request.url.replace('/Fragments(', '/FragmentInfo(');\n\n        return request;\n    }\n\n    function getCurrentRepresentation() {\n        const representationController = streamProcessor.getRepresentationController();\n        const representation = representationController.getCurrentRepresentation();\n\n        return representation;\n    }\n\n    function requestFragment(request) {\n\n        logger.debug('Load fragment for time: ' + request.startTime);\n        if (streamProcessor.getFragmentModel().isFragmentLoadedOrPending(request)) {\n            // We may have reached end of timeline in case of start-over streams\n            logger.debug('No more fragments');\n            return;\n        }\n\n        fragmentModel.executeRequest(request);\n    }\n\n    function onFragmentInfoLoadedCompleted(e) {\n        if (e.streamProcessor !== streamProcessor) {\n            return;\n        }\n\n        const request = e.fragmentInfo.request;\n        if (!e.fragmentInfo.response) {\n            logger.error('Load error', request.url);\n            return;\n        }\n\n        let deltaFragmentTime,\n            deltaTime;\n\n        logger.debug('FragmentInfo loaded: ', request.url);\n\n        if (!startFragmentTime) {\n            startFragmentTime = request.startTime;\n        }\n\n        try {\n            // Process FramgentInfo in order to update segment timeline (DVR window)\n            const mssFragmentMoofProcessor = MSSFragmentMoofProcessor(context).create({\n                metricsModel: metricsModel,\n                playbackController: playbackController,\n                ISOBoxer: ISOBoxer,\n                eventBus: eventBus,\n                debug: debug\n            });\n            mssFragmentMoofProcessor.updateSegmentList(e.fragmentInfo, streamProcessor);\n\n            deltaTime = (new Date().getTime() - startTime) / 1000;\n            deltaFragmentTime = (request.startTime + request.duration) - startFragmentTime;\n            delayLoadNextFragmentInfo(Math.max(0, (deltaFragmentTime - deltaTime)));\n        } catch (e) {\n            logger.fatal('Internal error while processing fragment info segment ');\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    instance = {\n        initialize: initialize,\n        controllerType: controllerType,\n        start: doStart,\n        getType: getType,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nMssFragmentInfoController.__dashjs_factory_name = 'MssFragmentInfoController';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentInfoController); /* jshint ignore:line */\n"]}