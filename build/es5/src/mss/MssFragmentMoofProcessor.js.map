{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":["DashJSError","MssErrors","Events","MssFragmentMoofProcessor","config","instance","type","logger","metricsModel","playbackController","errorHandler","errHandler","eventBus","ISOBoxer","debug","setup","getLogger","processTfrf","request","tfrf","tfdt","streamProcessor","representationController","getRepresentationController","representation","getCurrentRepresentation","indexHandler","getIndexHandler","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","timescale","SegmentTemplate","getType","timeShiftBufferDepth","error","MSS_NO_TFRF_CODE","MSS_NO_TFRF_MESSAGE","segments","SegmentTimeline","S","entries","entry","segmentTime","range","segment","t","availabilityStartTime","length","tManifest","parseFloat","fragment_absolute_time","start","end","baseMediaDecodeTime","duration","updateDVR","mediaType","getStreamInfo","manifestInfo","d","fragment_duration","push","trigger","MANIFEST_VALIDITY_CHANGED","sender","newDuration","Math","round","splice","updateSegmentList","dvrInfos","getMetricsFor","DVRInfo","addDVRInfo","getTime","getBoxOffset","parent","offset","i","boxes","size","convertFragment","e","sp","isoFile","parseBuffer","response","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","floor","startTime","trun","tfxd","_parent","indexOf","sepiff","usertype","undefined","saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","trafPosInMoof","sencPosInTraf","write","Error","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from '../streaming/vo/DashJSError';\nimport MssErrors from './errors/MssErrors';\n\nimport Events from '../streaming/MediaPlayerEvents';\n\n/**\n * @module MssFragmentMoovProcessor\n * @param {Object} config object\n */\nfunction MssFragmentMoofProcessor(config) {\n\n    config = config || {};\n    let instance,\n        type,\n        logger;\n    const metricsModel = config.metricsModel;\n    const playbackController = config.playbackController;\n    const errorHandler = config.errHandler;\n    const eventBus = config.eventBus;\n    const ISOBoxer = config.ISOBoxer;\n    const debug = config.debug;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        type = '';\n    }\n\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\n        const representationController = streamProcessor.getRepresentationController();\n        const representation = representationController.getCurrentRepresentation();\n        const indexHandler = streamProcessor.getIndexHandler();\n\n        const manifest = representation.adaptation.period.mpd.manifest;\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n        const timescale = adaptation.SegmentTemplate.timescale;\n\n        type = streamProcessor.getType();\n\n        if (manifest.type !== 'dynamic' && !manifest.timeShiftBufferDepth) {\n            return;\n        }\n\n        if (!tfrf) {\n            errorHandler.error(new DashJSError(MssErrors.MSS_NO_TFRF_CODE, MssErrors.MSS_NO_TFRF_MESSAGE));\n            return;\n        }\n\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S;\n        const entries = tfrf.entry;\n        let entry,\n            segmentTime,\n            range;\n        let segment = null;\n        let t = 0;\n        let availabilityStartTime = null;\n\n        if (entries.length === 0) {\n            return;\n        }\n\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\n        entry = entries[0];\n\n        // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)\n        // => then do not update anymore timeline\n        if (manifest.type === 'static') {\n            // Get first segment time\n            segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;\n            if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {\n                return;\n            }\n        }\n\n        logger.debug('entry - t = ', (entry.fragment_absolute_time / timescale));\n\n        // Get last segment time\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\n        logger.debug('Last segment - t = ', (segmentTime / timescale));\n\n        // Check if we have to append new segment to timeline\n        if (entry.fragment_absolute_time <= segmentTime) {\n            // Update DVR window range\n            // => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\n            return;\n        }\n\n        logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale));\n        segment = {};\n        segment.t = entry.fragment_absolute_time;\n        segment.d = entry.fragment_duration;\n        // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time\n        if (segments[0].tManifest) {\n            segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;\n            segment.tManifest = entry.fragment_absolute_time;\n        }\n        segments.push(segment);\n\n        // In case of static start-over streams, update content duration\n        if (manifest.type === 'static') {\n            if (type === 'video') {\n                segment = segments[segments.length - 1];\n                var end = (segment.t + segment.d) / timescale;\n                if (end > representation.adaptation.period.duration) {\n                    eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { sender: this, newDuration: end });\n                }\n            }\n            return;\n        }\n        // In case of live streams, update segment timeline according to DVR window\n        else if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n            // Get timestamp of the last segment\n            segment = segments[segments.length - 1];\n            t = segment.t;\n\n            // Determine the segments' availability start time\n            availabilityStartTime = Math.round((t - (manifest.timeShiftBufferDepth * timescale)) / timescale);\n\n            // Remove segments prior to availability start time\n            segment = segments[0];\n            while (Math.round(segment.t / timescale) < availabilityStartTime) {\n                logger.debug('Remove segment  - t = ' + (segment.t / timescale));\n                segments.splice(0, 1);\n                segment = segments[0];\n            }\n\n            // Update DVR window range => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(type, range, streamProcessor.getStreamInfo().manifestInfo);\n        }\n\n        indexHandler.updateSegmentList(representation);\n    }\n\n    function updateDVR(type, range, manifestInfo) {\n        const dvrInfos = metricsModel.getMetricsFor(type).DVRInfo;\n        if (dvrInfos) {\n            if (dvrInfos.length === 0 || (dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end)) {\n                logger.debug('Update DVR Infos [' + range.start + ' - ' + range.end + ']');\n                metricsModel.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\n            }\n        }\n    }\n\n    // This function returns the offset of the 1st byte of a child box within a container box\n    function getBoxOffset(parent, type) {\n        let offset = 8;\n        let i = 0;\n\n        for (i = 0; i < parent.boxes.length; i++) {\n            if (parent.boxes[i].type === type) {\n                return offset;\n            }\n            offset += parent.boxes[i].size;\n        }\n        return offset;\n    }\n\n    function convertFragment(e, sp) {\n        let i;\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        const traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        const trun = isoFile.fetch('trun');\n\n        // Process tfxd boxes\n        // This box provide absolute timestamp but we take the segment start time for tfdt\n        let tfxd = isoFile.fetch('tfxd');\n        if (tfxd) {\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\n            tfxd = null;\n        }\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, sp);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n        // => convert sepiff box it into a senc box\n        // => create saio and saiz boxes (if not already present)\n        const sepiff = isoFile.fetch('sepiff');\n        if (sepiff !== null) {\n            sepiff.type = 'senc';\n            sepiff.usertype = undefined;\n\n            let saio = isoFile.fetch('saio');\n            if (saio === null) {\n                // Create Sample Auxiliary Information Offsets Box box (saio)\n                saio = ISOBoxer.createFullBox('saio', traf);\n                saio.version = 0;\n                saio.flags = 0;\n                saio.entry_count = 1;\n                saio.offset = [0];\n\n                const saiz = ISOBoxer.createFullBox('saiz', traf);\n                saiz.version = 0;\n                saiz.flags = 0;\n                saiz.sample_count = sepiff.sample_count;\n                saiz.default_sample_info_size = 0;\n                saiz.sample_info_size = [];\n\n                if (sepiff.flags & 0x02) {\n                    // Sub-sample encryption => set sample_info_size for each sample\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                    }\n                } else {\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                    saiz.default_sample_info_size = 8;\n                }\n            }\n        }\n\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\n\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\n        const moof = isoFile.fetch('moof');\n        let length = moof.getLength();\n        trun.data_offset = length + 8;\n\n        // Update saio box offset field according to new senc box offset\n        let saio = isoFile.fetch('saio');\n        if (saio !== null) {\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\n            // Set offset from begin fragment to the first IV field in senc box\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n        }\n\n        // Write transformed/processed fragment into request reponse data\n        e.response = isoFile.write();\n    }\n\n    function updateSegmentList(e, sp) {\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            throw new Error('e.response parameter is missing');\n        }\n\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, sp);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    instance = {\n        convertFragment: convertFragment,\n        updateSegmentList: updateSegmentList,\n        getType: getType\n    };\n\n    setup();\n    return instance;\n}\n\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\n"]}