{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":["Debug","DashJSError","EventBus","Events","FactoryMaker","TextController","Errors","MAX_ALLOWED_DISCONTINUITY","SourceBufferSink","mediaSource","mediaInfo","onAppendedCallback","oldBuffer","context","eventBus","getInstance","instance","logger","buffer","isAppendingInProgress","intervalId","callbacks","appendQueue","onAppended","setup","getLogger","codec","match","Error","addSourceBuffer","changeType","debug","CHECK_INTERVAL","addEventListener","updateEndHandler","errHandler","err","setInterval","checkIsUpdateEnded","ex","isText","indexOf","textController","getTextSourceBuffer","reset","keepBuffer","removeEventListener","clearInterval","getClassName","removeSourceBuffer","e","error","getBuffer","getAllBufferRanges","buffered","message","hasDiscontinuitiesAfter","time","ranges","length","i","len","start","end","append","chunk","APPEND_ERROR_CODE","APPEND_ERROR_MESSAGE","push","waitForUpdateEnd","appendNextInQueue","bind","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","remove","forceRemoval","sourceBufferSink","readyState","trigger","SOURCEBUFFER_REMOVE_COMPLETED","from","to","unintended","code","nextChunk","splice","oldRanges","afterSuccess","newRanges","checkBufferGapsAfterAppend","call","bytes","appendBuffer","fatal","isChunkAlignedWithRange","Math","round","abort","setTextTrack","executeCallback","cb","shift","updating","type","callback","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"SourceBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\nimport Errors from '../core/errors/Errors';\n\nconst MAX_ALLOWED_DISCONTINUITY = 0.99; // 990 milliseconds\n\n/**\n * @class SourceBufferSink\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        buffer,\n        isAppendingInProgress,\n        intervalId;\n\n    let callbacks = [];\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        isAppendingInProgress = false;\n\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n            if (buffer.changeType && oldBuffer) {\n                logger.debug('Doing period transition with changeType');\n                buffer.changeType(codec);\n            }\n\n            const CHECK_INTERVAL = 50;\n            // use updateend event if possible\n            if (typeof buffer.addEventListener === 'function') {\n                try {\n                    buffer.addEventListener('updateend', updateEndHandler, false);\n                    buffer.addEventListener('error', errHandler, false);\n                    buffer.addEventListener('abort', errHandler, false);\n\n                } catch (err) {\n                    // use setInterval to periodically check if updating has been completed\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n                }\n            } else {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function reset(keepBuffer) {\n        if (buffer) {\n            if (typeof buffer.removeEventListener === 'function') {\n                buffer.removeEventListener('updateend', updateEndHandler, false);\n                buffer.removeEventListener('error', errHandler, false);\n                buffer.removeEventListener('abort', errHandler, false);\n            }\n            clearInterval(intervalId);\n            if (!keepBuffer) {\n                try {\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n                        mediaSource.removeSourceBuffer(buffer);\n                    }\n                } catch (e) {\n                    logger.error('Failed to remove source buffer from media source.');\n                }\n                buffer = null;\n            }\n            isAppendingInProgress = false;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        try {\n            return buffer.buffered;\n        } catch (e) {\n            logger.error('getAllBufferRanges exception: ' + e.message);\n            return null;\n        }\n    }\n\n    function hasDiscontinuitiesAfter(time) {\n        try {\n            const ranges = getAllBufferRanges();\n            if (ranges && ranges.length > 1) {\n                for (let i = 0, len = ranges.length; i < len; i++) {\n                    if (i > 0) {\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            logger.error('hasDiscontinuities exception: ' + e.message);\n        }\n        return false;\n    }\n\n    function append(chunk) {\n        if (!chunk) {\n            onAppended({\n                chunk: chunk,\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\n            });\n            return;\n        }\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(buffer, appendNextInQueue.bind(this));\n        }\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            waitForUpdateEnd(buffer, () => {\n                buffer.timestampOffset = MSETimeOffset;\n            });\n        }\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(buffer, function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end,\n                        unintended: false\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    unintended: false,\n                    error: new DashJSError(err.code, err.message)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        const sourceBufferSink = this;\n\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0,1);\n            let oldRanges = [];\n            const afterSuccess = function () {\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n                const newRanges = getAllBufferRanges();\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (nextChunk.bytes.length === 0) {\n                    afterSuccess.call(this);\n                } else {\n                    oldRanges = getAllBufferRanges();\n                    if (buffer.appendBuffer) {\n                        buffer.appendBuffer(nextChunk.bytes);\n                    } else {\n                        buffer.append(nextChunk.bytes, nextChunk);\n                    }\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                    waitForUpdateEnd(buffer, afterSuccess.bind(this));\n                }\n            } catch (err) {\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message)\n                    });\n                }\n            }\n        }\n    }\n\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\n            isChunkAlignedWithRange(oldRanges, chunk)) {\n            // A split in the range was created while appending\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                buffer: buffer,\n                from: newRanges.end(newRanges.length - 2),\n                to: newRanges.start(newRanges.length - 1),\n                unintended: true\n            });\n        }\n    }\n\n    function isChunkAlignedWithRange(oldRanges, chunk) {\n        for (let i = 0; i < oldRanges.length; i++ ) {\n            const start = Math.round(oldRanges.start(i));\n            const end = Math.round(oldRanges.end(i));\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end) ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n        appendQueue = [];\n    }\n\n    function executeCallback() {\n        if (callbacks.length > 0) {\n            const cb = callbacks.shift();\n            if (buffer.updating) {\n                waitForUpdateEnd(buffer, cb);\n            } else {\n                cb();\n                // Try to execute next callback if still not updating\n                executeCallback();\n            }\n        }\n    }\n\n    function checkIsUpdateEnded() {\n        // if updating is still in progress do nothing and wait for the next check again.\n        if (buffer.updating) return;\n        // updating is completed, now we can stop checking and resolve the promise\n        executeCallback();\n    }\n\n    function updateEndHandler() {\n        if (buffer.updating) return;\n\n        executeCallback();\n    }\n\n    function errHandler() {\n        logger.error('SourceBufferSink error', mediaInfo.type);\n    }\n\n    function waitForUpdateEnd(buffer, callback) {\n        callbacks.push(callback);\n\n        if (!buffer.updating) {\n            executeCallback();\n        }\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter\n    };\n\n    setup();\n\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]}