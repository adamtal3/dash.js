{"version":3,"sources":["../../../../../../src/streaming/rules/abr/ABRRulesCollection.js"],"names":["ThroughputRule","InsufficientBufferRule","AbandonRequestsRule","DroppedFramesRule","SwitchHistoryRule","BolaRule","FactoryMaker","SwitchRequest","QUALITY_SWITCH_RULES","ABANDON_FRAGMENT_RULES","ABRRulesCollection","config","context","mediaPlayerModel","metricsModel","dashMetrics","instance","qualitySwitchRules","abandonFragmentRules","initialize","getUseDefaultABRRules","push","create","customRules","getABRCustomRules","forEach","rule","type","getActiveRules","srArray","filter","sr","quality","NO_CHANGE","getMinSwitchRequest","values","i","len","req","newQuality","length","PRIORITY","STRONG","WEAK","DEFAULT","priority","Math","min","getMaxQuality","rulesContext","switchRequestArray","map","getMaxIndex","activeRules","maxQuality","shouldAbandonFragment","abandonRequestArray","shouldAbandon","reset","rules","__dashjs_factory_name","factory","getClassFactory","updateSingletonFactory"],"mappings":"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","file":"ABRRulesCollection.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport ThroughputRule from './ThroughputRule';\nimport InsufficientBufferRule from './InsufficientBufferRule';\nimport AbandonRequestsRule from './AbandonRequestsRule';\nimport DroppedFramesRule from './DroppedFramesRule';\nimport SwitchHistoryRule from './SwitchHistoryRule';\nimport BolaRule from './BolaRule';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport SwitchRequest from '../SwitchRequest';\n\nconst QUALITY_SWITCH_RULES = 'qualitySwitchRules';\nconst ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\n\nfunction ABRRulesCollection(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const metricsModel = config.metricsModel;\n    const dashMetrics = config.dashMetrics;\n\n    let instance,\n        qualitySwitchRules,\n        abandonFragmentRules;\n\n    function initialize() {\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n\n        if (mediaPlayerModel.getUseDefaultABRRules()) {\n            // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\n            // This is controlled by useBufferOccupancyABR mechanism in AbrController.\n            qualitySwitchRules.push(\n                BolaRule(context).create({\n                    metricsModel: metricsModel,\n                    dashMetrics: dashMetrics,\n                    mediaPlayerModel: mediaPlayerModel\n                })\n            );\n            qualitySwitchRules.push(\n                ThroughputRule(context).create({\n                    metricsModel: metricsModel,\n                    dashMetrics: dashMetrics\n                })\n            );\n            qualitySwitchRules.push(\n                InsufficientBufferRule(context).create({\n                    metricsModel: metricsModel,\n                    dashMetrics: dashMetrics\n                })\n            );\n            qualitySwitchRules.push(\n                SwitchHistoryRule(context).create()\n            );\n            qualitySwitchRules.push(\n                DroppedFramesRule(context).create()\n            );\n            abandonFragmentRules.push(\n                AbandonRequestsRule(context).create({\n                    metricsModel: metricsModel,\n                    dashMetrics: dashMetrics,\n                    mediaPlayerModel: mediaPlayerModel\n                })\n            );\n        }\n\n        // add custom ABR rules if any\n        const customRules = mediaPlayerModel.getABRCustomRules();\n        customRules.forEach(function (rule) {\n            if (rule.type === QUALITY_SWITCH_RULES) {\n                qualitySwitchRules.push(rule.rule(context).create());\n            }\n\n            if (rule.type === ABANDON_FRAGMENT_RULES) {\n                abandonFragmentRules.push(rule.rule(context).create());\n            }\n        });\n    }\n\n    function getActiveRules(srArray) {\n        return srArray.filter(sr => sr.quality > SwitchRequest.NO_CHANGE);\n    }\n\n    function getMinSwitchRequest(srArray) {\n        const values = {};\n        let i,\n            len,\n            req,\n            newQuality,\n            quality;\n\n        if (srArray.length === 0) {\n            return;\n        }\n\n        values[SwitchRequest.PRIORITY.STRONG] = SwitchRequest.NO_CHANGE;\n        values[SwitchRequest.PRIORITY.WEAK] = SwitchRequest.NO_CHANGE;\n        values[SwitchRequest.PRIORITY.DEFAULT] = SwitchRequest.NO_CHANGE;\n\n        for (i = 0, len = srArray.length; i < len; i += 1) {\n            req = srArray[i];\n            if (req.quality !== SwitchRequest.NO_CHANGE) {\n                values[req.priority] = values[req.priority] > SwitchRequest.NO_CHANGE ? Math.min(values[req.priority], req.quality) : req.quality;\n            }\n        }\n\n        if (values[SwitchRequest.PRIORITY.WEAK] !== SwitchRequest.NO_CHANGE) {\n            newQuality = values[SwitchRequest.PRIORITY.WEAK];\n        }\n\n        if (values[SwitchRequest.PRIORITY.DEFAULT] !== SwitchRequest.NO_CHANGE) {\n            newQuality = values[SwitchRequest.PRIORITY.DEFAULT];\n        }\n\n        if (values[SwitchRequest.PRIORITY.STRONG] !== SwitchRequest.NO_CHANGE) {\n            newQuality = values[SwitchRequest.PRIORITY.STRONG];\n        }\n\n        if (newQuality !== SwitchRequest.NO_CHANGE) {\n            quality = newQuality;\n        }\n\n        return SwitchRequest(context).create(quality);\n    }\n\n    function getMaxQuality(rulesContext) {\n        const switchRequestArray = qualitySwitchRules.map(rule => rule.getMaxIndex(rulesContext));\n        const activeRules = getActiveRules(switchRequestArray);\n        const maxQuality = getMinSwitchRequest(activeRules);\n\n        return maxQuality || SwitchRequest(context).create();\n    }\n\n    function shouldAbandonFragment(rulesContext) {\n        const abandonRequestArray = abandonFragmentRules.map(rule => rule.shouldAbandon(rulesContext));\n        const activeRules = getActiveRules(abandonRequestArray);\n        const shouldAbandon = getMinSwitchRequest(activeRules);\n\n        return shouldAbandon || SwitchRequest(context).create();\n    }\n\n    function reset() {\n        [qualitySwitchRules, abandonFragmentRules].forEach(rules => {\n            if (rules && rules.length) {\n                rules.forEach(rule => rule.reset && rule.reset());\n            }\n        });\n        qualitySwitchRules = [];\n        abandonFragmentRules = [];\n    }\n\n    instance = {\n        initialize: initialize,\n        reset: reset,\n        getMaxQuality: getMaxQuality,\n        shouldAbandonFragment: shouldAbandonFragment\n    };\n\n    return instance;\n}\n\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\nconst factory = FactoryMaker.getClassFactory(ABRRulesCollection);\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\nFactoryMaker.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\n\nexport default factory;\n"]}