{"version":3,"sources":["../../../../../../src/streaming/rules/abr/AbandonRequestsRule.js"],"names":["SwitchRequest","FactoryMaker","Debug","AbandonRequestsRule","config","ABANDON_MULTIPLIER","GRACE_TIME_THRESHOLD","MIN_LENGTH_TO_AVERAGE","context","mediaPlayerModel","metricsModel","dashMetrics","instance","logger","fragmentDict","abandonDict","throughputArray","setup","getInstance","getLogger","reset","setFragmentRequestDict","type","id","storeLastRequestThroughputByType","throughput","push","shouldAbandon","rulesContext","switchRequest","create","NO_CHANGE","name","__dashjs_factory_name","hasOwnProperty","mediaInfo","getMediaInfo","mediaType","getMediaType","req","getCurrentRequest","isNaN","index","stableBufferTime","getStableBufferTime","bufferLevel","getCurrentBufferLevel","getReadOnlyMetricsFor","fragmentInfo","firstByteDate","firstByteTime","undefined","getTime","segmentDuration","duration","bytesTotal","bytesLoaded","elapsedTime","Date","Math","round","length","totalSampledValue","reduce","a","b","measuredBandwidthInKbps","estimatedTimeOfDownload","toFixed","getRepresentationInfo","quality","abrController","getAbrController","bytesRemaining","bitrateList","getBitrateList","newQuality","getQualityForBitrate","getBandwidthSafetyFactor","estimateOtherBytesTotal","bitrate","getQualityFor","streamInfo","reason","fragmentID","debug","getClassFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAOA,aAAP,MAA0B,kBAA1B;AACA,OAAOC,YAAP,MAAyB,4BAAzB;AACA,OAAOC,KAAP,MAAkB,qBAAlB;;AAEA,SAASC,mBAAT,CAA6BC,MAA7B,EAAqC;;AAEjCA,aAASA,UAAU,EAAnB;AACA,UAAMC,qBAAqB,GAA3B;AACA,UAAMC,uBAAuB,GAA7B;AACA,UAAMC,wBAAwB,CAA9B;;AAEA,UAAMC,UAAU,KAAKA,OAArB;AACA,UAAMC,mBAAmBL,OAAOK,gBAAhC;AACA,UAAMC,eAAeN,OAAOM,YAA5B;AACA,UAAMC,cAAcP,OAAOO,WAA3B;;AAEA,QAAIC,QAAJ,EACIC,MADJ,EAEIC,YAFJ,EAGIC,WAHJ,EAIIC,eAJJ;;AAMA,aAASC,KAAT,GAAiB;AACbJ,iBAASX,MAAMM,OAAN,EAAeU,WAAf,GAA6BC,SAA7B,CAAuCP,QAAvC,CAAT;AACAQ;AACH;;AAED,aAASC,sBAAT,CAAgCC,IAAhC,EAAsCC,EAAtC,EAA0C;AACtCT,qBAAaQ,IAAb,IAAqBR,aAAaQ,IAAb,KAAsB,EAA3C;AACAR,qBAAaQ,IAAb,EAAmBC,EAAnB,IAAyBT,aAAaQ,IAAb,EAAmBC,EAAnB,KAA0B,EAAnD;AACH;;AAED,aAASC,gCAAT,CAA0CF,IAA1C,EAAgDG,UAAhD,EAA4D;AACxDT,wBAAgBM,IAAhB,IAAwBN,gBAAgBM,IAAhB,KAAyB,EAAjD;AACAN,wBAAgBM,IAAhB,EAAsBI,IAAtB,CAA2BD,UAA3B;AACH;;AAED,aAASE,aAAT,CAAuBC,YAAvB,EAAqC;AACjC,cAAMC,gBAAgB7B,cAAcQ,OAAd,EAAuBsB,MAAvB,CAA8B9B,cAAc+B,SAA5C,EAAuD,EAACC,MAAM7B,oBAAoB8B,qBAA3B,EAAvD,CAAtB;;AAEA,YAAI,CAACL,YAAD,IAAiB,CAACA,aAAaM,cAAb,CAA4B,cAA5B,CAAlB,IAAiE,CAACN,aAAaM,cAAb,CAA4B,cAA5B,CAAlE,IAAiH,CAACN,aAAaM,cAAb,CAA4B,mBAA5B,CAAlH,IACA,CAACN,aAAaM,cAAb,CAA4B,uBAA5B,CADD,IACyD,CAACN,aAAaM,cAAb,CAA4B,kBAA5B,CAD9D,EAC+G;AAC3G,mBAAOL,aAAP;AACH;;AAED,cAAMM,YAAYP,aAAaQ,YAAb,EAAlB;AACA,cAAMC,YAAYT,aAAaU,YAAb,EAAlB;AACA,cAAMC,MAAMX,aAAaY,iBAAb,EAAZ;;AAEA,YAAI,CAACC,MAAMF,IAAIG,KAAV,CAAL,EAAuB;AACnBrB,mCAAuBgB,SAAvB,EAAkCE,IAAIG,KAAtC;;AAEA,kBAAMC,mBAAmBlC,iBAAiBmC,mBAAjB,EAAzB;AACA,kBAAMC,cAAclC,YAAYmC,qBAAZ,CAAkCpC,aAAaqC,qBAAb,CAAmCV,SAAnC,CAAlC,CAApB;AACA,gBAAKQ,cAAcF,gBAAnB,EAAsC;AAClC,uBAAOd,aAAP;AACH;;AAED,kBAAMmB,eAAelC,aAAauB,SAAb,EAAwBE,IAAIG,KAA5B,CAArB;AACA,gBAAIM,iBAAiB,IAAjB,IAAyBT,IAAIU,aAAJ,KAAsB,IAA/C,IAAuDlC,YAAYmB,cAAZ,CAA2Bc,aAAazB,EAAxC,CAA3D,EAAwG;AACpG,uBAAOM,aAAP;AACH;;AAED;AACA,gBAAImB,aAAaE,aAAb,KAA+BC,SAAnC,EAA8C;AAC1CnC,gCAAgBqB,SAAhB,IAA6B,EAA7B;AACAW,6BAAaE,aAAb,GAA6BX,IAAIU,aAAJ,CAAkBG,OAAlB,EAA7B;AACAJ,6BAAaK,eAAb,GAA+Bd,IAAIe,QAAnC;AACAN,6BAAaO,UAAb,GAA0BhB,IAAIgB,UAA9B;AACAP,6BAAazB,EAAb,GAAkBgB,IAAIG,KAAtB;AACH;AACDM,yBAAaQ,WAAb,GAA2BjB,IAAIiB,WAA/B;AACAR,yBAAaS,WAAb,GAA2B,IAAIC,IAAJ,GAAWN,OAAX,KAAuBJ,aAAaE,aAA/D;;AAEA,gBAAIF,aAAaQ,WAAb,GAA2B,CAA3B,IAAgCR,aAAaS,WAAb,GAA2B,CAA/D,EAAkE;AAC9DjC,iDAAiCa,SAAjC,EAA4CsB,KAAKC,KAAL,CAAWZ,aAAaQ,WAAb,GAA2B,CAA3B,GAA+BR,aAAaS,WAAvD,CAA5C;AACH;;AAED,gBAAIzC,gBAAgBqB,SAAhB,EAA2BwB,MAA3B,IAAqCtD,qBAArC,IACAyC,aAAaS,WAAb,GAA2BnD,oBAD3B,IAEA0C,aAAaQ,WAAb,GAA2BR,aAAaO,UAF5C,EAEwD;;AAEpD,sBAAMO,oBAAoB9C,gBAAgBqB,SAAhB,EAA2B0B,MAA3B,CAAkC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,IAAIC,CAAhD,EAAmD,CAAnD,CAA1B;AACAjB,6BAAakB,uBAAb,GAAuCP,KAAKC,KAAL,CAAWE,oBAAoB9C,gBAAgBqB,SAAhB,EAA2BwB,MAA1D,CAAvC;AACAb,6BAAamB,uBAAb,GAAuC,CAAC,CAAEnB,aAAaO,UAAb,GAA0B,CAA1B,GAA8BP,aAAakB,uBAA5C,GAAuE,IAAxE,EAA8EE,OAA9E,CAAsF,CAAtF,CAAxC;;AAEA,oBAAIpB,aAAamB,uBAAb,GAAuCnB,aAAaK,eAAb,GAA+BhD,kBAAtE,IAA4FuB,aAAayC,qBAAb,GAAqCC,OAArC,KAAiD,CAAjJ,EAAqJ;AACjJ,2BAAOzC,aAAP;AACH,iBAFD,MAEO,IAAI,CAACd,YAAYmB,cAAZ,CAA2Bc,aAAazB,EAAxC,CAAL,EAAkD;;AAErD,0BAAMgD,gBAAgB3C,aAAa4C,gBAAb,EAAtB;AACA,0BAAMC,iBAAiBzB,aAAaO,UAAb,GAA0BP,aAAaQ,WAA9D;AACA,0BAAMkB,cAAcH,cAAcI,cAAd,CAA6BxC,SAA7B,CAApB;AACA,0BAAMyC,aAAaL,cAAcM,oBAAd,CAAmC1C,SAAnC,EAA8Ca,aAAakB,uBAAb,GAAuCzD,iBAAiBqE,wBAAjB,EAArF,CAAnB;AACA,0BAAMC,0BAA0B/B,aAAaO,UAAb,GAA0BmB,YAAYE,UAAZ,EAAwBI,OAAlD,GAA4DN,YAAYH,cAAcU,aAAd,CAA4B5C,SAA5B,EAAuCF,UAAU+C,UAAjD,CAAZ,EAA0EF,OAAtK;;AAEA,wBAAIP,iBAAiBM,uBAArB,EAA8C;AAC1ClD,sCAAcyC,OAAd,GAAwBM,UAAxB;AACA/C,sCAAcsD,MAAd,CAAqB1D,UAArB,GAAkCuB,aAAakB,uBAA/C;AACArC,sCAAcsD,MAAd,CAAqBC,UAArB,GAAkCpC,aAAazB,EAA/C;AACAR,oCAAYiC,aAAazB,EAAzB,IAA+ByB,YAA/B;AACAnC,+BAAOwE,KAAP,CAAa,IAAb,EAAmBhD,SAAnB,EAA8B,SAA9B,EAAwCW,aAAazB,EAArD,EAAwD,kDAAxD,EAA4GqD,UAA5G,EAAwH,yBAAxH,EAAmJ5B,aAAakB,uBAAhK;AACA,+BAAOpD,aAAauB,SAAb,EAAwBW,aAAazB,EAArC,CAAP;AACH;AACJ;AACJ,aA3BD,MA2BO,IAAIyB,aAAaQ,WAAb,KAA6BR,aAAaO,UAA9C,EAA0D;AAC7D,uBAAOzC,aAAauB,SAAb,EAAwBW,aAAazB,EAArC,CAAP;AACH;AACJ;;AAED,eAAOM,aAAP;AACH;;AAED,aAAST,KAAT,GAAiB;AACbN,uBAAe,EAAf;AACAC,sBAAc,EAAd;AACAC,0BAAkB,EAAlB;AACH;;AAEDJ,eAAW;AACPe,uBAAeA,aADR;AAEPP,eAAOA;AAFA,KAAX;;AAKAH;;AAEA,WAAOL,QAAP;AACH;;AAEDT,oBAAoB8B,qBAApB,GAA4C,qBAA5C;AACA,eAAehC,aAAaqF,eAAb,CAA6BnF,mBAA7B,CAAf","file":"AbandonRequestsRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\n\nfunction AbandonRequestsRule(config) {\n\n    config = config || {};\n    const ABANDON_MULTIPLIER = 1.8;\n    const GRACE_TIME_THRESHOLD = 500;\n    const MIN_LENGTH_TO_AVERAGE = 5;\n\n    const context = this.context;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const metricsModel = config.metricsModel;\n    const dashMetrics = config.dashMetrics;\n\n    let instance,\n        logger,\n        fragmentDict,\n        abandonDict,\n        throughputArray;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        reset();\n    }\n\n    function setFragmentRequestDict(type, id) {\n        fragmentDict[type] = fragmentDict[type] || {};\n        fragmentDict[type][id] = fragmentDict[type][id] || {};\n    }\n\n    function storeLastRequestThroughputByType(type, throughput) {\n        throughputArray[type] = throughputArray[type] || [];\n        throughputArray[type].push(throughput);\n    }\n\n    function shouldAbandon(rulesContext) {\n        const switchRequest = SwitchRequest(context).create(SwitchRequest.NO_CHANGE, {name: AbandonRequestsRule.__dashjs_factory_name});\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getCurrentRequest') ||\n            !rulesContext.hasOwnProperty('getRepresentationInfo') || !rulesContext.hasOwnProperty('getAbrController')) {\n            return switchRequest;\n        }\n\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const req = rulesContext.getCurrentRequest();\n\n        if (!isNaN(req.index)) {\n            setFragmentRequestDict(mediaType, req.index);\n\n            const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n            if ( bufferLevel > stableBufferTime ) {\n                return switchRequest;\n            }\n\n            const fragmentInfo = fragmentDict[mediaType][req.index];\n            if (fragmentInfo === null || req.firstByteDate === null || abandonDict.hasOwnProperty(fragmentInfo.id)) {\n                return switchRequest;\n            }\n\n            //setup some init info based on first progress event\n            if (fragmentInfo.firstByteTime === undefined) {\n                throughputArray[mediaType] = [];\n                fragmentInfo.firstByteTime = req.firstByteDate.getTime();\n                fragmentInfo.segmentDuration = req.duration;\n                fragmentInfo.bytesTotal = req.bytesTotal;\n                fragmentInfo.id = req.index;\n            }\n            fragmentInfo.bytesLoaded = req.bytesLoaded;\n            fragmentInfo.elapsedTime = new Date().getTime() - fragmentInfo.firstByteTime;\n\n            if (fragmentInfo.bytesLoaded > 0 && fragmentInfo.elapsedTime > 0) {\n                storeLastRequestThroughputByType(mediaType, Math.round(fragmentInfo.bytesLoaded * 8 / fragmentInfo.elapsedTime));\n            }\n\n            if (throughputArray[mediaType].length >= MIN_LENGTH_TO_AVERAGE &&\n                fragmentInfo.elapsedTime > GRACE_TIME_THRESHOLD &&\n                fragmentInfo.bytesLoaded < fragmentInfo.bytesTotal) {\n\n                const totalSampledValue = throughputArray[mediaType].reduce((a, b) => a + b, 0);\n                fragmentInfo.measuredBandwidthInKbps = Math.round(totalSampledValue / throughputArray[mediaType].length);\n                fragmentInfo.estimatedTimeOfDownload = +((fragmentInfo.bytesTotal * 8 / fragmentInfo.measuredBandwidthInKbps) / 1000).toFixed(2);\n\n                if (fragmentInfo.estimatedTimeOfDownload < fragmentInfo.segmentDuration * ABANDON_MULTIPLIER || rulesContext.getRepresentationInfo().quality === 0 ) {\n                    return switchRequest;\n                } else if (!abandonDict.hasOwnProperty(fragmentInfo.id)) {\n\n                    const abrController = rulesContext.getAbrController();\n                    const bytesRemaining = fragmentInfo.bytesTotal - fragmentInfo.bytesLoaded;\n                    const bitrateList = abrController.getBitrateList(mediaInfo);\n                    const newQuality = abrController.getQualityForBitrate(mediaInfo, fragmentInfo.measuredBandwidthInKbps * mediaPlayerModel.getBandwidthSafetyFactor());\n                    const estimateOtherBytesTotal = fragmentInfo.bytesTotal * bitrateList[newQuality].bitrate / bitrateList[abrController.getQualityFor(mediaType, mediaInfo.streamInfo)].bitrate;\n\n                    if (bytesRemaining > estimateOtherBytesTotal) {\n                        switchRequest.quality = newQuality;\n                        switchRequest.reason.throughput = fragmentInfo.measuredBandwidthInKbps;\n                        switchRequest.reason.fragmentID = fragmentInfo.id;\n                        abandonDict[fragmentInfo.id] = fragmentInfo;\n                        logger.debug('( ', mediaType, 'frag id',fragmentInfo.id,') is asking to abandon and switch to quality to ', newQuality, ' measured bandwidth was', fragmentInfo.measuredBandwidthInKbps);\n                        delete fragmentDict[mediaType][fragmentInfo.id];\n                    }\n                }\n            } else if (fragmentInfo.bytesLoaded === fragmentInfo.bytesTotal) {\n                delete fragmentDict[mediaType][fragmentInfo.id];\n            }\n        }\n\n        return switchRequest;\n    }\n\n    function reset() {\n        fragmentDict = {};\n        abandonDict = {};\n        throughputArray = [];\n    }\n\n    instance = {\n        shouldAbandon: shouldAbandon,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nAbandonRequestsRule.__dashjs_factory_name = 'AbandonRequestsRule';\nexport default FactoryMaker.getClassFactory(AbandonRequestsRule);\n"]}