{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":["MetricsConstants","SwitchRequest","FactoryMaker","HTTPRequest","EventBus","Events","Debug","BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","BolaRule","config","context","dashMetrics","metricsModel","mediaPlayerModel","eventBus","getInstance","instance","logger","bolaStateDict","setup","getLogger","resetInitialSettings","on","BUFFER_EMPTY","onBufferEmpty","PLAYBACK_SEEKING","onPlaybackSeeking","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","METRIC_ADDED","onMetricAdded","QUALITY_CHANGE_REQUESTED","onQualityChangeRequested","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","utilitiesFromBitrates","bitrates","map","b","Math","log","calculateBolaParameters","stableBufferTime","utilities","highestUtilityIndex","reduce","highestIndex","u","uIndex","bufferTime","max","length","gp","Vp","getInitialBolaState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrateList","bandwidth","getStableBufferTime","params","state","lastQuality","clearBolaStateOnSeek","bolaState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","checkBolaStateStableBufferTime","mediaType","bufferLevel","getCurrentBufferLevel","getReadOnlyMetricsFor","effectiveBufferLevel","getBolaState","getMediaType","getQualityFromBufferLevel","bitrateCount","quality","score","i","s","isNaN","maxBufferLevelForQuality","minBufferLevelForQuality","qBitrate","qUtility","min","iBitrate","iUtility","level","updatePlaceholderBuffer","nowMs","Date","now","delay","lastCallTimeMs","hasOwnProperty","e","chunk","type","start","duration","checkNewSegment","metric","HTTP_REQUEST","value","MEDIA_SEGMENT_TYPE","trace","trequest","getTime","_tfinish","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxPlaceholderBuffer","abrQuality","newQuality","wantEffectiveBufferLevel","getMaxIndex","metrics","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","streamId","id","isDynamic","manifestInfo","useBufferOccupancyABR","switchRequest","create","reason","setTimeToLoadDelay","throughput","getAverageThroughput","safeThroughput","getSafeAverageThroughput","latency","getAverageLatency","getQualityForBitrate","qualityForThroughput","delayS","getTopQualityIndexFor","debug","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const metricsModel = config.metricsModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        bolaStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        const qBitrate = bolaState.bitrates[quality];\n        const qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                const iBitrate = bolaState.bitrates[i];\n                const iUtility = bolaState.utilities[i];\n\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        const nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                const bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onPeriodSwitchStarted() {\n        // TODO: does this have to be handled here?\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(e.mediaType));\n                let wantEffectiveBufferLevel;\n                if (bolaState.abrQuality > 0) {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n                } else {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                }\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        const switchRequest = SwitchRequest(context).create();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                logger.debug('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]}