{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":["BufferController","EventBus","Events","FactoryMaker","Debug","SwitchRequest","Constants","InsufficientBufferRule","config","INSUFFICIENT_BUFFER_SAFETY_FACTOR","context","eventBus","getInstance","metricsModel","dashMetrics","instance","logger","bufferStateDict","setup","getLogger","resetInitialSettings","on","PLAYBACK_SEEKING","onPlaybackSeeking","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getMaxIndex","rulesContext","switchRequest","create","mediaType","getMediaType","metrics","getReadOnlyMetricsFor","lastBufferStateVO","BufferState","length","representationInfo","getRepresentationInfo","fragmentDuration","wasFirstBufferLoadedEventTriggered","state","BUFFER_EMPTY","debug","quality","reason","mediaInfo","getMediaInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","bufferLevel","getCurrentBufferLevel","throughput","getAverageThroughput","latency","getAverageLatency","bitrate","getQualityForBitrate","currentBufferState","wasTriggered","firstBufferLoadedEvent","BUFFER_LOADED","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"InsufficientBufferRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport BufferController from '../../controllers/BufferController';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\nimport SwitchRequest from '../SwitchRequest';\nimport Constants from '../../constants/Constants';\n\nfunction InsufficientBufferRule(config) {\n\n    config = config || {};\n    const INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\n\n    const context = this.context;\n\n    const eventBus = EventBus(context).getInstance();\n    const metricsModel = config.metricsModel;\n    const dashMetrics = config.dashMetrics;\n\n    let instance,\n        logger,\n        bufferStateDict;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    }\n\n    function checkConfig() {\n        if (!metricsModel || !metricsModel.hasOwnProperty('getReadOnlyMetricsFor') || !dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n    /*\n     * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\n     *\n     * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\n     *\n     * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\n     * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\n     * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\n     * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\n     */\n    function getMaxIndex (rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\n            return switchRequest;\n        }\n\n        checkConfig();\n\n        const mediaType = rulesContext.getMediaType();\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        const lastBufferStateVO = (metrics.BufferState.length > 0) ? metrics.BufferState[metrics.BufferState.length - 1] : null;\n        const representationInfo = rulesContext.getRepresentationInfo();\n        const fragmentDuration = representationInfo.fragmentDuration;\n\n        // Don't ask for a bitrate change if there is not info about buffer state or if fragmentDuration is not defined\n        if (!lastBufferStateVO || !wasFirstBufferLoadedEventTriggered(mediaType, lastBufferStateVO) || !fragmentDuration) {\n            return switchRequest;\n        }\n\n        if (lastBufferStateVO.state === BufferController.BUFFER_EMPTY) {\n            logger.debug('Switch to index 0; buffer is empty.');\n            switchRequest.quality = 0;\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n        } else {\n            const mediaInfo = rulesContext.getMediaInfo();\n            const abrController = rulesContext.getAbrController();\n            const throughputHistory = abrController.getThroughputHistory();\n\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\n            const throughput = throughputHistory.getAverageThroughput(mediaType);\n            const latency = throughputHistory.getAverageLatency(mediaType);\n            const bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\n\n            switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\n            switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\n        }\n\n        return switchRequest;\n    }\n\n    function wasFirstBufferLoadedEventTriggered(mediaType, currentBufferState) {\n        bufferStateDict[mediaType] = bufferStateDict[mediaType] || {};\n\n        let wasTriggered = false;\n        if (bufferStateDict[mediaType].firstBufferLoadedEvent) {\n            wasTriggered = true;\n        } else if (currentBufferState && currentBufferState.state === BufferController.BUFFER_LOADED) {\n            bufferStateDict[mediaType].firstBufferLoadedEvent = true;\n            wasTriggered = true;\n        }\n        return wasTriggered;\n    }\n\n    function resetInitialSettings() {\n        bufferStateDict = {};\n    }\n\n    function onPlaybackSeeking() {\n        resetInitialSettings();\n    }\n\n    function reset() {\n        resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\n"]}