{"version":3,"sources":["../../../../../src/streaming/rules/ThroughputHistory.js"],"names":["Constants","FactoryMaker","ThroughputHistory","config","MAX_MEASUREMENTS_TO_KEEP","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD","AVERAGE_LATENCY_SAMPLE_AMOUNT","THROUGHPUT_DECREASE_SCALE","THROUGHPUT_INCREASE_SCALE","EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS","EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS","EWMA_LATENCY_SLOW_HALF_LIFE_COUNT","EWMA_LATENCY_FAST_HALF_LIFE_COUNT","mediaPlayerModel","throughputDict","latencyDict","ewmaThroughputDict","ewmaLatencyDict","ewmaHalfLife","setup","throughputHalfLife","fast","slow","latencyHalfLife","reset","isCachedResponse","mediaType","latencyMs","downloadTimeMs","VIDEO","getCacheLoadThresholdForType","AUDIO","push","httpRequest","useDeadTimeLatency","trace","length","latencyTimeInMilliseconds","tresponse","getTime","trequest","downloadTimeInMilliseconds","_tfinish","downloadBytes","reduce","a","b","throughputMeasureTime","getLowLatencyEnabled","d","throughput","Math","round","checkSettingsForMediaType","hasCachedEntries","clearSettingsForMediaType","shift","updateEwmaEstimate","ewmaObj","value","weight","halfLife","fastAlpha","pow","fastEstimate","slowAlpha","slowEstimate","totalWeight","getSampleSize","isThroughput","isLive","arr","sampleSize","i","ratio","getAverage","isDynamic","getMovingAverageMethod","MOVING_AVERAGE_SLIDING_WINDOW","getAverageEwma","getAverageSlidingWindow","dict","NaN","slice","total","elem","min","max","getAverageThroughput","getSafeAverageThroughput","average","isNaN","getBandwidthSafetyFactor","getAverageLatency","instance","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"ThroughputHistory.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2017, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\n\n// throughput generally stored in kbit/s\n// latency generally stored in ms\n\nfunction ThroughputHistory(config) {\n\n    config = config || {};\n    // sliding window constants\n    const MAX_MEASUREMENTS_TO_KEEP = 20;\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE = 3;\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD = 4;\n    const AVERAGE_LATENCY_SAMPLE_AMOUNT = 4;\n    const THROUGHPUT_DECREASE_SCALE = 1.3;\n    const THROUGHPUT_INCREASE_SCALE = 1.3;\n\n    // EWMA constants\n    const EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS = 8;\n    const EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS = 3;\n    const EWMA_LATENCY_SLOW_HALF_LIFE_COUNT = 2;\n    const EWMA_LATENCY_FAST_HALF_LIFE_COUNT = 1;\n\n    const mediaPlayerModel = config.mediaPlayerModel;\n\n    let throughputDict,\n        latencyDict,\n        ewmaThroughputDict,\n        ewmaLatencyDict,\n        ewmaHalfLife;\n\n    function setup() {\n        ewmaHalfLife = {\n            throughputHalfLife: { fast: EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS, slow: EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS },\n            latencyHalfLife:    { fast: EWMA_LATENCY_FAST_HALF_LIFE_COUNT,      slow: EWMA_LATENCY_SLOW_HALF_LIFE_COUNT }\n        };\n\n        reset();\n    }\n\n    function isCachedResponse(mediaType, latencyMs, downloadTimeMs) {\n        if (mediaType === Constants.VIDEO) {\n            return downloadTimeMs < mediaPlayerModel.getCacheLoadThresholdForType(Constants.VIDEO);\n        } else if (mediaType === Constants.AUDIO) {\n            return downloadTimeMs < mediaPlayerModel.getCacheLoadThresholdForType(Constants.AUDIO);\n        }\n    }\n\n    function push(mediaType, httpRequest, useDeadTimeLatency) {\n        if (!httpRequest.trace || !httpRequest.trace.length) {\n            return;\n        }\n\n        const latencyTimeInMilliseconds = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) || 1;\n        const downloadTimeInMilliseconds = (httpRequest._tfinish.getTime() - httpRequest.tresponse.getTime()) || 1; //Make sure never 0 we divide by this value. Avoid infinity!\n        const downloadBytes = httpRequest.trace.reduce((a, b) => a + b.b[0], 0);\n\n        let throughputMeasureTime;\n        if (mediaPlayerModel.getLowLatencyEnabled()) {\n            throughputMeasureTime = httpRequest.trace.reduce((a, b) => a + b.d, 0);\n        } else {\n            throughputMeasureTime = useDeadTimeLatency ? downloadTimeInMilliseconds : latencyTimeInMilliseconds + downloadTimeInMilliseconds;\n        }\n\n        const throughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\n\n        checkSettingsForMediaType(mediaType);\n\n        if (isCachedResponse(mediaType, latencyTimeInMilliseconds, downloadTimeInMilliseconds)) {\n            if (throughputDict[mediaType].length > 0 && !throughputDict[mediaType].hasCachedEntries) {\n                // already have some entries which are not cached entries\n                // prevent cached fragment loads from skewing the average values\n                return;\n            } else { // have no entries || have cached entries\n                // no uncached entries yet, rely on cached entries because ABR rules need something to go by\n                throughputDict[mediaType].hasCachedEntries = true;\n            }\n        } else if (throughputDict[mediaType] && throughputDict[mediaType].hasCachedEntries) {\n            // if we are here then we have some entries already, but they are cached, and now we have a new uncached entry\n            clearSettingsForMediaType(mediaType);\n        }\n\n        throughputDict[mediaType].push(throughput);\n        if (throughputDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n            throughputDict[mediaType].shift();\n        }\n\n        latencyDict[mediaType].push(latencyTimeInMilliseconds);\n        if (latencyDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\n            latencyDict[mediaType].shift();\n        }\n\n        updateEwmaEstimate(ewmaThroughputDict[mediaType], throughput, 0.001 * downloadTimeInMilliseconds, ewmaHalfLife.throughputHalfLife);\n        updateEwmaEstimate(ewmaLatencyDict[mediaType], latencyTimeInMilliseconds, 1, ewmaHalfLife.latencyHalfLife);\n    }\n\n    function updateEwmaEstimate(ewmaObj, value, weight, halfLife) {\n        // Note about startup:\n        // Estimates start at 0, so early values are underestimated.\n        // This effect is countered in getAverageEwma() by dividing the estimates by:\n        //     1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n\n        const fastAlpha = Math.pow(0.5, weight / halfLife.fast);\n        ewmaObj.fastEstimate = (1 - fastAlpha) * value + fastAlpha * ewmaObj.fastEstimate;\n\n        const slowAlpha = Math.pow(0.5, weight / halfLife.slow);\n        ewmaObj.slowEstimate = (1 - slowAlpha) * value + slowAlpha * ewmaObj.slowEstimate;\n\n        ewmaObj.totalWeight += weight;\n    }\n\n    function getSampleSize(isThroughput, mediaType, isLive) {\n        let arr,\n            sampleSize;\n\n        if (isThroughput) {\n            arr = throughputDict[mediaType];\n            sampleSize = isLive ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD;\n        } else {\n            arr = latencyDict[mediaType];\n            sampleSize = AVERAGE_LATENCY_SAMPLE_AMOUNT;\n        }\n\n        if (!arr) {\n            sampleSize = 0;\n        } else if (sampleSize >= arr.length) {\n            sampleSize = arr.length;\n        } else if (isThroughput) {\n            // if throughput samples vary a lot, average over a wider sample\n            for (let i = 1; i < sampleSize; ++i) {\n                const ratio = arr[i] / arr[i - 1];\n                if (ratio >= THROUGHPUT_INCREASE_SCALE || ratio <= 1 / THROUGHPUT_DECREASE_SCALE) {\n                    sampleSize += 1;\n                    if (sampleSize === arr.length) { // cannot increase sampleSize beyond arr.length\n                        break;\n                    }\n                }\n            }\n        }\n\n        return sampleSize;\n    }\n\n    function getAverage(isThroughput, mediaType, isDynamic) {\n        // only two moving average methods defined at the moment\n        return mediaPlayerModel.getMovingAverageMethod() !== Constants.MOVING_AVERAGE_SLIDING_WINDOW ?\n            getAverageEwma(isThroughput, mediaType) : getAverageSlidingWindow(isThroughput, mediaType, isDynamic);\n    }\n\n    function getAverageSlidingWindow(isThroughput, mediaType, isDynamic) {\n        const sampleSize = getSampleSize(isThroughput, mediaType, isDynamic);\n        const dict = isThroughput ? throughputDict : latencyDict;\n        let arr = dict[mediaType];\n\n        if (sampleSize === 0 || !arr || arr.length === 0) {\n            return NaN;\n        }\n\n        arr = arr.slice(-sampleSize); // still works if sampleSize too large\n        // arr.length >= 1\n        return arr.reduce((total, elem) => total + elem) / arr.length;\n    }\n\n    function getAverageEwma(isThroughput, mediaType) {\n        const halfLife = isThroughput ? ewmaHalfLife.throughputHalfLife : ewmaHalfLife.latencyHalfLife;\n        const ewmaObj = isThroughput ? ewmaThroughputDict[mediaType] : ewmaLatencyDict[mediaType];\n\n        if (!ewmaObj || ewmaObj.totalWeight <= 0) {\n            return NaN;\n        }\n\n        // to correct for startup, divide by zero factor = 1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\n        const fastEstimate = ewmaObj.fastEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.fast));\n        const slowEstimate = ewmaObj.slowEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.slow));\n        return isThroughput ? Math.min(fastEstimate, slowEstimate) : Math.max(fastEstimate, slowEstimate);\n    }\n\n    function getAverageThroughput(mediaType, isDynamic) {\n        return getAverage(true, mediaType, isDynamic);\n    }\n\n    function getSafeAverageThroughput(mediaType, isDynamic) {\n        let average = getAverageThroughput(mediaType, isDynamic);\n        if (!isNaN(average)) {\n            average *= mediaPlayerModel.getBandwidthSafetyFactor();\n        }\n        return average;\n    }\n\n    function getAverageLatency(mediaType) {\n        return getAverage(false, mediaType);\n    }\n\n    function checkSettingsForMediaType(mediaType) {\n        throughputDict[mediaType] = throughputDict[mediaType] || [];\n        latencyDict[mediaType] = latencyDict[mediaType] || [];\n        ewmaThroughputDict[mediaType] = ewmaThroughputDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\n        ewmaLatencyDict[mediaType] = ewmaLatencyDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\n    }\n\n    function clearSettingsForMediaType(mediaType) {\n        delete throughputDict[mediaType];\n        delete latencyDict[mediaType];\n        delete ewmaThroughputDict[mediaType];\n        delete ewmaLatencyDict[mediaType];\n        checkSettingsForMediaType(mediaType);\n    }\n\n    function reset() {\n        throughputDict = {};\n        latencyDict = {};\n        ewmaThroughputDict = {};\n        ewmaLatencyDict = {};\n    }\n\n    const instance = {\n        push: push,\n        getAverageThroughput: getAverageThroughput,\n        getSafeAverageThroughput: getSafeAverageThroughput,\n        getAverageLatency: getAverageLatency,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nThroughputHistory.__dashjs_factory_name = 'ThroughputHistory';\nexport default FactoryMaker.getClassFactory(ThroughputHistory);\n"]}