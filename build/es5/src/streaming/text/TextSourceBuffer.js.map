{"version":3,"sources":["../../../../../src/streaming/text/TextSourceBuffer.js"],"names":["Constants","HTTPRequest","TextTrackInfo","BoxParser","CustomTimeRanges","FactoryMaker","Debug","TextTracks","EmbeddedTextHtmlRender","ISOBoxer","cea608parser","EventBus","Events","DashJSError","Errors","TextSourceBuffer","context","eventBus","getInstance","embeddedInitialized","instance","logger","boxParser","errHandler","dashManifestModel","manifestModel","mediaController","parser","vttParser","ttmlParser","mediaInfos","textTracks","fragmentedFragmentModel","initializationSegmentReceived","timescale","fragmentedTracks","videoModel","streamController","firstFragmentedSubtitleStart","currFragmentedTrackIdx","embeddedTracks","embeddedInitializationSegmentReceived","embeddedTimescale","embeddedLastSequenceNumber","embeddedSequenceNumbers","embeddedCea608FieldParsers","embeddedTextHtmlRender","mseTimeOffset","setup","getLogger","resetInitialSettings","resetFragmented","NaN","initialize","mimeType","streamProcessor","initEmbedded","setConfig","addMediaInfos","isFragmented","getIsTextTrack","concat","getMediaInfoArr","getFragmentModel","buffered","create","getTracksFor","FRAGMENTED_TEXT","getActiveStreamInfo","currFragTrack","getCurrentTrackFor","i","length","setCurrentFragmentedTrackIdx","createTextTrackFromMediaInfo","abort","deleteAllTextTracks","reset","onVideoChunkReceived","e","chunk","mediaInfo","embeddedCaptions","append","bytes","streamProcessors","getActiveStreamProcessors","getType","getRepresentationInfo","MSETimeOffset","on","VIDEO_CHUNK_RECEIVED","resetEmbedded","off","addEmbeddedTrack","id","CC1","CC3","push","warn","config","getConfig","fragmentModel","idx","captionData","textTrackInfo","trackKindMap","subtitle","caption","getKind","kind","roles","checkTTML","ttml","codec","search","STPP","TTML","lang","labels","index","isTTML","defaultTrack","getIsDefault","isEmbedded","accessibility","totalNrTracks","addTextTrack","result","sampleList","j","k","samplesInfo","ccContent","mediaType","type","codecType","error","getMediaTimescaleFromMoov","getSamplesInfo","cts","start","getParser","sample","sampleStart","sampleRelStart","add","duration","dataView","DataView","offset","subSizes","Utils","dataViewToString","UTF8","images","subOffset","inData","Uint8Array","raw","String","fromCharCode","apply","manifest","getValue","offsetTime","ttmlTimeIsRelative","parse","addCaptions","removeExecutedRequestsBeforeTime","remove","message","captionArray","sampleData","slice","size","sampleBoxes","parseBuffer","boxes","box1","debug","box2","cue_text","start_time","end_time","end","data","styles","TEXT","byteLength","getCurrentTrackIdx","timedTextError","TIMED_TEXT_ERROR_ID_PARSE_CODE","TIMED_TEXT_ERROR_MESSAGE_PARSE","VIDEO","segmentType","INIT_SEGMENT_TYPE","makeCueAdderForIndex","self","trackIndex","newCue","startTime","endTime","captionScreen","captionsArray","getTTMLRenderingDiv","createHTMLCaptionsFromScreen","getElement","text","getDisplayText","sequenceNumber","lastSequenceNumber","field","handler","trackIdx","getTrackIdxForId","Cea608Parser","indexOf","numSequences","allCcData","extractCea608Data","fieldNr","ccData","fields","fieldParser","addData","samples","splits","cea608Ranges","findCea608Nalus","lastSampleTime","extractCea608DataFromRange","forEach","sortField","sort","a","b","isDefault","substring","VTT","undefined","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"TextSourceBuffer.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\nimport TextTrackInfo from '../vo/TextTrackInfo';\nimport BoxParser from '../utils/BoxParser';\nimport CustomTimeRanges from '../utils/CustomTimeRanges';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport TextTracks from './TextTracks';\nimport EmbeddedTextHtmlRender from './EmbeddedTextHtmlRender';\nimport ISOBoxer from 'codem-isoboxer';\nimport cea608parser from '../../../externals/cea608-parser';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport DashJSError from '../vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nfunction TextSourceBuffer() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    let embeddedInitialized = false;\n\n    let instance,\n        logger,\n        boxParser,\n        errHandler,\n        dashManifestModel,\n        manifestModel,\n        mediaController,\n        parser,\n        vttParser,\n        ttmlParser,\n        mediaInfos,\n        textTracks,\n        fragmentedFragmentModel,\n        initializationSegmentReceived,\n        timescale,\n        fragmentedTracks,\n        videoModel,\n        streamController,\n        firstFragmentedSubtitleStart,\n        currFragmentedTrackIdx,\n        embeddedTracks,\n        embeddedInitializationSegmentReceived,\n        embeddedTimescale,\n        embeddedLastSequenceNumber,\n        embeddedSequenceNumbers,\n        embeddedCea608FieldParsers,\n        embeddedTextHtmlRender,\n        mseTimeOffset;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        resetInitialSettings();\n    }\n\n    function resetFragmented () {\n        fragmentedFragmentModel = null;\n        timescale = NaN;\n        fragmentedTracks = [];\n        firstFragmentedSubtitleStart = null;\n        initializationSegmentReceived = false;\n    }\n\n    function resetInitialSettings() {\n        resetFragmented();\n\n        mediaInfos = [];\n        parser = null;\n    }\n\n    function initialize(mimeType, streamProcessor) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n\n        if (!boxParser) {\n            boxParser = BoxParser(context).getInstance();\n        }\n\n        addMediaInfos(mimeType, streamProcessor);\n    }\n\n    function addMediaInfos(mimeType, streamProcessor) {\n        const isFragmented = !dashManifestModel.getIsTextTrack(mimeType);\n        if (streamProcessor) {\n            mediaInfos = mediaInfos.concat(streamProcessor.getMediaInfoArr());\n\n            if (isFragmented) {\n                fragmentedFragmentModel = streamProcessor.getFragmentModel();\n                instance.buffered = CustomTimeRanges(context).create();\n                fragmentedTracks = mediaController.getTracksFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                const currFragTrack = mediaController.getCurrentTrackFor(Constants.FRAGMENTED_TEXT, streamController.getActiveStreamInfo());\n                for (let i = 0; i < fragmentedTracks.length; i++) {\n                    if (fragmentedTracks[i] === currFragTrack) {\n                        setCurrentFragmentedTrackIdx(i);\n                        break;\n                    }\n                }\n            }\n\n            for (let i = 0; i < mediaInfos.length; i++) {\n                createTextTrackFromMediaInfo(null, mediaInfos[i]);\n            }\n        }\n    }\n\n    function abort() {\n        textTracks.deleteAllTextTracks();\n        boxParser = null;\n        mediaInfos = [];\n        fragmentedFragmentModel = null;\n        initializationSegmentReceived = false;\n        fragmentedTracks = [];\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        streamController = null;\n        videoModel = null;\n        textTracks = null;\n    }\n\n    function onVideoChunkReceived(e) {\n        const chunk = e.chunk;\n\n        if (chunk.mediaInfo.embeddedCaptions) {\n            append(chunk.bytes, chunk);\n        }\n    }\n\n    function initEmbedded() {\n        embeddedTracks = [];\n        textTracks = TextTracks(context).getInstance();\n        textTracks.setConfig({\n            videoModel: videoModel\n        });\n        textTracks.initialize();\n        boxParser = BoxParser(context).getInstance();\n        currFragmentedTrackIdx = null;\n        embeddedInitializationSegmentReceived = false;\n        embeddedTimescale = 0;\n        embeddedCea608FieldParsers = [];\n        embeddedSequenceNumbers = [];\n        embeddedLastSequenceNumber = null;\n        embeddedInitialized = true;\n        embeddedTextHtmlRender = EmbeddedTextHtmlRender(context).getInstance();\n\n        const streamProcessors = streamController.getActiveStreamProcessors();\n        for (const i in streamProcessors) {\n            if (streamProcessors[i].getType() === 'video') {\n                mseTimeOffset = streamProcessors[i].getRepresentationInfo().MSETimeOffset;\n                break;\n            }\n        }\n\n        eventBus.on(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n    }\n\n    function resetEmbedded() {\n        eventBus.off(Events.VIDEO_CHUNK_RECEIVED, onVideoChunkReceived, this);\n        if (textTracks) {\n            textTracks.deleteAllTextTracks();\n        }\n        embeddedInitialized = false;\n        embeddedTracks = [];\n        embeddedCea608FieldParsers = [null, null];\n        embeddedSequenceNumbers = [];\n        embeddedLastSequenceNumber = null;\n    }\n\n    function addEmbeddedTrack(mediaInfo) {\n        if (!embeddedInitialized) {\n            initEmbedded();\n        }\n        if (mediaInfo) {\n            if (mediaInfo.id === Constants.CC1 || mediaInfo.id === Constants.CC3) {\n                for (let i = 0; i < embeddedTracks.length; i++) {\n                    if (embeddedTracks[i].id === mediaInfo.id) {\n                        return;\n                    }\n                }\n                embeddedTracks.push(mediaInfo);\n            } else {\n                logger.warn('Embedded track ' + mediaInfo.id + ' not supported!');\n            }\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.errHandler) {\n            errHandler = config.errHandler;\n        }\n        if (config.dashManifestModel) {\n            dashManifestModel = config.dashManifestModel;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.mediaController) {\n            mediaController = config.mediaController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.textTracks) {\n            textTracks = config.textTracks;\n        }\n        if (config.vttParser) {\n            vttParser = config.vttParser;\n        }\n        if (config.ttmlParser) {\n            ttmlParser = config.ttmlParser;\n        }\n    }\n\n    function getConfig() {\n        const config = {\n            fragmentModel: fragmentedFragmentModel,\n            fragmentedTracks: fragmentedTracks,\n            videoModel: videoModel\n        };\n\n        return config;\n    }\n\n    function setCurrentFragmentedTrackIdx(idx) {\n        currFragmentedTrackIdx = idx;\n    }\n\n    function createTextTrackFromMediaInfo(captionData, mediaInfo) {\n        const textTrackInfo = new TextTrackInfo();\n        const trackKindMap = { subtitle: 'subtitles', caption: 'captions' }; //Dash Spec has no \"s\" on end of KIND but HTML needs plural.\n        const getKind = function () {\n            let kind = (mediaInfo.roles.length > 0) ? trackKindMap[mediaInfo.roles[0]] : trackKindMap.caption;\n            kind = (kind === trackKindMap.caption || kind === trackKindMap.subtitle) ? kind : trackKindMap.caption;\n            return kind;\n        };\n\n        const checkTTML = function () {\n            let ttml = false;\n            if (mediaInfo.codec && mediaInfo.codec.search(Constants.STPP) >= 0) {\n                ttml = true;\n            }\n            if (mediaInfo.mimeType && mediaInfo.mimeType.search(Constants.TTML) >= 0) {\n                ttml = true;\n            }\n            return ttml;\n        };\n\n        textTrackInfo.captionData = captionData;\n        textTrackInfo.lang = mediaInfo.lang;\n        textTrackInfo.labels = mediaInfo.labels;\n        textTrackInfo.id = mediaInfo.id ? mediaInfo.id : mediaInfo.index; // AdaptationSet id (an unsigned int) as it's optional parameter, use mediaInfo.index\n        textTrackInfo.index = mediaInfo.index; // AdaptationSet index in manifest\n        textTrackInfo.isTTML = checkTTML();\n        textTrackInfo.defaultTrack = getIsDefault(mediaInfo);\n        textTrackInfo.isFragmented = !dashManifestModel.getIsTextTrack(mediaInfo.mimeType);\n        textTrackInfo.isEmbedded = mediaInfo.isEmbedded ? true : false;\n        textTrackInfo.kind = getKind();\n        textTrackInfo.roles = mediaInfo.roles;\n        textTrackInfo.accessibility = mediaInfo.accessibility;\n        const totalNrTracks = (mediaInfos ? mediaInfos.length : 0) + embeddedTracks.length;\n        textTracks.addTextTrack(textTrackInfo, totalNrTracks);\n    }\n\n    function append(bytes, chunk) {\n        let result,\n            sampleList,\n            i, j, k,\n            samplesInfo,\n            ccContent;\n        const mediaInfo = chunk.mediaInfo;\n        const mediaType = mediaInfo.type;\n        const mimeType = mediaInfo.mimeType;\n        const codecType = mediaInfo.codec || mimeType;\n        if (!codecType) {\n            logger.error('No text type defined');\n            return;\n        }\n\n        if (mediaType === Constants.FRAGMENTED_TEXT) {\n            if (!initializationSegmentReceived) {\n                initializationSegmentReceived = true;\n                timescale = boxParser.getMediaTimescaleFromMoov(bytes);\n            } else {\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n                sampleList = samplesInfo.sampleList;\n                if (firstFragmentedSubtitleStart === null && sampleList.length > 0) {\n                    firstFragmentedSubtitleStart = sampleList[0].cts - chunk.start * timescale;\n                }\n                if (codecType.search(Constants.STPP) >= 0) {\n                    parser = parser !== null ? parser : getParser(codecType);\n                    for (i = 0; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        const sampleStart = sample.cts;\n                        const sampleRelStart = sampleStart - firstFragmentedSubtitleStart;\n                        this.buffered.add(sampleRelStart / timescale, (sampleRelStart + sample.duration) / timescale);\n                        const dataView = new DataView(bytes, sample.offset, sample.subSizes[0]);\n                        ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n                        const images = [];\n                        let subOffset = sample.offset + sample.subSizes[0];\n                        for (j = 1; j < sample.subSizes.length; j++) {\n                            const inData = new Uint8Array(bytes, subOffset, sample.subSizes[j]);\n                            const raw = String.fromCharCode.apply(null, inData);\n                            images.push(raw);\n                            subOffset += sample.subSizes[j];\n                        }\n                        try {\n                            // Only used for Miscrosoft Smooth Streaming support - caption time is relative to sample time. In this case, we apply an offset.\n                            const manifest = manifestModel.getValue();\n                            const offsetTime = manifest.ttmlTimeIsRelative ? sampleStart / timescale : 0;\n                            result = parser.parse(ccContent, offsetTime, sampleStart / timescale, (sampleStart + sample.duration) / timescale, images);\n                            textTracks.addCaptions(currFragmentedTrackIdx, firstFragmentedSubtitleStart / timescale, result);\n                        } catch (e) {\n                            fragmentedFragmentModel.removeExecutedRequestsBeforeTime();\n                            this.remove();\n                            logger.error('TTML parser error: ' + e.message);\n                        }\n                    }\n                } else {\n                    // WebVTT case\n                    const captionArray = [];\n                    for (i = 0 ; i < sampleList.length; i++) {\n                        const sample = sampleList[i];\n                        sample.cts -= firstFragmentedSubtitleStart;\n                        this.buffered.add(sample.cts / timescale, (sample.cts + sample.duration) / timescale);\n                        const sampleData = bytes.slice(sample.offset, sample.offset + sample.size);\n                        // There are boxes inside the sampleData, so we need a ISOBoxer to get at it.\n                        const sampleBoxes = ISOBoxer.parseBuffer(sampleData);\n\n                        for (j = 0 ; j < sampleBoxes.boxes.length; j++) {\n                            const box1 = sampleBoxes.boxes[j];\n                            logger.debug('VTT box1: ' + box1.type);\n                            if (box1.type === 'vtte') {\n                                continue; //Empty box\n                            }\n                            if (box1.type === 'vttc') {\n                                logger.debug('VTT vttc boxes.length = ' + box1.boxes.length);\n                                for (k = 0 ; k < box1.boxes.length; k++) {\n                                    const box2 = box1.boxes[k];\n                                    logger.debug('VTT box2: ' + box2.type);\n                                    if (box2.type === 'payl') {\n                                        const cue_text = box2.cue_text;\n                                        logger.debug('VTT cue_text = ' + cue_text);\n                                        const start_time = sample.cts / timescale;\n                                        const end_time = (sample.cts + sample.duration) / timescale;\n                                        captionArray.push({\n                                            start: start_time,\n                                            end: end_time,\n                                            data: cue_text,\n                                            styles: {}\n                                        });\n                                        logger.debug('VTT ' + start_time + '-' + end_time + ' : ' + cue_text);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (captionArray.length > 0) {\n                        textTracks.addCaptions(currFragmentedTrackIdx, 0, captionArray);\n                    }\n                }\n            }\n        } else if (mediaType === Constants.TEXT) {\n            const dataView = new DataView(bytes, 0, bytes.byteLength);\n            ccContent = ISOBoxer.Utils.dataViewToString(dataView, Constants.UTF8);\n\n            try {\n                result = getParser(codecType).parse(ccContent, 0);\n                textTracks.addCaptions(textTracks.getCurrentTrackIdx(), 0, result);\n            } catch (e) {\n                errHandler.timedTextError(e, 'parse', ccContent);\n                errHandler.error(new DashJSError(Errors.TIMED_TEXT_ERROR_ID_PARSE_CODE, Errors.TIMED_TEXT_ERROR_MESSAGE_PARSE + e.message, ccContent));\n            }\n        } else if (mediaType === Constants.VIDEO) { //embedded text\n            if (chunk.segmentType === HTTPRequest.INIT_SEGMENT_TYPE) {\n                if (embeddedTimescale === 0) {\n                    embeddedTimescale = boxParser.getMediaTimescaleFromMoov(bytes);\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        createTextTrackFromMediaInfo(null, embeddedTracks[i]);\n                    }\n                }\n            } else { // MediaSegment\n                if (embeddedTimescale === 0) {\n                    logger.warn('CEA-608: No timescale for embeddedTextTrack yet');\n                    return;\n                }\n                const makeCueAdderForIndex = function (self, trackIndex) {\n                    function newCue(startTime, endTime, captionScreen) {\n                        let captionsArray = null;\n                        if (videoModel.getTTMLRenderingDiv()) {\n                            captionsArray = embeddedTextHtmlRender.createHTMLCaptionsFromScreen(videoModel.getElement(), startTime, endTime, captionScreen);\n                        } else {\n                            const text = captionScreen.getDisplayText();\n                            captionsArray = [{\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: {}\n                            }];\n                        }\n                        if (captionsArray) {\n                            textTracks.addCaptions(trackIndex, 0, captionsArray);\n                        }\n                    }\n                    return newCue;\n                };\n\n                samplesInfo = boxParser.getSamplesInfo(bytes);\n\n                const sequenceNumber = samplesInfo.lastSequenceNumber;\n\n                if (!embeddedCea608FieldParsers[0] && !embeddedCea608FieldParsers[1]) {\n                    // Time to setup the CEA-608 parsing\n                    let field, handler, trackIdx;\n                    for (i = 0; i < embeddedTracks.length; i++) {\n                        if (embeddedTracks[i].id === Constants.CC1) {\n                            field = 0;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC1);\n                        } else if (embeddedTracks[i].id === Constants.CC3) {\n                            field = 1;\n                            trackIdx = textTracks.getTrackIdxForId(Constants.CC3);\n                        }\n                        if (trackIdx === -1) {\n                            logger.warn('CEA-608: data before track is ready.');\n                            return;\n                        }\n                        handler = makeCueAdderForIndex(this, trackIdx);\n                        embeddedCea608FieldParsers[i] = new cea608parser.Cea608Parser(i + 1, {\n                            'newCue': handler\n                        }, null);\n                    }\n                }\n\n                if (embeddedTimescale && embeddedSequenceNumbers.indexOf(sequenceNumber) == -1) {\n                    if (embeddedLastSequenceNumber !== null && sequenceNumber !== embeddedLastSequenceNumber + samplesInfo.numSequences) {\n                        for (i = 0; i < embeddedCea608FieldParsers.length; i++) {\n                            if (embeddedCea608FieldParsers[i]) {\n                                embeddedCea608FieldParsers[i].reset();\n                            }\n                        }\n                    }\n\n                    const allCcData = extractCea608Data(bytes, samplesInfo.sampleList);\n\n                    for (let fieldNr = 0; fieldNr < embeddedCea608FieldParsers.length; fieldNr++) {\n                        const ccData = allCcData.fields[fieldNr];\n                        const fieldParser = embeddedCea608FieldParsers[fieldNr];\n                        if (fieldParser) {\n                            for (i = 0; i < ccData.length; i++) {\n                                fieldParser.addData(ccData[i][0] / embeddedTimescale, ccData[i][1]);\n                            }\n                        }\n                    }\n                    embeddedLastSequenceNumber = sequenceNumber;\n                    embeddedSequenceNumbers.push(sequenceNumber);\n                }\n            }\n        }\n    }\n    /**\n     * Extract CEA-608 data from a buffer of data.\n     * @param {ArrayBuffer} data\n     * @param {Array} samples cue information\n     * @returns {Object|null} ccData corresponding to one segment.\n     */\n    function extractCea608Data(data, samples) {\n        if (samples.length === 0) {\n            return null;\n        }\n\n        const allCcData = {\n            splits: [],\n            fields: [[], []]\n        };\n        const raw = new DataView(data);\n        for (let i = 0; i < samples.length; i++) {\n            const sample = samples[i];\n            const cea608Ranges = cea608parser.findCea608Nalus(raw, sample.offset, sample.size);\n            let lastSampleTime = null;\n            let idx = 0;\n            for (let j = 0; j < cea608Ranges.length; j++) {\n                const ccData = cea608parser.extractCea608DataFromRange(raw, cea608Ranges[j]);\n                for (let k = 0; k < 2; k++) {\n                    if (ccData[k].length > 0) {\n                        if (sample.cts !== lastSampleTime) {\n                            idx = 0;\n                        } else {\n                            idx += 1;\n                        }\n                        allCcData.fields[k].push([sample.cts + (mseTimeOffset * embeddedTimescale), ccData[k], idx]);\n                        lastSampleTime = sample.cts;\n                    }\n                }\n            }\n        }\n\n        // Sort by sampleTime ascending order\n        // If two packets have the same sampleTime, use them in the order\n        // they were received\n        allCcData.fields.forEach(function sortField(field) {\n            field.sort(function (a, b) {\n                if (a[0] === b[0]) {\n                    return a[2] - b[2];\n                }\n                return a[0] - b[0];\n            });\n        });\n\n        return allCcData;\n    }\n\n    function getIsDefault(mediaInfo) {\n        //TODO How to tag default. currently same order as listed in manifest.\n        // Is there a way to mark a text adaptation set as the default one? DASHIF meeting talk about using role which is being used for track KIND\n        // Eg subtitles etc. You can have multiple role tags per adaptation Not defined in the spec yet.\n        let isDefault = false;\n        if (embeddedTracks.length > 1 && mediaInfo.isEmbedded) {\n            isDefault = (mediaInfo.id && mediaInfo.id === Constants.CC1); // CC1 if both CC1 and CC3 exist\n        } else if (embeddedTracks.length === 1) {\n            if (mediaInfo.id && typeof mediaInfo.id === 'string' && mediaInfo.id.substring(0, 2) === 'CC') { // Either CC1 or CC3\n                isDefault = true;\n            }\n        } else if (embeddedTracks.length === 0) {\n            isDefault = (mediaInfo.index === mediaInfos[0].index);\n        }\n        return isDefault;\n    }\n\n    function getParser(codecType) {\n        let parser;\n        if (codecType.search(Constants.VTT) >= 0) {\n            parser = vttParser;\n        } else if (codecType.search(Constants.TTML) >= 0 || codecType.search(Constants.STPP) >= 0) {\n            parser = ttmlParser;\n        }\n        return parser;\n    }\n\n    function remove(start, end) {\n        //if start and end are not defined, remove all\n        if ((start === undefined) && (start === end)) {\n            start = this.buffered.start(0);\n            end = this.buffered.end(this.buffered.length - 1);\n        }\n        this.buffered.remove(start, end);\n    }\n\n    instance = {\n        initialize: initialize,\n        append: append,\n        abort: abort,\n        addEmbeddedTrack: addEmbeddedTrack,\n        resetEmbedded: resetEmbedded,\n        setConfig: setConfig,\n        getConfig: getConfig,\n        setCurrentFragmentedTrackIdx: setCurrentFragmentedTrackIdx,\n        remove: remove,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextSourceBuffer.__dashjs_factory_name = 'TextSourceBuffer';\nexport default FactoryMaker.getSingletonFactory(TextSourceBuffer);\n"]}