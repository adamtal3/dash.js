{"version":3,"sources":["../../../../../src/streaming/text/NotFragmentedTextBufferController.js"],"names":["Constants","EventBus","Events","FactoryMaker","InitCache","SourceBufferSink","TextController","DashJSError","Errors","BUFFER_CONTROLLER_TYPE","NotFragmentedTextBufferController","config","context","eventBus","getInstance","textController","errHandler","type","mimeType","streamProcessor","instance","isBufferingCompleted","initialized","mediaSource","buffer","initCache","setup","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INIT_FRAGMENT_LOADED","onInitFragmentLoaded","getBufferControllerType","initialize","source","setMediaSource","createBuffer","mediaInfo","create","textBuffer","getBuffer","hasOwnProperty","INITIALIZE","e","isText","codec","indexOf","getTextSourceBuffer","mediaSourceError","error","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","message","getType","value","getMediaSource","getStreamProcessor","getIsPruningInProgress","dischargePreBuffer","setSeekStartTime","getBufferLevel","getIsBufferingCompleted","reset","errored","off","abort","sender","chunk","extract","getStreamInfo","id","getCurrentRepresentation","trigger","TIMED_TEXT_REQUESTED","index","fragmentModel","getFragmentModel","bytes","save","append","STREAM_COMPLETED","request","switchInitData","streamId","representationId","getRangeAt","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"NotFragmentedTextBufferController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport InitCache from '../utils/InitCache';\nimport SourceBufferSink from '../SourceBufferSink';\nimport TextController from '../../streaming/text/TextController';\nimport DashJSError from '../../streaming/vo/DashJSError';\nimport Errors from '../../core/errors/Errors';\n\nconst BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\nfunction NotFragmentedTextBufferController(config) {\n\n    config = config || {};\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n    const textController = TextController(context).getInstance();\n\n    let errHandler = config.errHandler;\n    let type = config.type;\n    let mimeType = config.mimeType;\n    let streamProcessor = config.streamProcessor;\n\n    let instance,\n        isBufferingCompleted,\n        initialized,\n        mediaSource,\n        buffer,\n        initCache;\n\n    function setup() {\n        initialized = false;\n        mediaSource = null;\n        isBufferingCompleted = false;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n    }\n\n    function getBufferControllerType() {\n        return BUFFER_CONTROLLER_TYPE;\n    }\n\n    function initialize(source) {\n        setMediaSource(source);\n        initCache = InitCache(context).getInstance();\n    }\n\n    /**\n     * @param {MediaInfo }mediaInfo\n     * @memberof BufferController#\n     */\n    function createBuffer(mediaInfo) {\n        try {\n            buffer = SourceBufferSink(context).create(mediaSource, mediaInfo);\n            if (!initialized) {\n                const textBuffer = buffer.getBuffer();\n                if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) {\n                    textBuffer.initialize(mimeType, streamProcessor);\n                }\n                initialized = true;\n            }\n            return buffer;\n        } catch (e) {\n            if ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=\"stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1)) {\n                try {\n                    buffer = textController.getTextSourceBuffer();\n                } catch (e) {\n                    errHandler.mediaSourceError('Error creating ' + type + ' source buffer.');\n                    errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\n                }\n            } else {\n                errHandler.mediaSourceError('Error creating ' + type + ' source buffer.');\n                errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\n            }\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function setMediaSource(value) {\n        mediaSource = value;\n    }\n\n    function getMediaSource() {\n        return mediaSource;\n    }\n\n    function getStreamProcessor() {\n        return streamProcessor;\n    }\n\n    function getIsPruningInProgress() {\n        return false;\n    }\n\n    function dischargePreBuffer() {\n    }\n\n    function setSeekStartTime() { //Unused - TODO Remove need for stub function\n    }\n\n    function getBufferLevel() {\n        return 0;\n    }\n\n    function getIsBufferingCompleted() {\n        return isBufferingCompleted;\n    }\n\n    function reset(errored) {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\n\n        if (!errored && buffer) {\n            buffer.abort();\n            buffer.reset();\n            buffer = null;\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        const chunk = initCache.extract(streamProcessor.getStreamInfo().id, e.sender.getCurrentRepresentation().id);\n\n        if (!chunk) {\n            eventBus.trigger(Events.TIMED_TEXT_REQUESTED, {\n                index: 0,\n                sender: e.sender\n            }); //TODO make index dynamic if referring to MP?\n        }\n    }\n\n    function onInitFragmentLoaded(e) {\n        if (e.fragmentModel !== streamProcessor.getFragmentModel() || (!e.chunk.bytes)) {\n            return;\n        }\n\n        initCache.save(e.chunk);\n        buffer.append(e.chunk);\n\n        eventBus.trigger(Events.STREAM_COMPLETED, {\n            request: e.request,\n            fragmentModel: e.fragmentModel\n        });\n    }\n\n    function switchInitData(streamId, representationId) {\n        const chunk = initCache.extract(streamId, representationId);\n\n        if (!chunk) {\n            eventBus.trigger(Events.TIMED_TEXT_REQUESTED, {\n                index: 0,\n                sender: instance\n            });\n        }\n    }\n\n    function getRangeAt() {\n        return null;\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getType: getType,\n        getStreamProcessor: getStreamProcessor,\n        setSeekStartTime: setSeekStartTime,\n        getBuffer: getBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        switchInitData: switchInitData,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset\n    };\n\n    setup();\n\n    return instance;\n}\n\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\nexport default FactoryMaker.getClassFactory(NotFragmentedTextBufferController);\n"]}