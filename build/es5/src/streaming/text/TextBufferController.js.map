{"version":3,"sources":["../../../../../src/streaming/text/TextBufferController.js"],"names":["Constants","FactoryMaker","BufferController","NotFragmentedTextBufferController","TextBufferController","config","context","_BufferControllerImpl","instance","setup","type","FRAGMENTED_TEXT","create","metricsModel","mediaPlayerModel","manifestModel","errHandler","streamController","mediaController","adapter","textController","abrController","playbackController","streamProcessor","mimeType","getBufferControllerType","initialize","source","StreamProcessor","createBuffer","mediaInfo","getType","getBuffer","setBuffer","value","getMediaSource","setMediaSource","getStreamProcessor","setSeekStartTime","getBufferLevel","reset","errored","getIsBufferingCompleted","switchInitData","streamId","representationId","getIsPruningInProgress","dischargePreBuffer","getRangeAt","time","updateTimestampOffset","MSETimeOffset","buffer","timestampOffset","isNaN","__dashjs_factory_name","getClassFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAOA,SAAP,MAAsB,wBAAtB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,gBAAP,MAA6B,mCAA7B;AACA,OAAOC,iCAAP,MAA8C,qCAA9C;;AAEA,SAASC,oBAAT,CAA8BC,MAA9B,EAAsC;;AAElCA,aAASA,UAAU,EAAnB;AACA,QAAIC,UAAU,KAAKA,OAAnB;;AAEA,QAAIC,qBAAJ,EACIC,QADJ;;AAGA,aAASC,KAAT,GAAiB;;AAEb;AACA,YAAIJ,OAAOK,IAAP,KAAgBV,UAAUW,eAA9B,EAA+C;;AAE3C;AACAJ,oCAAwBL,iBAAiBI,OAAjB,EAA0BM,MAA1B,CAAiC;AACrDF,sBAAML,OAAOK,IADwC;AAErDG,8BAAcR,OAAOQ,YAFgC;AAGrDC,kCAAkBT,OAAOS,gBAH4B;AAIrDC,+BAAeV,OAAOU,aAJ+B;AAKrDC,4BAAYX,OAAOW,UALkC;AAMrDC,kCAAkBZ,OAAOY,gBAN4B;AAOrDC,iCAAiBb,OAAOa,eAP6B;AAQrDC,yBAASd,OAAOc,OARqC;AASrDC,gCAAgBf,OAAOe,cAT8B;AAUrDC,+BAAehB,OAAOgB,aAV+B;AAWrDC,oCAAoBjB,OAAOiB,kBAX0B;AAYrDC,iCAAiBlB,OAAOkB;AAZ6B,aAAjC,CAAxB;AAcH,SAjBD,MAiBO;;AAEH;AACAhB,oCAAwBJ,kCAAkCG,OAAlC,EAA2CM,MAA3C,CAAkD;AACtEF,sBAAML,OAAOK,IADyD;AAEtEc,0BAAUnB,OAAOmB,QAFqD;AAGtER,4BAAYX,OAAOW,UAHmD;AAItEO,iCAAiBlB,OAAOkB;AAJ8C,aAAlD,CAAxB;AAMH;AACJ;;AAED,aAASE,uBAAT,GAAmC;AAC/B,eAAOlB,sBAAsBkB,uBAAtB,EAAP;AACH;;AAED,aAASC,UAAT,CAAoBC,MAApB,EAA4BC,eAA5B,EAA6C;AACzC,eAAOrB,sBAAsBmB,UAAtB,CAAiCC,MAAjC,EAAyCC,eAAzC,CAAP;AACH;;AAED;;;;;AAKA,aAASC,YAAT,CAAsBC,SAAtB,EAAiC;AAC7B,eAAOvB,sBAAsBsB,YAAtB,CAAmCC,SAAnC,CAAP;AACH;;AAED,aAASC,OAAT,GAAmB;AACf,eAAOxB,sBAAsBwB,OAAtB,EAAP;AACH;;AAED,aAASC,SAAT,GAAqB;AACjB,eAAOzB,sBAAsByB,SAAtB,EAAP;AACH;;AAED,aAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACtB3B,8BAAsB0B,SAAtB,CAAgCC,KAAhC;AACH;;AAED,aAASC,cAAT,GAA0B;AACtB,eAAO5B,sBAAsB4B,cAAtB,EAAP;AACH;;AAED,aAASC,cAAT,CAAwBF,KAAxB,EAA+B;AAC3B3B,8BAAsB6B,cAAtB,CAAqCF,KAArC;AACH;;AAED,aAASG,kBAAT,GAA8B;AAC1B9B,8BAAsB8B,kBAAtB;AACH;;AAED,aAASC,gBAAT,CAA0BJ,KAA1B,EAAiC;AAC7B3B,8BAAsB+B,gBAAtB,CAAuCJ,KAAvC;AACH;;AAED,aAASK,cAAT,GAA0B;AACtB,eAAOhC,sBAAsBgC,cAAtB,EAAP;AACH;;AAED,aAASC,KAAT,CAAeC,OAAf,EAAwB;AACpBlC,8BAAsBiC,KAAtB,CAA4BC,OAA5B;AACH;;AAED,aAASC,uBAAT,GAAmC;AAC/B,eAAOnC,sBAAsBmC,uBAAtB,EAAP;AACH;;AAED,aAASC,cAAT,CAAwBC,QAAxB,EAAkCC,gBAAlC,EAAoD;AAChDtC,8BAAsBoC,cAAtB,CAAqCC,QAArC,EAA+CC,gBAA/C;AACH;;AAED,aAASC,sBAAT,GAAkC;AAC9B,eAAOvC,sBAAsBuC,sBAAtB,EAAP;AACH;;AAED,aAASC,kBAAT,GAA8B;AAC1B,eAAOxC,sBAAsBwC,kBAAtB,EAAP;AACH;;AAED,aAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtB,eAAO1C,sBAAsByC,UAAtB,CAAiCC,IAAjC,CAAP;AACH;;AAED,aAASC,qBAAT,CAA+BC,aAA/B,EAA8C;AAC1C,cAAMC,SAASpB,WAAf;AACA,YAAIoB,OAAOC,eAAP,KAA2BF,aAA3B,IAA4C,CAACG,MAAMH,aAAN,CAAjD,EAAuE;AACnEC,mBAAOC,eAAP,GAAyBF,aAAzB;AACH;AACJ;;AAED3C,eAAW;AACPiB,iCAAyBA,uBADlB;AAEPC,oBAAYA,UAFL;AAGPG,sBAAcA,YAHP;AAIPE,iBAASA,OAJF;AAKPM,4BAAoBA,kBALb;AAMPC,0BAAkBA,gBANX;AAOPN,mBAAWA,SAPJ;AAQPC,mBAAWA,SARJ;AASPM,wBAAgBA,cATT;AAUPH,wBAAgBA,cAVT;AAWPD,wBAAgBA,cAXT;AAYPO,iCAAyBA,uBAZlB;AAaPI,gCAAwBA,sBAbjB;AAcPC,4BAAoBA,kBAdb;AAePJ,wBAAgBA,cAfT;AAgBPK,oBAAYA,UAhBL;AAiBPR,eAAOA,KAjBA;AAkBPU,+BAAuBA;AAlBhB,KAAX;;AAqBAzC;;AAEA,WAAOD,QAAP;AACH;;AAEDJ,qBAAqBmD,qBAArB,GAA6C,sBAA7C;AACA,eAAetD,aAAauD,eAAb,CAA6BpD,oBAA7B,CAAf","file":"TextBufferController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport BufferController from './../controllers/BufferController';\nimport NotFragmentedTextBufferController from './NotFragmentedTextBufferController';\n\nfunction TextBufferController(config) {\n\n    config = config || {};\n    let context = this.context;\n\n    let _BufferControllerImpl,\n        instance;\n\n    function setup() {\n\n        // according to text type, we create corresponding buffer controller\n        if (config.type === Constants.FRAGMENTED_TEXT) {\n\n            // in this case, internal buffer ocntroller is a classical BufferController object\n            _BufferControllerImpl = BufferController(context).create({\n                type: config.type,\n                metricsModel: config.metricsModel,\n                mediaPlayerModel: config.mediaPlayerModel,\n                manifestModel: config.manifestModel,\n                errHandler: config.errHandler,\n                streamController: config.streamController,\n                mediaController: config.mediaController,\n                adapter: config.adapter,\n                textController: config.textController,\n                abrController: config.abrController,\n                playbackController: config.playbackController,\n                streamProcessor: config.streamProcessor\n            });\n        } else {\n\n            // in this case, internal buffer controller is a not fragmented text controller object\n            _BufferControllerImpl = NotFragmentedTextBufferController(context).create({\n                type: config.type,\n                mimeType: config.mimeType,\n                errHandler: config.errHandler,\n                streamProcessor: config.streamProcessor\n            });\n        }\n    }\n\n    function getBufferControllerType() {\n        return _BufferControllerImpl.getBufferControllerType();\n    }\n\n    function initialize(source, StreamProcessor) {\n        return _BufferControllerImpl.initialize(source, StreamProcessor);\n    }\n\n    /**\n     * @param {MediaInfo }mediaInfo\n     * @returns {Object} SourceBuffer object\n     * @memberof BufferController#\n     */\n    function createBuffer(mediaInfo) {\n        return _BufferControllerImpl.createBuffer(mediaInfo);\n    }\n\n    function getType() {\n        return _BufferControllerImpl.getType();\n    }\n\n    function getBuffer() {\n        return _BufferControllerImpl.getBuffer();\n    }\n\n    function setBuffer(value) {\n        _BufferControllerImpl.setBuffer(value);\n    }\n\n    function getMediaSource() {\n        return _BufferControllerImpl.getMediaSource();\n    }\n\n    function setMediaSource(value) {\n        _BufferControllerImpl.setMediaSource(value);\n    }\n\n    function getStreamProcessor() {\n        _BufferControllerImpl.getStreamProcessor();\n    }\n\n    function setSeekStartTime(value) {\n        _BufferControllerImpl.setSeekStartTime(value);\n    }\n\n    function getBufferLevel() {\n        return _BufferControllerImpl.getBufferLevel();\n    }\n\n    function reset(errored) {\n        _BufferControllerImpl.reset(errored);\n    }\n\n    function getIsBufferingCompleted() {\n        return _BufferControllerImpl.getIsBufferingCompleted();\n    }\n\n    function switchInitData(streamId, representationId) {\n        _BufferControllerImpl.switchInitData(streamId, representationId);\n    }\n\n    function getIsPruningInProgress() {\n        return _BufferControllerImpl.getIsPruningInProgress();\n    }\n\n    function dischargePreBuffer() {\n        return _BufferControllerImpl.dischargePreBuffer();\n    }\n\n    function getRangeAt(time) {\n        return _BufferControllerImpl.getRangeAt(time);\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        const buffer = getBuffer();\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    instance = {\n        getBufferControllerType: getBufferControllerType,\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getType: getType,\n        getStreamProcessor: getStreamProcessor,\n        setSeekStartTime: setSeekStartTime,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        getBufferLevel: getBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        getIsPruningInProgress: getIsPruningInProgress,\n        dischargePreBuffer: dischargePreBuffer,\n        switchInitData: switchInitData,\n        getRangeAt: getRangeAt,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTextBufferController.__dashjs_factory_name = 'TextBufferController';\nexport default FactoryMaker.getClassFactory(TextBufferController);\n"]}