{"version":3,"sources":["../../../../src/streaming/PreBufferSink.js"],"names":["Debug","FactoryMaker","PreBufferSink","onAppendedCallback","context","instance","logger","outstandingInit","chunks","onAppended","setup","getInstance","getLogger","reset","append","chunk","segmentType","push","sort","a","b","start","debug","end","remove","filter","isNaN","abort","getAllBufferRanges","ranges","i","length","timeranges","n","Object","defineProperty","get","hasDiscontinuitiesAfter","updateTimestampOffset","discharge","result","getChunksAt","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"PreBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\n/**\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n *\n * @class PreBufferSink\n * @implements FragmentSink\n */\nfunction PreBufferSink(onAppendedCallback) {\n    const context = this.context;\n\n    let instance,\n        logger,\n        outstandingInit;\n    let chunks = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function reset() {\n        chunks = [];\n        outstandingInit = null;\n        onAppended = null;\n    }\n\n    function append(chunk) {\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\n            chunks.push(chunk);\n            chunks.sort(function (a, b) { return a.start - b.start; });\n            outstandingInit = null;\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n            outstandingInit = chunk;\n        }\n\n        logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n        if (onAppended) {\n            onAppended({\n                chunk: chunk\n            });\n        }\n    }\n\n    function remove(start, end) {\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\n    }\n\n    //Nothing async, nothing to abort.\n    function abort() {\n    }\n\n    function getAllBufferRanges() {\n        let ranges = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            let chunk = chunks[i];\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n                ranges.push({ start: chunk.start, end: chunk.end });\n            } else {\n                ranges[ranges.length - 1].end = chunk.end;\n            }\n        }\n\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n        const timeranges = {\n            start: function (n) {\n                return ranges[n].start;\n            },\n            end: function (n) {\n                return ranges[n].end;\n            }\n        };\n\n        Object.defineProperty(timeranges, 'length', {\n            get: function () {\n                return ranges.length;\n            }\n        });\n\n        return timeranges;\n    }\n\n    function hasDiscontinuitiesAfter() {\n        return false;\n    }\n\n    function updateTimestampOffset() {\n        // Nothing to do\n    }\n\n    /**\n     * Return the all chunks in the buffer the lie between times start and end.\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n     * Chunks are removed from the buffer when they are discharged.\n     * @function PreBufferSink#discharge\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\n     */\n    function discharge(start, end) {\n        const result = getChunksAt(start, end);\n        if (outstandingInit) {\n            result.push(outstandingInit);\n            outstandingInit = null;\n        }\n\n        remove(start, end);\n\n        return result;\n    }\n\n    function getChunksAt(start, end) {\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\n    }\n\n    instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        append: append,\n        remove: remove,\n        abort: abort,\n        discharge: discharge,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter\n    };\n\n    setup();\n\n    return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\nexport default factory;\n"]}