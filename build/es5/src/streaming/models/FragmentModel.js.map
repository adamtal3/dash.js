{"version":3,"sources":["../../../../../src/streaming/models/FragmentModel.js"],"names":["EventBus","Events","FactoryMaker","FragmentRequest","Debug","FRAGMENT_MODEL_LOADING","FRAGMENT_MODEL_EXECUTED","FRAGMENT_MODEL_CANCELED","FRAGMENT_MODEL_FAILED","FragmentModel","config","context","eventBus","getInstance","metricsModel","fragmentLoader","instance","logger","streamProcessor","executedRequests","loadingRequests","setup","getLogger","resetInitialSettings","on","LOADING_COMPLETED","onLoadingCompleted","LOADING_DATA_PROGRESS","onLoadingInProgress","LOADING_ABANDONED","onLoadingAborted","setStreamProcessor","value","getStreamProcessor","isFragmentLoaded","request","isEqualComplete","req1","req2","action","ACTION_COMPLETE","isEqualMedia","isNaN","index","startTime","adaptationIndex","type","isEqualInit","quality","check","requests","isLoaded","some","req","isFragmentLoadedOrPending","i","length","url","getRequests","filter","states","state","Array","filteredRequests","forEach","getRequestsForState","concat","filterRequests","getRequestThreshold","duration","Math","min","removeExecutedRequestsBeforeTime","time","threshold","undefined","removeExecutedRequestsAfterTime","removeExecutedRequestsInTimeRange","start","end","syncExecutedRequestsWithBufferedRange","bufferedRanges","streamDuration","ln","abortRequests","abort","executeRequest","push","addSchedulingInfoMetrics","debug","trigger","STREAM_COMPLETED","fragmentModel","ACTION_DOWNLOAD","loadCurrentFragment","warn","FRAGMENT_LOADING_STARTED","sender","load","getRequestForTime","arr","lastIdx","hasOwnProperty","prop","addSchedulingInfo","mediaType","Date","availabilityStartTime","range","addRequestsQueue","e","splice","indexOf","response","error","FRAGMENT_LOADING_COMPLETED","FRAGMENT_LOADING_PROGRESS","FRAGMENT_LOADING_ABANDONED","reset","off","addExecutedRequest","__dashjs_factory_name","factory","getClassFactory","updateClassFactory"],"mappings":"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","file":"FragmentModel.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport FragmentRequest from '../vo/FragmentRequest';\nimport Debug from '../../core/Debug';\n\nconst FRAGMENT_MODEL_LOADING = 'loading';\nconst FRAGMENT_MODEL_EXECUTED = 'executed';\nconst FRAGMENT_MODEL_CANCELED = 'canceled';\nconst FRAGMENT_MODEL_FAILED = 'failed';\n\nfunction FragmentModel(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const metricsModel = config.metricsModel;\n    const fragmentLoader = config.fragmentLoader;\n\n    let instance,\n        logger,\n        streamProcessor,\n        executedRequests,\n        loadingRequests;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n        eventBus.on(Events.LOADING_COMPLETED, onLoadingCompleted, instance);\n        eventBus.on(Events.LOADING_DATA_PROGRESS, onLoadingInProgress, instance);\n        eventBus.on(Events.LOADING_ABANDONED, onLoadingAborted, instance);\n    }\n\n    function setStreamProcessor(value) {\n        streamProcessor = value;\n    }\n\n    function getStreamProcessor() {\n        return streamProcessor;\n    }\n\n    function isFragmentLoaded(request) {\n        const isEqualComplete = function (req1, req2) {\n            return ((req1.action === FragmentRequest.ACTION_COMPLETE) && (req1.action === req2.action));\n        };\n\n        const isEqualMedia = function (req1, req2) {\n            return !isNaN(req1.index) && (req1.startTime === req2.startTime) && (req1.adaptationIndex === req2.adaptationIndex) && (req1.type === req2.type);\n        };\n\n        const isEqualInit = function (req1, req2) {\n            return isNaN(req1.index) && isNaN(req2.index) && (req1.quality === req2.quality);\n        };\n\n        const check = function (requests) {\n            let isLoaded = false;\n\n            requests.some(req => {\n                if (isEqualMedia(request, req) || isEqualInit(request, req) || isEqualComplete(request, req)) {\n                    isLoaded = true;\n                    return isLoaded;\n                }\n            });\n            return isLoaded;\n        };\n\n        if (!request) {\n            return false;\n        }\n\n        return check(executedRequests);\n    }\n\n    function isFragmentLoadedOrPending(request) {\n        let isLoaded = false;\n        let i = 0;\n        let req;\n\n        // First, check if the fragment has already been loaded\n        isLoaded = isFragmentLoaded(request);\n\n        // Then, check if the fragment is about to be loeaded\n        if (!isLoaded) {\n            for (i = 0; i < loadingRequests.length; i++) {\n                req = loadingRequests[i];\n                if ((request.url === req.url) && (request.startTime === req.startTime)) {\n                    isLoaded = true;\n                }\n            }\n        }\n\n        return isLoaded;\n    }\n\n    /**\n     *\n     * Gets an array of {@link FragmentRequest} objects\n     *\n     * @param {Object} filter The object with properties by which the method filters the requests to be returned.\n     *  the only mandatory property is state, which must be a value from\n     *  other properties should match the properties of {@link FragmentRequest}. E.g.:\n     *  getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, quality: 0}) - returns\n     *  all the requests from executedRequests array where requests.quality = filter.quality\n     *\n     * @returns {Array}\n     * @memberof FragmentModel#\n     */\n    function getRequests(filter) {\n        const states = filter ? filter.state instanceof Array ? filter.state : [filter.state] : [];\n\n        let filteredRequests = [];\n        states.forEach(state => {\n            const requests = getRequestsForState(state);\n            filteredRequests = filteredRequests.concat(filterRequests(requests, filter));\n        });\n\n        return filteredRequests;\n    }\n\n    function getRequestThreshold(req) {\n        return isNaN(req.duration) ? 0.25 : Math.min(req.duration / 8, 0.5);\n    }\n\n    function removeExecutedRequestsBeforeTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime >= time - threshold : false);\n        });\n    }\n\n    function removeExecutedRequestsAfterTime(time) {\n        executedRequests = executedRequests.filter(req => {\n            return isNaN(req.startTime) || (time !== undefined ? req.startTime < time : false);\n        });\n    }\n\n    function removeExecutedRequestsInTimeRange(start, end) {\n        if (end <= start + 0.5) {\n            return;\n        }\n\n        executedRequests = executedRequests.filter(req => {\n            const threshold = getRequestThreshold(req);\n            return (isNaN(req.startTime) || req.startTime >= (end - threshold)) ||\n                (isNaN(req.duration) || (req.startTime + req.duration) <= (start + threshold));\n        });\n    }\n\n    // Remove requests that are not \"represented\" by any of buffered ranges\n    function syncExecutedRequestsWithBufferedRange(bufferedRanges, streamDuration) {\n        if (!bufferedRanges || bufferedRanges.length === 0) {\n            removeExecutedRequestsBeforeTime();\n            return;\n        }\n\n        let start = 0;\n        for (let i = 0, ln = bufferedRanges.length; i < ln; i++) {\n            removeExecutedRequestsInTimeRange(start, bufferedRanges.start(i));\n            start = bufferedRanges.end(i);\n        }\n        if (streamDuration > 0) {\n            removeExecutedRequestsInTimeRange(start, streamDuration);\n        }\n    }\n\n    function abortRequests() {\n        fragmentLoader.abort();\n        loadingRequests = [];\n    }\n\n    function executeRequest(request) {\n        switch (request.action) {\n            case FragmentRequest.ACTION_COMPLETE:\n                executedRequests.push(request);\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_EXECUTED);\n                logger.debug('executeRequest trigger STREAM_COMPLETED');\n                eventBus.trigger(Events.STREAM_COMPLETED, {\n                    request: request,\n                    fragmentModel: this\n                });\n                break;\n            case FragmentRequest.ACTION_DOWNLOAD:\n                addSchedulingInfoMetrics(request, FRAGMENT_MODEL_LOADING);\n                loadingRequests.push(request);\n                loadCurrentFragment(request);\n                break;\n            default:\n                logger.warn('Unknown request action.');\n        }\n    }\n\n    function loadCurrentFragment(request) {\n        eventBus.trigger(Events.FRAGMENT_LOADING_STARTED, {\n            sender: instance,\n            request: request\n        });\n        fragmentLoader.load(request);\n    }\n\n    function getRequestForTime(arr, time, threshold) {\n        // loop through the executed requests and pick the one for which the playback interval matches the given time\n        const lastIdx = arr.length - 1;\n        for (let i = lastIdx; i >= 0; i--) {\n            const req = arr[i];\n            const start = req.startTime;\n            const end = start + req.duration;\n            threshold = !isNaN(threshold) ? threshold : getRequestThreshold(req);\n            if ((!isNaN(start) && !isNaN(end) && ((time + threshold) >= start) && ((time - threshold) < end)) || (isNaN(start) && isNaN(time))) {\n                return req;\n            }\n        }\n        return null;\n    }\n\n    function filterRequests(arr, filter) {\n        // for time use a specific filtration function\n        if (filter.hasOwnProperty('time')) {\n            return [getRequestForTime(arr, filter.time, filter.threshold)];\n        }\n\n        return arr.filter(request => {\n            for (const prop in filter) {\n                if (prop === 'state') continue;\n                if (filter.hasOwnProperty(prop) && request[prop] != filter[prop]) return false;\n            }\n\n            return true;\n        });\n    }\n\n    function getRequestsForState(state) {\n        let requests;\n        switch (state) {\n            case FRAGMENT_MODEL_LOADING:\n                requests = loadingRequests;\n                break;\n            case FRAGMENT_MODEL_EXECUTED:\n                requests = executedRequests;\n                break;\n            default:\n                requests = [];\n        }\n        return requests;\n    }\n\n    function addSchedulingInfoMetrics(request, state) {\n        metricsModel.addSchedulingInfo(\n            request.mediaType,\n            new Date(),\n            request.type,\n            request.startTime,\n            request.availabilityStartTime,\n            request.duration,\n            request.quality,\n            request.range,\n            state);\n\n        metricsModel.addRequestsQueue(request.mediaType, loadingRequests, executedRequests);\n    }\n\n    function onLoadingCompleted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        loadingRequests.splice(loadingRequests.indexOf(e.request), 1);\n\n        if (e.response && !e.error) {\n            executedRequests.push(e.request);\n        }\n\n        addSchedulingInfoMetrics(e.request, e.error ? FRAGMENT_MODEL_FAILED : FRAGMENT_MODEL_EXECUTED);\n\n        eventBus.trigger(Events.FRAGMENT_LOADING_COMPLETED, {\n            request: e.request,\n            response: e.response,\n            error: e.error,\n            sender: this\n        });\n    }\n\n    function onLoadingInProgress(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(Events.FRAGMENT_LOADING_PROGRESS, {\n            request: e.request,\n            response: e.response,\n            error: e.error,\n            sender: this\n        });\n    }\n\n    function onLoadingAborted(e) {\n        if (e.sender !== fragmentLoader) return;\n\n        eventBus.trigger(Events.FRAGMENT_LOADING_ABANDONED, { streamProcessor: this.getStreamProcessor(), request: e.request, mediaType: e.mediaType });\n    }\n\n    function resetInitialSettings() {\n        executedRequests = [];\n        loadingRequests = [];\n    }\n\n    function reset() {\n        eventBus.off(Events.LOADING_COMPLETED, onLoadingCompleted, this);\n        eventBus.off(Events.LOADING_DATA_PROGRESS, onLoadingInProgress, this);\n        eventBus.off(Events.LOADING_ABANDONED, onLoadingAborted, this);\n\n        if (fragmentLoader) {\n            fragmentLoader.reset();\n        }\n        resetInitialSettings();\n    }\n\n    function addExecutedRequest(request) {\n        executedRequests.push(request);\n    }\n\n    instance = {\n        setStreamProcessor: setStreamProcessor,\n        getStreamProcessor: getStreamProcessor,\n        getRequests: getRequests,\n        isFragmentLoaded: isFragmentLoaded,\n        isFragmentLoadedOrPending: isFragmentLoadedOrPending,\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\n        removeExecutedRequestsAfterTime: removeExecutedRequestsAfterTime,\n        syncExecutedRequestsWithBufferedRange: syncExecutedRequestsWithBufferedRange,\n        abortRequests: abortRequests,\n        executeRequest: executeRequest,\n        reset: reset,\n        addExecutedRequest: addExecutedRequest\n    };\n\n    setup();\n    return instance;\n}\n\nFragmentModel.__dashjs_factory_name = 'FragmentModel';\nconst factory = FactoryMaker.getClassFactory(FragmentModel);\nfactory.FRAGMENT_MODEL_LOADING = FRAGMENT_MODEL_LOADING;\nfactory.FRAGMENT_MODEL_EXECUTED = FRAGMENT_MODEL_EXECUTED;\nfactory.FRAGMENT_MODEL_CANCELED = FRAGMENT_MODEL_CANCELED;\nfactory.FRAGMENT_MODEL_FAILED = FRAGMENT_MODEL_FAILED;\nFactoryMaker.updateClassFactory(FragmentModel.__dashjs_factory_name, factory);\nexport default factory;\n"]}