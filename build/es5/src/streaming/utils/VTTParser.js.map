{"version":3,"sources":["../../../../../src/streaming/utils/VTTParser.js"],"names":["FactoryMaker","Debug","WEBVTT","VTTParser","context","instance","logger","regExNewLine","regExToken","regExWhiteSpace","regExWhiteSpaceWordBoundary","setup","getInstance","getLogger","parse","data","captionArray","len","lastStartTime","split","length","i","item","match","attributes","parseItemAttributes","cuePoints","styles","text","getSublines","startTime","convertCuePointTimes","replace","endTime","isNaN","push","start","end","error","time","timeArray","parseInt","parseFloat","vttCuePoints","arr","shift","getCaptionStyles","styleObject","forEach","element","val","search","align","line","position","size","idx","subline","lineData","lineCount","j","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"VTTParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst WEBVTT = 'WEBVTT';\n\nfunction VTTParser() {\n    const context = this.context;\n\n    let instance,\n        logger,\n        regExNewLine,\n        regExToken,\n        regExWhiteSpace,\n        regExWhiteSpaceWordBoundary;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        regExNewLine = /(?:\\r\\n|\\r|\\n)/gm;\n        regExToken = /-->/;\n        regExWhiteSpace = /(^[\\s]+|[\\s]+$)/g;\n        regExWhiteSpaceWordBoundary = /\\s\\b/g;\n    }\n\n    function parse(data) {\n        const captionArray = [];\n        let len,\n            lastStartTime;\n\n        if (!data) {\n            return captionArray;\n        }\n\n        data = data.split( regExNewLine );\n        len = data.length;\n        lastStartTime = -1;\n\n        for (let i = 0 ; i < len; i++) {\n            let item = data[i];\n\n            if (item.length > 0 && item !== WEBVTT) {\n                if (item.match(regExToken)) {\n                    const attributes = parseItemAttributes(item);\n                    const cuePoints = attributes.cuePoints;\n                    const styles = attributes.styles;\n                    const text = getSublines(data, i + 1);\n                    const startTime = convertCuePointTimes(cuePoints[0].replace(regExWhiteSpace, ''));\n                    const endTime = convertCuePointTimes(cuePoints[1].replace(regExWhiteSpace, ''));\n\n                    if ((!isNaN(startTime) && !isNaN(endTime)) && startTime >= lastStartTime && endTime > startTime) {\n                        if (text !== '') {\n                            lastStartTime = startTime;\n                            //TODO Make VO external so other parsers can use.\n                            captionArray.push({\n                                start: startTime,\n                                end: endTime,\n                                data: text,\n                                styles: styles\n                            });\n                        }\n                        else {\n                            logger.error('Skipping cue due to empty/malformed cue text');\n                        }\n                    }\n                    else {\n                        logger.error('Skipping cue due to incorrect cue timing');\n                    }\n                }\n            }\n        }\n\n        return captionArray;\n    }\n\n    function convertCuePointTimes(time) {\n        const timeArray = time.split(':');\n        const len = timeArray.length - 1;\n\n        time = parseInt( timeArray[len - 1], 10 ) * 60 + parseFloat( timeArray[len]);\n\n        if ( len === 2 ) {\n            time += parseInt( timeArray[0], 10 ) * 3600;\n        }\n\n        return time;\n    }\n\n    function parseItemAttributes(data) {\n        const vttCuePoints = data.split(regExToken);\n        const arr = vttCuePoints[1].split(regExWhiteSpaceWordBoundary);\n        arr.shift(); //remove first array index it is empty...\n        vttCuePoints[1] = arr[0];\n        arr.shift();\n        return {cuePoints: vttCuePoints, styles: getCaptionStyles(arr)};\n    }\n\n    function getCaptionStyles(arr) {\n        const styleObject = {};\n        arr.forEach(function (element) {\n            if (element.split(/:/).length > 1) {\n                let val = element.split(/:/)[1];\n                if (val && val.search(/%/) != -1) {\n                    val = parseInt(val.replace(/%/, ''), 10);\n                }\n                if (element.match(/align/) || element.match(/A/)) {\n                    styleObject.align = val;\n                }\n                if (element.match(/line/) || element.match(/L/) ) {\n                    styleObject.line = val;\n                }\n                if (element.match(/position/) || element.match(/P/) ) {\n                    styleObject.position = val;\n                }\n                if (element.match(/size/) || element.match(/S/)) {\n                    styleObject.size = val;\n                }\n            }\n        });\n\n        return styleObject;\n    }\n\n    /*\n    * VTT can have multiple lines to display per cuepoint.\n    */\n    function getSublines(data, idx) {\n        let i = idx;\n\n        let subline = '';\n        let lineData = '';\n        let lineCount;\n\n        while (data[i] !== '' && i < data.length) {\n            i++;\n        }\n\n        lineCount = i - idx;\n        if (lineCount > 1) {\n            for (let j = 0; j < lineCount; j++) {\n                lineData = data[(idx + j)];\n                if (!lineData.match(regExToken)) {\n                    subline += lineData;\n                    if (j !== lineCount - 1) {\n                        subline += '\\n';\n                    }\n                }\n                else {\n                    // caption text should not have '-->' in it\n                    subline = '';\n                    break;\n                }\n            }\n        } else {\n            lineData = data[idx];\n            if (!lineData.match(regExToken))\n                subline = lineData;\n        }\n        return subline;\n    }\n\n    instance = {\n        parse: parse\n    };\n\n    setup();\n    return instance;\n}\nVTTParser.__dashjs_factory_name = 'VTTParser';\nexport default FactoryMaker.getSingletonFactory(VTTParser);\n"]}