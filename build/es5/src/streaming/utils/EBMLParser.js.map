{"version":3,"sources":["../../../../../src/streaming/utils/EBMLParser.js"],"names":["FactoryMaker","EBMLParser","config","instance","data","DataView","pos","getPos","setPos","value","consumeTag","tag","test","found","bytesConsumed","p1","p2","undefined","getUint32","getUint16","getUint8","required","Error","consumeTagAndSize","getMatroskaCodedNum","parseTag","size","parse","skipOverElement","headerSize","retainMSB","bytesUsed","mask","maxBytes","extraBytes","num","ch","i","getMatroskaFloat","outFloat","getFloat32","getFloat64","getMatroskaUint","val","moreData","byteLength","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"EBMLParser.js","sourcesContent":["import FactoryMaker from '../../core/FactoryMaker';\n\n/**\n * Creates an instance of an EBMLParser class which implements a large subset\n * of the functionality required to parse Matroska EBML\n *\n * @param {Object} config object with data member which is the buffer to parse\n */\nfunction EBMLParser(config) {\n\n    config = config || {};\n    let instance;\n\n    let data = new DataView(config.data);\n    let pos = 0;\n\n    function getPos() {\n        return pos;\n    }\n\n    function setPos(value) {\n        pos = value;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformed.\n     * @memberof EBMLParser\n     */\n    function consumeTag(tag, test) {\n        let found = true;\n        let bytesConsumed = 0;\n        let p1,\n            p2;\n\n        if (test === undefined) {\n            test = false;\n        }\n\n        if (tag.tag > 0xFFFFFF) {\n            if (data.getUint32(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 4;\n        } else if (tag.tag > 0xFFFF) {\n            // 3 bytes\n            p1 = data.getUint16(pos);\n            p2 = data.getUint8(pos + 2);\n\n            // shift p1 over a byte and add p2\n            if (p1 * 256 + p2 !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 3;\n        } else if (tag.tag > 0xFF) {\n            if (data.getUint16(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 2;\n        } else {\n            if (data.getUint8(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 1;\n        }\n\n        if (!found && tag.required && !test) {\n            throw new Error('required tag not found');\n        }\n\n        if (found) {\n            pos += bytesConsumed;\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformedata.\n     * @memberof EBMLParser\n     */\n    function consumeTagAndSize(tag, test) {\n        let found = consumeTag(tag, test);\n\n        if (found) {\n            getMatroskaCodedNum();\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to parse a binary\n     * field, using a parser defined in the tag itself\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag,\n     * {boolean} required flag, and a parse function which takes a size parameter\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found,\n     * or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function parseTag(tag) {\n        let size;\n\n        consumeTag(tag);\n        size = getMatroskaCodedNum();\n        return instance[tag.parse](size);\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to skip over the\n     * entire section of EBML encapsulated by the tag.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and\n     * {boolean} required flag\n     * @param {boolean} test a flag to indicate if an exception should be thrown\n     * if a required tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test is\n     * false or undefined or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function skipOverElement(tag, test) {\n        let found = consumeTag(tag, test);\n        let headerSize;\n\n        if (found) {\n            headerSize = getMatroskaCodedNum();\n            pos += headerSize;\n        }\n\n        return found;\n    }\n\n    /**\n     * Returns and consumes a number encoded according to the Matroska EBML\n     * specification from the bitstream.\n     *\n     * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the\n     * first 1). this is usually true when reading Tag IDs.\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaCodedNum(retainMSB) {\n        let bytesUsed = 1;\n        let mask = 0x80;\n        let maxBytes = 8;\n        let extraBytes = -1;\n        let num = 0;\n        let ch = data.getUint8(pos);\n        let i = 0;\n\n        for (i = 0; i < maxBytes; i += 1) {\n            if ((ch & mask) === mask) {\n                num = (retainMSB === undefined) ? ch & ~mask : ch;\n                extraBytes = i;\n                break;\n            }\n            mask >>= 1;\n        }\n\n        for (i = 0; i < extraBytes; i += 1, bytesUsed += 1) {\n            num = (num << 8) | (0xff & data.getUint8(pos + bytesUsed));\n        }\n\n        pos += bytesUsed;\n\n        return num;\n    }\n\n    /**\n     * Returns and consumes a float from the bitstream.\n     *\n     * @param {number} size 4 or 8 byte floats are supported\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaFloat(size) {\n        let outFloat;\n\n        switch (size) {\n        case 4:\n            outFloat = data.getFloat32(pos);\n            pos += 4;\n            break;\n        case 8:\n            outFloat = data.getFloat64(pos);\n            pos += 8;\n            break;\n        }\n        return outFloat;\n    }\n\n    /**\n     * Consumes and returns an unsigned int from the bitstream.\n     *\n     * @param {number} size 1 to 8 bytes\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaUint(size) {\n        let val = 0;\n\n        for (let i = 0; i < size; i += 1) {\n            val <<= 8;\n            val |= data.getUint8(pos + i) & 0xff;\n        }\n\n        pos += size;\n        return val;\n    }\n\n    /**\n     * Tests whether there is more data in the bitstream for parsing\n     *\n     * @return {boolean} whether there is more data to parse\n     * @memberof EBMLParser\n     */\n    function moreData() {\n        return pos < data.byteLength;\n    }\n\n    instance = {\n        getPos: getPos,\n        setPos: setPos,\n        consumeTag: consumeTag,\n        consumeTagAndSize: consumeTagAndSize,\n        parseTag: parseTag,\n        skipOverElement: skipOverElement,\n        getMatroskaCodedNum: getMatroskaCodedNum,\n        getMatroskaFloat: getMatroskaFloat,\n        getMatroskaUint: getMatroskaUint,\n        moreData: moreData\n    };\n\n    return instance;\n}\n\nEBMLParser.__dashjs_factory_name = 'EBMLParser';\nexport default FactoryMaker.getClassFactory(EBMLParser);"]}