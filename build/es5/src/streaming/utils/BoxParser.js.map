{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":["Debug","IsoFile","FactoryMaker","ISOBoxer","IsoBoxSearchInfo","BoxParser","logger","instance","context","setup","getInstance","getLogger","parse","data","fileStart","undefined","parsedFile","parseBuffer","dashIsoFile","create","setData","findLastTopIsoBoxCompleted","types","buffer","offset","byteLength","ArrayBuffer","Uint8Array","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","indexOf","getSamplesInfo","ab","sampleList","lastSequenceNumber","NaN","totalDuration","numSequences","isoFile","moofBoxes","getBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","length","sequence_number","subsIndex","nextSubsSample","moofBox","trafBoxes","getChildBoxes","trafBox","tfhdBox","getChildBox","tfdtBox","baseMediaDecodeTime","trunBoxes","subsBoxes","trunBox","sample_count","base_data_offset","data_offset","samples","sample_duration","default_sample_duration","sample_size","default_sample_size","sample_composition_time_offset","sampleData","subsBox","entry_count","entries","sample_delta","subSizes","entry","subsample_count","push","subsamples","subsample_size","getMediaTimescaleFromMoov","mdhdBox","getBox","timescale","String","fromCharCode","findInitRange","initRange","start","end","ftyp","moov","debug","isComplete","size","__dashjs_factory_name","getSingletonFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BA,MAAOA,MAAP,KAAkB,kBAAlB,CACA,MAAOC,QAAP,KAAoB,WAApB,CACA,MAAOC,aAAP,KAAyB,yBAAzB,CACA,MAAOC,SAAP,KAAqB,gBAArB,CAEA,MAAOC,iBAAP,KAA6B,wBAA7B,CAEA,QAASC,UAAT,EAAmB,UAAY,CAE3B,GAAIC,OAAJ,CACIC,QADJ,CAEA,GAAIC,SAAU,KAAKA,OAAnB,CAEA,QAASC,MAAT,EAAiB,CACbH,OAASN,MAAMQ,OAAN,EAAeE,WAAf,GAA6BC,SAA7B,CAAuCJ,QAAvC,CAAT,CACH,CAED;;;;OAKA,QAASK,MAAT,CAAeC,IAAf,CAAqB,CACjB,GAAI,CAACA,IAAL,CAAW,MAAO,KAAP,CAEX,GAAIA,KAAKC,SAAL,GAAmBC,SAAvB,CAAkC,CAC9BF,KAAKC,SAAL,CAAiB,CAAjB,CACH,CAED,GAAIE,YAAab,SAASc,WAAT,CAAqBJ,IAArB,CAAjB,CACA,GAAIK,aAAcjB,QAAQO,OAAR,EAAiBW,MAAjB,EAAlB,CAEAD,YAAYE,OAAZ,CAAoBJ,UAApB,EAEA,MAAOE,YAAP,CACH,CAED;;;;;;;;OASA,QAASG,2BAAT,CAAoCC,KAApC,CAA2CC,MAA3C,CAAmDC,MAAnD,CAA2D,CACvD,GAAIA,SAAWT,SAAf,CAA0B,CACtBS,OAAS,CAAT,CACH,CAED;AACA,GAAI,CAACD,MAAD,EAAWC,OAAS,CAAT,EAAcD,OAAOE,UAApC,CAAgD,CAC5C,MAAO,IAAIrB,iBAAJ,CAAqB,CAArB,CAAwB,KAAxB,CAAP,CACH,CAED,KAAMS,MAAQU,iBAAkBG,YAAnB,CAAkC,GAAIC,WAAJ,CAAeJ,MAAf,CAAlC,CAA2DA,MAAxE,CACA,GAAIK,QAAJ,CACA,GAAIC,qBAAsB,CAA1B,CACA,MAAOL,OAASX,KAAKY,UAArB,CAAiC,CAC7B,KAAMK,SAAUC,YAAYlB,IAAZ,CAAkBW,MAAlB,CAAhB,CACA,KAAMQ,SAAUC,gBAAgBpB,IAAhB,CAAsBW,OAAS,CAA/B,CAAhB,CAEA,GAAIM,UAAY,CAAhB,CAAmB,CACf,MACH,CAED,GAAIN,OAASM,OAAT,EAAoBjB,KAAKY,UAA7B,CAAyC,CACrC,GAAIH,MAAMY,OAAN,CAAcF,OAAd,GAA0B,CAA9B,CAAiC,CAC7BJ,QAAU,GAAIxB,iBAAJ,CAAqBoB,MAArB,CAA6B,IAA7B,CAAmCM,OAAnC,CAAV,CACH,CAFD,IAEO,CACHD,oBAAsBL,OAASM,OAA/B,CACH,CACJ,CAEDN,QAAUM,OAAV,CACH,CAED,GAAI,CAACF,OAAL,CAAc,CACV,MAAO,IAAIxB,iBAAJ,CAAqByB,mBAArB,CAA0C,KAA1C,CAAP,CACH,CAED,MAAOD,QAAP,CACH,CAED,QAASO,eAAT,CAAwBC,EAAxB,CAA4B,CACxB,GAAI,CAACA,EAAD,EAAOA,GAAGX,UAAH,GAAkB,CAA7B,CAAgC,CAC5B,MAAO,CAACY,WAAY,EAAb,CAAiBC,mBAAoBC,GAArC,CAA0CC,cAAeD,GAAzD,CAA8DE,aAAcF,GAA5E,CAAP,CACH,CACD,GAAIG,SAAU9B,MAAMwB,EAAN,CAAd,CACA;AACA,GAAIO,WAAYD,QAAQE,QAAR,CAAiB,MAAjB,CAAhB,CACA;AACA,GAAIC,WAAYH,QAAQE,QAAR,CAAiB,MAAjB,CAAhB,CAEA,GAAIE,eAAJ,CACIC,2BADJ,CAEIC,WAFJ,CAGIC,UAHJ,CAIIC,SAJJ,CAKIb,UALJ,CAMIc,MANJ,CAOIC,CAPJ,CAOOC,CAPP,CAOUC,CAPV,CAOaC,CAPb,CAOgBC,CAPhB,CAOmBC,CAPnB,CAQIC,UARJ,CASIpB,kBATJ,CAUIG,YAVJ,CAWID,aAXJ,CAaAC,aAAeC,QAAQE,QAAR,CAAiB,MAAjB,EAAyBe,MAAxC,CACArB,mBAAqBO,UAAUA,UAAUc,MAAV,CAAmB,CAA7B,EAAgCC,eAArD,CACAZ,YAAc,CAAd,CAEAX,WAAa,EAAb,CACA,GAAIwB,WAAY,CAAC,CAAjB,CACA,GAAIC,gBAAiB,CAAC,CAAtB,CACA,IAAKP,EAAI,CAAT,CAAYA,EAAIZ,UAAUgB,MAA1B,CAAkCJ,GAAlC,CAAuC,CACnC,GAAIQ,SAAUpB,UAAUY,CAAV,CAAd,CACA;AACA,GAAIS,WAAYD,QAAQE,aAAR,CAAsB,MAAtB,CAAhB,CACA,IAAKZ,EAAI,CAAT,CAAYA,EAAIW,UAAUL,MAA1B,CAAkCN,GAAlC,CAAuC,CACnC,GAAIa,SAAUF,UAAUX,CAAV,CAAd,CACA;AACA,GAAIc,SAAUD,QAAQE,WAAR,CAAoB,MAApB,CAAd,CACA;AACA,GAAIC,SAAUH,QAAQE,WAAR,CAAoB,MAApB,CAAd,CACAlB,UAAYmB,QAAQC,mBAApB,CACA;AACA,GAAIC,WAAYL,QAAQD,aAAR,CAAsB,MAAtB,CAAhB,CACA;AACA,GAAIO,WAAYN,QAAQD,aAAR,CAAsB,MAAtB,CAAhB,CACA,IAAKX,EAAI,CAAT,CAAYA,EAAIiB,UAAUZ,MAA1B,CAAkCL,GAAlC,CAAuC,CACnC,GAAImB,SAAUF,UAAUjB,CAAV,CAAd,CACAN,YAAcyB,QAAQC,YAAtB,CACAhB,WAAa,CAACS,QAAQQ,gBAAR,EAA4B,CAA7B,GAAmCF,QAAQG,WAAR,EAAuB,CAA1D,CAAb,CAEA,IAAKxB,EAAI,CAAT,CAAYA,EAAIJ,WAAhB,CAA6BI,GAA7B,CAAkC,CAC9BD,OAASsB,QAAQI,OAAR,CAAgBzB,CAAhB,CAAT,CACAN,eAAkBK,OAAO2B,eAAP,GAA2B/D,SAA5B,CAAyCoC,OAAO2B,eAAhD,CAAkEX,QAAQY,uBAA3F,CACA9B,WAAcE,OAAO6B,WAAP,GAAuBjE,SAAxB,CAAqCoC,OAAO6B,WAA5C,CAA0Db,QAAQc,mBAA/E,CACAlC,4BAA+BI,OAAO+B,8BAAP,GAA0CnE,SAA3C,CAAwDoC,OAAO+B,8BAA/D,CAAgG,CAA9H,CACA,GAAIC,YAAa,CACb,MAAOjC,SADM,CAEb,MAAQA,UAAYH,2BAFP,CAGb,WAAYD,cAHC,CAIb,SAAUiB,QAAQvC,MAAR,CAAiBkC,UAJd,CAKb,OAAQT,UALK,CAMb,WAAY,CAACA,UAAD,CANC,CAAjB,CAQA,GAAIuB,SAAJ,CAAe,CACX,IAAKhB,EAAI,CAAT,CAAYA,EAAIgB,UAAUb,MAA1B,CAAkCH,GAAlC,CAAuC,CACnC,GAAI4B,SAAUZ,UAAUhB,CAAV,CAAd,CACA,GAAIK,UAAauB,QAAQC,WAAR,CAAsB,CAAnC,EAAyCjC,EAAIU,cAAjD,CAAiE,CAC7DD,YACAC,gBAAkBsB,QAAQE,OAAR,CAAgBzB,SAAhB,EAA2B0B,YAA7C,CACH,CACD,GAAInC,GAAKU,cAAT,CAAyB,CACrBqB,WAAWK,QAAX,CAAsB,EAAtB,CACA,GAAIC,OAAQL,QAAQE,OAAR,CAAgBzB,SAAhB,CAAZ,CACA,IAAKJ,EAAI,CAAT,CAAYA,EAAIgC,MAAMC,eAAtB,CAAuCjC,GAAvC,CAA4C,CACxC0B,WAAWK,QAAX,CAAoBG,IAApB,CAAyBF,MAAMG,UAAN,CAAiBnC,CAAjB,EAAoBoC,cAA7C,EACH,CACJ,CACJ,CACJ,CACDxD,WAAWsD,IAAX,CAAgBR,UAAhB,EACAzB,YAAcT,UAAd,CACAC,WAAaJ,cAAb,CACH,CACJ,CACDN,cAAgBU,UAAYmB,QAAQC,mBAApC,CACH,CACJ,CACD,MAAO,CAACjC,WAAYA,UAAb,CAAyBC,mBAAoBA,kBAA7C,CAAiEE,cAAeA,aAAhF,CAA+FC,aAAcA,YAA7G,CAAP,CACH,CAED,QAASqD,0BAAT,CAAmC1D,EAAnC,CAAuC,CACnC,GAAIM,SAAU9B,MAAMwB,EAAN,CAAd,CACA,GAAI2D,SAAUrD,QAAUA,QAAQsD,MAAR,CAAe,MAAf,CAAV,CAAmCjF,SAAjD,CAEA,MAAOgF,SAAUA,QAAQE,SAAlB,CAA8B1D,GAArC,CACH,CAED,QAASR,YAAT,CAAqBlB,IAArB,CAA2BW,MAA3B,CAAmC,CAC/B,MAAOX,MAAKW,OAAS,CAAd,IAAqB,CAArB,CACFX,KAAKW,OAAS,CAAd,GAAoB,CAArB,GAA4B,CADzB,CAEFX,KAAKW,OAAS,CAAd,GAAoB,EAArB,GAA6B,CAF1B,CAGFX,KAAKW,MAAL,GAAgB,EAAjB,GAAyB,CAH7B,CAIH,CAED,QAASS,gBAAT,CAAyBpB,IAAzB,CAA+BW,MAA/B,CAAuC,CACnC,MAAO0E,QAAOC,YAAP,CAAoBtF,KAAKW,QAAL,CAApB,EACH0E,OAAOC,YAAP,CAAoBtF,KAAKW,QAAL,CAApB,CADG,CAEH0E,OAAOC,YAAP,CAAoBtF,KAAKW,QAAL,CAApB,CAFG,CAGH0E,OAAOC,YAAP,CAAoBtF,KAAKW,MAAL,CAApB,CAHJ,CAIH,CAED,QAAS4E,cAAT,CAAuBvF,IAAvB,CAA6B,CACzB,GAAIwF,WAAY,IAAhB,CACA,GAAIC,MAAJ,CACIC,GADJ,CAGA,KAAM7D,SAAU9B,MAAMC,IAAN,CAAhB,CAEA,GAAI,CAAC6B,OAAL,CAAc,CACV,MAAO2D,UAAP,CACH,CAED,KAAMG,MAAO9D,QAAQsD,MAAR,CAAe,MAAf,CAAb,CACA,KAAMS,MAAO/D,QAAQsD,MAAR,CAAe,MAAf,CAAb,CAEA1F,OAAOoG,KAAP,CAAa,+BAAb,EAEA,GAAID,MAAQA,KAAKE,UAAjB,CAA6B,CACzBL,MAAQE,KAAOA,KAAKhF,MAAZ,CAAqBiF,KAAKjF,MAAlC,CACA+E,IAAME,KAAKjF,MAAL,CAAciF,KAAKG,IAAnB,CAA0B,CAAhC,CACAP,UAAYC,MAAQ,GAAR,CAAcC,GAA1B,CAEAjG,OAAOoG,KAAP,CAAa,qCAAuCL,SAApD,EACH,CAED,MAAOA,UAAP,CACH,CAED9F,SAAW,CACPK,MAAOA,KADA,CAEPS,2BAA4BA,0BAFrB,CAGPyE,0BAA2BA,yBAHpB,CAIP3D,eAAgBA,cAJT,CAKPiE,cAAeA,aALR,CAAX,CAQA3F,QAEA,MAAOF,SAAP,CACH,CACDF,UAAUwG,qBAAV,CAAkC,WAAlC,CACA,cAAe3G,cAAa4G,mBAAb,CAAiCzG,SAAjC,CAAf","file":"BoxParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Debug from '../../core/Debug';\nimport IsoFile from './IsoFile';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ISOBoxer from 'codem-isoboxer';\n\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\n\nfunction BoxParser(/*config*/) {\n\n    let logger,\n        instance;\n    let context = this.context;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @returns {IsoFile|null}\n     * @memberof BoxParser#\n     */\n    function parse(data) {\n        if (!data) return null;\n\n        if (data.fileStart === undefined) {\n            data.fileStart = 0;\n        }\n\n        let parsedFile = ISOBoxer.parseBuffer(data);\n        let dashIsoFile = IsoFile(context).create();\n\n        dashIsoFile.setData(parsedFile);\n\n        return dashIsoFile;\n    }\n\n    /**\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\n     * @param {string[]} types\n     * @param {ArrayBuffer|uint8Array} buffer\n     * @param {number} offset\n     * @returns {IsoBoxSearchInfo}\n     * @memberof BoxParser#\n     */\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        // 8 = size (uint32) + type (4 characters)\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    function getSamplesInfo(ab) {\n        if (!ab || ab.byteLength === 0) {\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\n        }\n        let isoFile = parse(ab);\n        // zero or more moofs\n        let moofBoxes = isoFile.getBoxes('moof');\n        // exactly one mfhd per moof\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\n\n        let sampleDuration,\n            sampleCompositionTimeOffset,\n            sampleCount,\n            sampleSize,\n            sampleDts,\n            sampleList,\n            sample,\n            i, j, k, l, m, n,\n            dataOffset,\n            lastSequenceNumber,\n            numSequences,\n            totalDuration;\n\n        numSequences = isoFile.getBoxes('moof').length;\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n        sampleCount = 0;\n\n        sampleList = [];\n        let subsIndex = -1;\n        let nextSubsSample = -1;\n        for (l = 0; l < moofBoxes.length; l++) {\n            let moofBox = moofBoxes[l];\n            // zero or more trafs per moof\n            let trafBoxes = moofBox.getChildBoxes('traf');\n            for (j = 0; j < trafBoxes.length; j++) {\n                let trafBox = trafBoxes[j];\n                // exactly one tfhd per traf\n                let tfhdBox = trafBox.getChildBox('tfhd');\n                // zero or one tfdt per traf\n                let tfdtBox = trafBox.getChildBox('tfdt');\n                sampleDts = tfdtBox.baseMediaDecodeTime;\n                // zero or more truns per traf\n                let trunBoxes = trafBox.getChildBoxes('trun');\n                // zero or more subs per traf\n                let subsBoxes = trafBox.getChildBoxes('subs');\n                for (k = 0; k < trunBoxes.length; k++) {\n                    let trunBox = trunBoxes[k];\n                    sampleCount = trunBox.sample_count;\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n                    for (i = 0; i < sampleCount; i++) {\n                        sample = trunBox.samples[i];\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\n                        let sampleData = {\n                            'dts': sampleDts,\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\n                            'duration': sampleDuration,\n                            'offset': moofBox.offset + dataOffset,\n                            'size': sampleSize,\n                            'subSizes': [sampleSize]\n                        };\n                        if (subsBoxes) {\n                            for (m = 0; m < subsBoxes.length; m++) {\n                                let subsBox = subsBoxes[m];\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\n                                    subsIndex++;\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                                }\n                                if (i == nextSubsSample) {\n                                    sampleData.subSizes = [];\n                                    let entry = subsBox.entries[subsIndex];\n                                    for (n = 0; n < entry.subsample_count; n++) {\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                                    }\n                                }\n                            }\n                        }\n                        sampleList.push(sampleData);\n                        dataOffset += sampleSize;\n                        sampleDts += sampleDuration;\n                    }\n                }\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n            }\n        }\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\n    }\n\n    function getMediaTimescaleFromMoov(ab) {\n        let isoFile = parse(ab);\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n\n        return mdhdBox ? mdhdBox.timescale : NaN;\n    }\n\n    function parseUint32(data, offset) {\n        return data[offset + 3] >>> 0 |\n            (data[offset + 2] << 8) >>> 0 |\n            (data[offset + 1] << 16) >>> 0 |\n            (data[offset] << 24) >>> 0;\n    }\n\n    function parseIsoBoxType(data, offset) {\n        return String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset]);\n    }\n\n    function findInitRange(data) {\n        let initRange = null;\n        let start,\n            end;\n\n        const isoFile = parse(data);\n\n        if (!isoFile) {\n            return initRange;\n        }\n\n        const ftyp = isoFile.getBox('ftyp');\n        const moov = isoFile.getBox('moov');\n\n        logger.debug('Searching for initialization.');\n\n        if (moov && moov.isComplete) {\n            start = ftyp ? ftyp.offset : moov.offset;\n            end = moov.offset + moov.size - 1;\n            initRange = start + '-' + end;\n\n            logger.debug('Found the initialization.  Range: ' + initRange);\n        }\n\n        return initRange;\n    }\n\n    instance = {\n        parse: parse,\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n        getSamplesInfo: getSamplesInfo,\n        findInitRange: findInitRange\n    };\n\n    setup();\n\n    return instance;\n}\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexport default FactoryMaker.getSingletonFactory(BoxParser);\n"]}