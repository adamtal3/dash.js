{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":["Debug","IsoFile","FactoryMaker","ISOBoxer","IsoBoxSearchInfo","BoxParser","logger","instance","context","setup","getInstance","getLogger","parse","data","fileStart","undefined","parsedFile","parseBuffer","dashIsoFile","create","setData","findLastTopIsoBoxCompleted","types","buffer","offset","byteLength","ArrayBuffer","Uint8Array","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","indexOf","getSamplesInfo","ab","sampleList","lastSequenceNumber","NaN","totalDuration","numSequences","isoFile","moofBoxes","getBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","length","sequence_number","subsIndex","nextSubsSample","moofBox","trafBoxes","getChildBoxes","trafBox","tfhdBox","getChildBox","tfdtBox","baseMediaDecodeTime","trunBoxes","subsBoxes","trunBox","sample_count","base_data_offset","data_offset","samples","sample_duration","default_sample_duration","sample_size","default_sample_size","sample_composition_time_offset","sampleData","subsBox","entry_count","entries","sample_delta","subSizes","entry","subsample_count","push","subsamples","subsample_size","getMediaTimescaleFromMoov","mdhdBox","getBox","timescale","String","fromCharCode","findInitRange","initRange","start","end","ftyp","moov","debug","isComplete","size","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"BoxParser.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Debug from '../../core/Debug';\nimport IsoFile from './IsoFile';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport ISOBoxer from 'codem-isoboxer';\n\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\n\nfunction BoxParser(/*config*/) {\n\n    let logger,\n        instance;\n    let context = this.context;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     * @returns {IsoFile|null}\n     * @memberof BoxParser#\n     */\n    function parse(data) {\n        if (!data) return null;\n\n        if (data.fileStart === undefined) {\n            data.fileStart = 0;\n        }\n\n        let parsedFile = ISOBoxer.parseBuffer(data);\n        let dashIsoFile = IsoFile(context).create();\n\n        dashIsoFile.setData(parsedFile);\n\n        return dashIsoFile;\n    }\n\n    /**\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\n     * @param {string[]} types\n     * @param {ArrayBuffer|uint8Array} buffer\n     * @param {number} offset\n     * @returns {IsoBoxSearchInfo}\n     * @memberof BoxParser#\n     */\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n\n        // 8 = size (uint32) + type (4 characters)\n        if (!buffer || offset + 8 >= buffer.byteLength) {\n            return new IsoBoxSearchInfo(0, false);\n        }\n\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\n        let boxInfo;\n        let lastCompletedOffset = 0;\n        while (offset < data.byteLength) {\n            const boxSize = parseUint32(data, offset);\n            const boxType = parseIsoBoxType(data, offset + 4);\n\n            if (boxSize === 0) {\n                break;\n            }\n\n            if (offset + boxSize <= data.byteLength) {\n                if (types.indexOf(boxType) >= 0) {\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\n                } else {\n                    lastCompletedOffset = offset + boxSize;\n                }\n            }\n\n            offset += boxSize;\n        }\n\n        if (!boxInfo) {\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\n        }\n\n        return boxInfo;\n    }\n\n    function getSamplesInfo(ab) {\n        if (!ab || ab.byteLength === 0) {\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\n        }\n        let isoFile = parse(ab);\n        // zero or more moofs\n        let moofBoxes = isoFile.getBoxes('moof');\n        // exactly one mfhd per moof\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\n\n        let sampleDuration,\n            sampleCompositionTimeOffset,\n            sampleCount,\n            sampleSize,\n            sampleDts,\n            sampleList,\n            sample,\n            i, j, k, l, m, n,\n            dataOffset,\n            lastSequenceNumber,\n            numSequences,\n            totalDuration;\n\n        numSequences = isoFile.getBoxes('moof').length;\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\n        sampleCount = 0;\n\n        sampleList = [];\n        let subsIndex = -1;\n        let nextSubsSample = -1;\n        for (l = 0; l < moofBoxes.length; l++) {\n            let moofBox = moofBoxes[l];\n            // zero or more trafs per moof\n            let trafBoxes = moofBox.getChildBoxes('traf');\n            for (j = 0; j < trafBoxes.length; j++) {\n                let trafBox = trafBoxes[j];\n                // exactly one tfhd per traf\n                let tfhdBox = trafBox.getChildBox('tfhd');\n                // zero or one tfdt per traf\n                let tfdtBox = trafBox.getChildBox('tfdt');\n                sampleDts = tfdtBox.baseMediaDecodeTime;\n                // zero or more truns per traf\n                let trunBoxes = trafBox.getChildBoxes('trun');\n                // zero or more subs per traf\n                let subsBoxes = trafBox.getChildBoxes('subs');\n                for (k = 0; k < trunBoxes.length; k++) {\n                    let trunBox = trunBoxes[k];\n                    sampleCount = trunBox.sample_count;\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\n\n                    for (i = 0; i < sampleCount; i++) {\n                        sample = trunBox.samples[i];\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\n                        let sampleData = {\n                            'dts': sampleDts,\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\n                            'duration': sampleDuration,\n                            'offset': moofBox.offset + dataOffset,\n                            'size': sampleSize,\n                            'subSizes': [sampleSize]\n                        };\n                        if (subsBoxes) {\n                            for (m = 0; m < subsBoxes.length; m++) {\n                                let subsBox = subsBoxes[m];\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\n                                    subsIndex++;\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\n                                }\n                                if (i == nextSubsSample) {\n                                    sampleData.subSizes = [];\n                                    let entry = subsBox.entries[subsIndex];\n                                    for (n = 0; n < entry.subsample_count; n++) {\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\n                                    }\n                                }\n                            }\n                        }\n                        sampleList.push(sampleData);\n                        dataOffset += sampleSize;\n                        sampleDts += sampleDuration;\n                    }\n                }\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\n            }\n        }\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\n    }\n\n    function getMediaTimescaleFromMoov(ab) {\n        let isoFile = parse(ab);\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\n\n        return mdhdBox ? mdhdBox.timescale : NaN;\n    }\n\n    function parseUint32(data, offset) {\n        return data[offset + 3] >>> 0 |\n            (data[offset + 2] << 8) >>> 0 |\n            (data[offset + 1] << 16) >>> 0 |\n            (data[offset] << 24) >>> 0;\n    }\n\n    function parseIsoBoxType(data, offset) {\n        return String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset++]) +\n            String.fromCharCode(data[offset]);\n    }\n\n    function findInitRange(data) {\n        let initRange = null;\n        let start,\n            end;\n\n        const isoFile = parse(data);\n\n        if (!isoFile) {\n            return initRange;\n        }\n\n        const ftyp = isoFile.getBox('ftyp');\n        const moov = isoFile.getBox('moov');\n\n        logger.debug('Searching for initialization.');\n\n        if (moov && moov.isComplete) {\n            start = ftyp ? ftyp.offset : moov.offset;\n            end = moov.offset + moov.size - 1;\n            initRange = start + '-' + end;\n\n            logger.debug('Found the initialization.  Range: ' + initRange);\n        }\n\n        return initRange;\n    }\n\n    instance = {\n        parse: parse,\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\n        getSamplesInfo: getSamplesInfo,\n        findInitRange: findInitRange\n    };\n\n    setup();\n\n    return instance;\n}\nBoxParser.__dashjs_factory_name = 'BoxParser';\nexport default FactoryMaker.getSingletonFactory(BoxParser);\n"]}