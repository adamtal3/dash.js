{"version":3,"sources":["../../../../../../src/streaming/protection/models/ProtectionModel_01b.js"],"names":["ProtectionKeyController","NeedKey","DashJSError","KeyMessage","KeySystemConfiguration","KeySystemAccess","ProtectionErrors","ProtectionModel_01b","config","context","eventBus","events","debug","api","errHandler","instance","logger","videoElement","keySystem","protectionKeyController","pendingSessions","sessions","moreSessionsAllowed","eventHandler","setup","getLogger","getInstance","createEventHandler","reset","removeEventListeners","i","length","closeKeySession","trigger","TEARDOWN_COMPLETE","getKeySystem","getAllInitData","retVal","push","initData","requestKeySystemAccess","ksConfigurations","ve","document","createElement","found","ksIdx","systemString","ks","configs","supportedAudio","supportedVideo","configIdx","videos","videoCapabilities","videoIdx","canPlayType","contentType","ksConfig","getKeySystemBySystemString","KEY_SYSTEM_ACCESS_COMPLETE","data","error","selectKeySystem","keySystemAccess","INTERNAL_KEY_SYSTEM_SELECTED","setMediaElement","mediaElement","addEventListener","keyerror","needkey","keymessage","keyadded","VIDEO_ELEMENT_SELECTED","createKeySession","Error","newSession","sessionID","getSessionID","getExpirationTime","NaN","getSessionType","generateKeyRequest","Uint8Array","updateKeySession","sessionToken","message","isClearKey","addKey","keyPairs","key","keyID","cancelKeyRequest","KEY_SESSION_CLOSED","setServerCertificate","loadKeySession","removeKeySession","handleEvent","event","type","ArrayBuffer","isView","buffer","NEED_KEY","findSessionByID","sessionId","code","MEDIA_KEYERR_CODE","msg","errorCode","MEDIA_KEYERR_UNKNOWN_CODE","MEDIA_KEYERR_UNKNOWN_MESSAGE","MEDIA_KEYERR_CLIENT_CODE","MEDIA_KEYERR_CLIENT_MESSAGE","MEDIA_KEYERR_SERVICE_CODE","MEDIA_KEYERR_SERVICE_MESSAGE","MEDIA_KEYERR_OUTPUT_CODE","MEDIA_KEYERR_OUTPUT_MESSAGE","MEDIA_KEYERR_HARDWARECHANGE_CODE","MEDIA_KEYERR_HARDWARECHANGE_MESSAGE","MEDIA_KEYERR_DOMAIN_CODE","MEDIA_KEYERR_DOMAIN_MESSAGE","systemCode","KEY_ERROR","KEY_ADDED","undefined","shift","KEY_SESSION_CREATED","mediaKeyMessageError","MEDIA_KEY_MESSAGE_ERROR_MESSAGE","MEDIA_KEY_MESSAGE_ERROR_CODE","keyMessage","INTERNAL_KEY_MESSAGE","defaultURL","warn","sessionArray","len","removeEventListener","stop","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"ProtectionModel_01b.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Initial implementation of EME\n *\n * Implemented by Google Chrome prior to v36\n *\n * @implements ProtectionModel\n * @class\n */\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\nimport NeedKey from '../vo/NeedKey';\nimport DashJSError from '../../vo/DashJSError';\nimport KeyMessage from '../vo/KeyMessage';\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\nimport KeySystemAccess from '../vo/KeySystemAccess';\nimport ProtectionErrors from '../errors/ProtectionErrors';\n\nfunction ProtectionModel_01b(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\n    const events = config.events;\n    const debug = config.debug;\n    const api = config.api;\n    const errHandler = config.errHandler;\n\n    let instance,\n        logger,\n        videoElement,\n        keySystem,\n        protectionKeyController,\n\n        // With this version of the EME APIs, sessionIDs are not assigned to\n        // sessions until the first key message is received.  We are assuming\n        // that in the case of multiple sessions, key messages will be received\n        // in the order that generateKeyRequest() is called.\n        // Holding spot for newly-created sessions until we determine whether or\n        // not the CDM supports sessionIDs\n        pendingSessions,\n\n        // List of sessions that have been initialized.  Only the first position will\n        // be used in the case that the CDM does not support sessionIDs\n        sessions,\n\n        // Not all CDMs support the notion of sessionIDs.  Without sessionIDs\n        // there is no way for us to differentiate between sessions, therefore\n        // we must only allow a single session.  Once we receive the first key\n        // message we can set this flag to determine if more sessions are allowed\n        moreSessionsAllowed,\n\n        // This is our main event handler for all desired HTMLMediaElement events\n        // related to EME.  These events are translated into our API-independent\n        // versions of the same events\n        eventHandler;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        videoElement = null;\n        keySystem = null;\n        pendingSessions = [];\n        sessions = [];\n        protectionKeyController = ProtectionKeyController(context).getInstance();\n        eventHandler = createEventHandler();\n    }\n\n    function reset() {\n        if (videoElement) {\n            removeEventListeners();\n        }\n        for (let i = 0; i < sessions.length; i++) {\n            closeKeySession(sessions[i]);\n        }\n        eventBus.trigger(events.TEARDOWN_COMPLETE);\n    }\n\n    function getKeySystem() {\n        return keySystem;\n    }\n\n    function getAllInitData() {\n        const retVal = [];\n        for (let i = 0; i < pendingSessions.length; i++) {\n            retVal.push(pendingSessions[i].initData);\n        }\n        for (let i = 0; i < sessions.length; i++) {\n            retVal.push(sessions[i].initData);\n        }\n        return retVal;\n    }\n\n    function requestKeySystemAccess(ksConfigurations) {\n        let ve = videoElement;\n        if (!ve) { // Must have a video element to do this capability tests\n            ve = document.createElement('video');\n        }\n\n        // Try key systems in order, first one with supported key system configuration\n        // is used\n        let found = false;\n        for (let ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n            const systemString = ksConfigurations[ksIdx].ks.systemString;\n            const configs = ksConfigurations[ksIdx].configs;\n            let supportedAudio = null;\n            let supportedVideo = null;\n\n            // Try key system configs in order, first one with supported audio/video\n            // is used\n            for (let configIdx = 0; configIdx < configs.length; configIdx++) {\n                //let audios = configs[configIdx].audioCapabilities;\n                const videos = configs[configIdx].videoCapabilities;\n                // Look for supported video container/codecs\n                if (videos && videos.length !== 0) {\n                    supportedVideo = []; // Indicates that we have a requested video config\n                    for (let videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n                        if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') {\n                            supportedVideo.push(videos[videoIdx]);\n                        }\n                    }\n                }\n\n                // No supported audio or video in this configuration OR we have\n                // requested audio or video configuration that is not supported\n                if ((!supportedAudio && !supportedVideo) ||\n                    (supportedAudio && supportedAudio.length === 0) ||\n                    (supportedVideo && supportedVideo.length === 0)) {\n                    continue;\n                }\n\n                // This configuration is supported\n                found = true;\n                const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo);\n                const ks = protectionKeyController.getKeySystemBySystemString(systemString);\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) });\n                break;\n            }\n        }\n        if (!found) {\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {error: 'Key system access denied! -- No valid audio/video content configurations detected!'});\n        }\n    }\n\n    function selectKeySystem(keySystemAccess) {\n        keySystem = keySystemAccess.keySystem;\n        eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\n    }\n\n    function setMediaElement(mediaElement) {\n        if (videoElement === mediaElement) {\n            return;\n        }\n\n        // Replacing the previous element\n        if (videoElement) {\n            removeEventListeners();\n\n            // Close any open sessions - avoids memory leak on LG webOS 2016/2017 TVs\n            for (var i = 0; i < sessions.length; i++) {\n                closeKeySession(sessions[i]);\n            }\n            sessions = [];\n        }\n\n        videoElement = mediaElement;\n\n        // Only if we are not detaching from the existing element\n        if (videoElement) {\n            videoElement.addEventListener(api.keyerror, eventHandler);\n            videoElement.addEventListener(api.needkey, eventHandler);\n            videoElement.addEventListener(api.keymessage, eventHandler);\n            videoElement.addEventListener(api.keyadded, eventHandler);\n            eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\n        }\n    }\n\n    function createKeySession(initData /*, protData, keySystemType */) {\n        if (!keySystem) {\n            throw new Error('Can not create sessions until you have selected a key system');\n        }\n\n        // Determine if creating a new session is allowed\n        if (moreSessionsAllowed || sessions.length === 0) {\n            const newSession = { // Implements SessionToken\n                sessionID: null,\n                initData: initData,\n                getSessionID: function () {\n                    return this.sessionID;\n                },\n\n                getExpirationTime: function () {\n                    return NaN;\n                },\n\n                getSessionType: function () {\n                    return 'temporary';\n                }\n            };\n            pendingSessions.push(newSession);\n\n            // Send our request to the CDM\n            videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData));\n\n            return newSession;\n\n        } else {\n            throw new Error('Multiple sessions not allowed!');\n        }\n\n    }\n\n    function updateKeySession(sessionToken, message) {\n        const sessionID = sessionToken.sessionID;\n        if (!protectionKeyController.isClearKey(keySystem)) {\n            // Send our request to the CDM\n            videoElement[api.addKey](keySystem.systemString,\n                new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID);\n        } else {\n            // For clearkey, message is a ClearKeyKeySet\n            for (let i = 0; i < message.keyPairs.length; i++) {\n                videoElement[api.addKey](keySystem.systemString,\n                    message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);\n            }\n        }\n    }\n\n    function closeKeySession(sessionToken) {\n        // Send our request to the CDM\n        try {\n            videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID);\n        } catch (error) {\n            eventBus.trigger(events.KEY_SESSION_CLOSED, {data: null, error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message});\n        }\n    }\n\n    function setServerCertificate(/*serverCertificate*/) { /* Not supported */ }\n    function loadKeySession(/*sessionID*/) { /* Not supported */ }\n    function removeKeySession(/*sessionToken*/) { /* Not supported */ }\n\n    function createEventHandler() {\n        return {\n            handleEvent: function (event) {\n                let sessionToken = null;\n                switch (event.type) {\n                    case api.needkey:\n                        let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                        eventBus.trigger(events.NEED_KEY, {key: new NeedKey(initData, 'cenc')});\n                        break;\n\n                    case api.keyerror:\n                        sessionToken = findSessionByID(sessions, event.sessionId);\n                        if (!sessionToken) {\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                        }\n\n                        if (sessionToken) {\n                            let code = ProtectionErrors.MEDIA_KEYERR_CODE;\n                            let msg = '';\n                            switch (event.errorCode.code) {\n                                case 1:\n                                    code = ProtectionErrors.MEDIA_KEYERR_UNKNOWN_CODE;\n                                    msg += 'MEDIA_KEYERR_UNKNOWN - ' + ProtectionErrors.MEDIA_KEYERR_UNKNOWN_MESSAGE;\n                                    break;\n                                case 2:\n                                    code = ProtectionErrors.MEDIA_KEYERR_CLIENT_CODE;\n                                    msg += 'MEDIA_KEYERR_CLIENT - ' + ProtectionErrors.MEDIA_KEYERR_CLIENT_MESSAGE;\n                                    break;\n                                case 3:\n                                    code = ProtectionErrors.MEDIA_KEYERR_SERVICE_CODE;\n                                    msg += 'MEDIA_KEYERR_SERVICE - ' + ProtectionErrors.MEDIA_KEYERR_SERVICE_MESSAGE;\n                                    break;\n                                case 4:\n                                    code = ProtectionErrors.MEDIA_KEYERR_OUTPUT_CODE;\n                                    msg += 'MEDIA_KEYERR_OUTPUT - ' + ProtectionErrors.MEDIA_KEYERR_OUTPUT_MESSAGE;\n                                    break;\n                                case 5:\n                                    code = ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_CODE;\n                                    msg += 'MEDIA_KEYERR_HARDWARECHANGE - ' + ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;\n                                    break;\n                                case 6:\n                                    code = ProtectionErrors.MEDIA_KEYERR_DOMAIN_CODE;\n                                    msg += 'MEDIA_KEYERR_DOMAIN - ' + ProtectionErrors.MEDIA_KEYERR_DOMAIN_MESSAGE;\n                                    break;\n                            }\n                            msg += '  System Code = ' + event.systemCode;\n                            // TODO: Build error string based on key error\n                            eventBus.trigger(events.KEY_ERROR, {data: new DashJSError(code, msg, sessionToken)});\n                        } else {\n                            logger.error('No session token found for key error');\n                        }\n                        break;\n\n                    case api.keyadded:\n                        sessionToken = findSessionByID(sessions, event.sessionId);\n                        if (!sessionToken) {\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                        }\n\n                        if (sessionToken) {\n                            logger.debug('DRM: Key added.');\n                            eventBus.trigger(events.KEY_ADDED, {data: sessionToken});//TODO not sure anything is using sessionToken? why there?\n                        } else {\n                            logger.debug('No session token found for key added');\n                        }\n                        break;\n\n                    case api.keymessage:\n                        // If this CDM does not support session IDs, we will be limited\n                        // to a single session\n                        moreSessionsAllowed = (event.sessionId !== null) && (event.sessionId !== undefined);\n\n                        // SessionIDs supported\n                        if (moreSessionsAllowed) {\n                            // Attempt to find an uninitialized token with this sessionID\n                            sessionToken = findSessionByID(sessions, event.sessionId);\n                            if (!sessionToken && pendingSessions.length > 0) {\n\n                                // This is the first message for our latest session, so set the\n                                // sessionID and add it to our list\n                                sessionToken = pendingSessions.shift();\n                                sessions.push(sessionToken);\n                                sessionToken.sessionID = event.sessionId;\n\n                                eventBus.trigger(events.KEY_SESSION_CREATED, {data: sessionToken});\n                            }\n                        } else if (pendingSessions.length > 0) { // SessionIDs not supported\n                            sessionToken = pendingSessions.shift();\n                            sessions.push(sessionToken);\n\n                            if (pendingSessions.length !== 0) {\n                                errHandler.mediaKeyMessageError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE);\n                                errHandler.error(new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE));\n                            }\n                        }\n\n                        if (sessionToken) {\n                            let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n\n                            // For ClearKey, the spec mandates that you pass this message to the\n                            // addKey method, so we always save it to the token since there is no\n                            // way to tell which key system is in use\n                            sessionToken.keyMessage = message;\n                            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {data: new KeyMessage(sessionToken, message, event.defaultURL)});\n\n                        } else {\n                            logger.warn('No session token found for key message');\n                        }\n                        break;\n                }\n            }\n        };\n    }\n\n\n    /**\n     * Helper function to retrieve the stored session token based on a given\n     * sessionID value\n     *\n     * @param {Array} sessionArray - the array of sessions to search\n     * @param {*} sessionID - the sessionID to search for\n     * @returns {*} the session token with the given sessionID\n     */\n    function findSessionByID(sessionArray, sessionID) {\n        if (!sessionID || !sessionArray) {\n            return null;\n        } else {\n            const len = sessionArray.length;\n            for (let i = 0; i < len; i++) {\n                if (sessionArray[i].sessionID == sessionID) {\n                    return sessionArray[i];\n                }\n            }\n            return null;\n        }\n    }\n\n    function removeEventListeners() {\n        videoElement.removeEventListener(api.keyerror, eventHandler);\n        videoElement.removeEventListener(api.needkey, eventHandler);\n        videoElement.removeEventListener(api.keymessage, eventHandler);\n        videoElement.removeEventListener(api.keyadded, eventHandler);\n    }\n\n    instance = {\n        getAllInitData: getAllInitData,\n        requestKeySystemAccess: requestKeySystemAccess,\n        getKeySystem: getKeySystem,\n        selectKeySystem: selectKeySystem,\n        setMediaElement: setMediaElement,\n        createKeySession: createKeySession,\n        updateKeySession: updateKeySession,\n        closeKeySession: closeKeySession,\n        setServerCertificate: setServerCertificate,\n        loadKeySession: loadKeySession,\n        removeKeySession: removeKeySession,\n        stop: reset,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b';\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b); /* jshint ignore:line */\n"]}