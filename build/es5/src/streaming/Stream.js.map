{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["Constants","StreamProcessor","EventController","FragmentController","ThumbnailController","EventBus","Events","Debug","Errors","FactoryMaker","DashJSError","Stream","config","context","eventBus","getInstance","manifestModel","dashManifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","errHandler","timelineConverter","metricsModel","abrController","playbackController","mediaController","textController","videoModel","instance","logger","streamProcessors","isStreamActivated","isMediaInitialized","streamInfo","updateError","isUpdating","protectionController","fragmentController","thumbnailController","eventController","preloaded","trackChangedEvent","codecCompatibilityTable","setup","getLogger","resetInitialSettings","create","registerEvents","on","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","unRegisterEvents","off","registerProtectionEvents","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","initialize","StreamInfo","ProtectionController","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","manifestError","getValue","error","MANIFEST_ERROR_ID_NOSTREAMS_CODE","fatal","pause","duration","NaN","start","getId","id","getStreamInfo","getFragmentController","getThumbnailController","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","startEventController","stopEventController","stop","event","mediaKeySessionError","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","debug","contentProtection","supportsEncryptedMedia","capabilityError","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","manifest","setCurrentMediaInfo","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setIndexHandlerTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","streamProcessor","mimeType","dashMetrics","baseURLController","stream","domStorage","streamController","setBuffer","buffer","getIndexHandler","setCurrentTime","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","addEmbeddedTrack","addTrack","getTracksFor","getTextDefaultEnabled","checkInitialMediaSettingsForType","getCurrentTrackFor","initializeEventController","setConfig","addInlineEvents","events","getEventsFor","addInbandEvents","element","getElement","filterCodecs","VIDEO","AUDIO","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","realAdaptation","getAdaptationForType","Array","isArray","Representation_asArray","filter","_","getCodec","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","getType","initializeForMedia","trigger","STREAM_INITIALIZED","createBuffer","getBuffer","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","sp","sender","getStreamProcessor","arr","updateData","updatedStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","compareCodecs","isProtectionCompatible","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","currentAdaptation","ContentProtection","sameMimeType","oldCodecs","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","codec1","codec2","codecRoot","split","rootCompatible","compatTableCodec","compatibleCodecs","compatibleCodec","value","preload","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"Stream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport StreamProcessor from './StreamProcessor';\nimport EventController from './controllers/EventController';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashJSError from './vo/DashJSError';\n\nfunction Stream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const dashManifestModel = config.dashManifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const metricsModel = config.metricsModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const videoModel = config.videoModel;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamActivated,\n        isMediaInitialized,\n        streamInfo,\n        updateError,\n        isUpdating,\n        protectionController,\n        fragmentController,\n        thumbnailController,\n        eventController,\n        preloaded,\n        trackChangedEvent;\n\n    const codecCompatibilityTable = [\n        {\n            'codec': 'avc1',\n            'compatibleCodecs': ['avc3']\n        },\n        {\n            'codec': 'avc3',\n            'compatibleCodecs': ['avc1']\n        }\n    ];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        fragmentController = FragmentController(context).create({\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            errHandler: errHandler\n        });\n\n        registerEvents();\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    }\n\n    function unRegisterEvents() {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    }\n\n    function registerProtectionEvents() {\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function unRegisterProtectionEvents() {\n        if (protectionController) {\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function initialize(StreamInfo, ProtectionController) {\n        streamInfo = StreamInfo;\n        protectionController = ProtectionController;\n        registerProtectionEvents();\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i,1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg +  'nostreams', manifestModel.getValue()));\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        streamInfo = null;\n        updateError = {};\n        isUpdating = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        resetInitialSettings();\n\n        unRegisterEvents();\n\n        unRegisterProtectionEvents();\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getFragmentController() {\n        return fragmentController;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function startEventController() {\n        if (eventController) {\n            eventController.start();\n        }\n    }\n\n    function stopEventController() {\n        if (eventController) {\n            eventController.stop();\n        }\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.mediaKeySessionError(event.error.message);\n            errHandler.error(event.error);\n            logger.fatal(event.error.message);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo.type;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED && mediaInfo) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.manifestError(msg, 'multiplexedrep', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.capabilityError('encryptedmedia');\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n\n        let processor = getProcessorForMediaInfo(e.newMediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) {\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(NaN);\n                adapter.setIndexHandlerTime(processor, currentTime);\n                adapter.resetIndexHandler(processor);\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n        let streamProcessor = StreamProcessor(context).create({\n            type: mediaInfo.type,\n            mimeType: mediaInfo.mimeType,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            dashManifestModel: dashManifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            stream: instance,\n            abrController: abrController,\n            domStorage: config.domStorage,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            streamController: config.streamController,\n            textController: textController,\n            errHandler: errHandler\n        });\n\n        streamProcessor.initialize(mediaSource);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.getIndexHandler().setCurrentTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if ((mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                dashManifestModel: dashManifestModel,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                stream: instance,\n                timelineConverter: config.timelineConverter\n            });\n            return;\n        }\n\n        if (type !== Constants.FRAGMENTED_TEXT || (type === Constants.FRAGMENTED_TEXT && textController.getTextDefaultEnabled())) {\n            mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n            initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n        }\n\n        if (type === Constants.FRAGMENTED_TEXT && !textController.getTextDefaultEnabled()) {\n            initialMediaInfo = mediaController.getTracksFor(type, streamInfo)[0];\n        }\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function initializeEventController () {\n        //if initializeMedia is called from a switch period, eventController could have been already created.\n        if (!eventController) {\n            eventController = EventController(context).create();\n\n            eventController.setConfig({\n                manifestUpdater: manifestUpdater,\n                playbackController: playbackController\n            });\n            addInlineEvents();\n        }\n    }\n\n    function addInlineEvents () {\n        const events = adapter.getEventsFor(streamInfo);\n        eventController.addInlineEvents(events);\n    }\n\n    function addInbandEvents (events) {\n        if (eventController) {\n            eventController.addInbandEvents(events);\n        }\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let element = videoModel.getElement();\n\n        initializeEventController();\n\n        isUpdating = true;\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        if (element === null || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function filterCodecs(type) {\n        const realAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), streamInfo.index, type, streamInfo);\n\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return;\n\n        // Filter codecs that are not supported\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\n            // keep at least codec from lowest representation\n            if (i === 0) return true;\n\n            const codec = dashManifestModel.getCodec(realAdaptation, i, true);\n            if (!capabilities.supportsCodec(codec)) {\n                logger.error('[Stream] codec not supported: ' + codec);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\n                    streamProcessors[i].getType() === Constants.VIDEO ||\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\n                }\n            }\n        }\n\n        eventBus.trigger(Events.STREAM_INITIALIZED, {\n            streamInfo: streamInfo,\n            error: error\n        });\n    }\n\n    function getMediaInfo(type) {\n        const ln = streamProcessors.length;\n        let streamProcessor = null;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            buffers[streamProcessors[i].getType()] = streamProcessors[i].createBuffer(previousBuffers).getBuffer();\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted(e) {\n        if (e.streamInfo !== streamInfo) {\n            return;\n        }\n\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\n            streamInfo: streamInfo\n        });\n    }\n\n    function onDataUpdateCompleted(e) {\n        let sp = e.sender.getStreamProcessor();\n\n        if (sp.getStreamInfo() !== streamInfo) {\n            return;\n        }\n\n        updateError[sp.getType()] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return null;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        const ln = streamProcessors.length;\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        if (eventController) {\n            addInlineEvents();\n        }\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            abrController.updateTopQualityIndex(mediaInfo);\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== 'fragmentedText') {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isMediaCodecCompatible(stream) {\n        return compareCodecs(stream, Constants.VIDEO) && compareCodecs(stream, Constants.AUDIO);\n    }\n\n    function isProtectionCompatible(stream) {\n        return compareProtectionConfig(stream, Constants.VIDEO) && compareProtectionConfig(stream, Constants.AUDIO);\n    }\n\n    function compareProtectionConfig(stream, type) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        // If any of the periods requires EME, we can't do smooth transition\n        if (newAdaptation.ContentProtection || currentAdaptation.ContentProtection) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function compareCodecs(stream, type) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType =  newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\n    function codecRootCompatibleWithCodec(codec1, codec2) {\n        const codecRoot = codec1.split('.')[0];\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\n        let compatTableCodec;\n        for (let i = 0; i < codecCompatibilityTable.length; i++) {\n            if (codecCompatibilityTable[i].codec === codecRoot) {\n                compatTableCodec = codecCompatibilityTable[i];\n                break;\n            }\n        }\n        if (compatTableCodec) {\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\n        }\n        return rootCompatible;\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        initializeEventController();\n\n        initializeMediaForType(Constants.VIDEO, mediaSource);\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        createBuffers(previousBuffers);\n\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n        for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n\n        setPreloaded(true);\n    }\n\n    instance = {\n        initialize: initialize,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        preload: preload,\n        getFragmentController: getFragmentController,\n        getThumbnailController: getThumbnailController,\n        getBitrateListFor: getBitrateListFor,\n        startEventController: startEventController,\n        stopEventController: stopEventController,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isMediaCodecCompatible: isMediaCodecCompatible,\n        isProtectionCompatible: isProtectionCompatible,\n        getPreloaded: getPreloaded,\n        addInbandEvents: addInbandEvents\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]}