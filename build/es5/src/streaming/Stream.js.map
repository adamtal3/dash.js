{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["Constants","StreamProcessor","EventController","FragmentController","ThumbnailController","EventBus","Events","Debug","Errors","FactoryMaker","DashJSError","Stream","config","context","eventBus","getInstance","manifestModel","dashManifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","errHandler","timelineConverter","metricsModel","abrController","playbackController","mediaController","textController","videoModel","instance","logger","streamProcessors","isStreamActivated","isMediaInitialized","streamInfo","updateError","isUpdating","protectionController","fragmentController","thumbnailController","eventController","preloaded","trackChangedEvent","codecCompatibilityTable","setup","getLogger","resetInitialSettings","create","registerEvents","on","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","unRegisterEvents","off","registerProtectionEvents","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","initialize","StreamInfo","ProtectionController","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","manifestError","getValue","error","MANIFEST_ERROR_ID_NOSTREAMS_CODE","fatal","pause","duration","NaN","start","getId","id","getStreamInfo","getFragmentController","getThumbnailController","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","startEventController","stopEventController","stop","event","mediaKeySessionError","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","debug","contentProtection","supportsEncryptedMedia","capabilityError","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","manifest","setCurrentMediaInfo","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setIndexHandlerTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","streamProcessor","mimeType","dashMetrics","baseURLController","stream","domStorage","streamController","setBuffer","buffer","getIndexHandler","setCurrentTime","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","addEmbeddedTrack","addTrack","getTracksFor","getTextDefaultEnabled","checkInitialMediaSettingsForType","getCurrentTrackFor","initializeEventController","setConfig","addInlineEvents","events","getEventsFor","addInbandEvents","element","getElement","filterCodecs","VIDEO","AUDIO","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","realAdaptation","getAdaptationForType","Array","isArray","Representation_asArray","filter","_","getCodec","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","getType","initializeForMedia","trigger","STREAM_INITIALIZED","createBuffer","getBuffer","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","sp","sender","getStreamProcessor","arr","updateData","updatedStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","compareCodecs","isProtectionCompatible","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","currentAdaptation","ContentProtection","sameMimeType","oldCodecs","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","codec1","codec2","codecRoot","split","rootCompatible","compatTableCodec","compatibleCodecs","compatibleCodec","value","preload","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"Stream.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from './constants/Constants';\nimport StreamProcessor from './StreamProcessor';\nimport EventController from './controllers/EventController';\nimport FragmentController from './controllers/FragmentController';\nimport ThumbnailController from './thumbnail/ThumbnailController';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport Debug from '../core/Debug';\nimport Errors from '../core/errors/Errors';\nimport FactoryMaker from '../core/FactoryMaker';\nimport DashJSError from './vo/DashJSError';\n\nfunction Stream(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    const manifestModel = config.manifestModel;\n    const dashManifestModel = config.dashManifestModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const manifestUpdater = config.manifestUpdater;\n    const adapter = config.adapter;\n    const capabilities = config.capabilities;\n    const errHandler = config.errHandler;\n    const timelineConverter = config.timelineConverter;\n    const metricsModel = config.metricsModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const mediaController = config.mediaController;\n    const textController = config.textController;\n    const videoModel = config.videoModel;\n\n    let instance,\n        logger,\n        streamProcessors,\n        isStreamActivated,\n        isMediaInitialized,\n        streamInfo,\n        updateError,\n        isUpdating,\n        protectionController,\n        fragmentController,\n        thumbnailController,\n        eventController,\n        preloaded,\n        trackChangedEvent;\n\n    const codecCompatibilityTable = [\n        {\n            'codec': 'avc1',\n            'compatibleCodecs': ['avc3']\n        },\n        {\n            'codec': 'avc3',\n            'compatibleCodecs': ['avc1']\n        }\n    ];\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n\n        fragmentController = FragmentController(context).create({\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            errHandler: errHandler\n        });\n\n        registerEvents();\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n    }\n\n    function unRegisterEvents() {\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\n    }\n\n    function registerProtectionEvents() {\n        if (protectionController) {\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function unRegisterProtectionEvents() {\n        if (protectionController) {\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\n        }\n    }\n\n    function initialize(StreamInfo, ProtectionController) {\n        streamInfo = StreamInfo;\n        protectionController = ProtectionController;\n        registerProtectionEvents();\n    }\n\n    /**\n     * Activates Stream by re-initializing some of its components\n     * @param {MediaSource} mediaSource\n     * @memberof Stream#\n     * @param {SourceBuffer} previousBuffers\n     */\n    function activate(mediaSource, previousBuffers) {\n        if (!isStreamActivated) {\n            let result;\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n            if (!getPreloaded()) {\n                result = initializeMedia(mediaSource, previousBuffers);\n            } else {\n                initializeAfterPreload();\n                result = previousBuffers;\n            }\n            isStreamActivated = true;\n            return result;\n        }\n        return previousBuffers;\n    }\n\n    /**\n     * Partially resets some of the Stream elements\n     * @memberof Stream#\n     * @param {boolean} keepBuffers\n     */\n    function deactivate(keepBuffers) {\n        let ln = streamProcessors ? streamProcessors.length : 0;\n        const errored = false;\n        for (let i = 0; i < ln; i++) {\n            let fragmentModel = streamProcessors[i].getFragmentModel();\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\n            streamProcessors[i].reset(errored, keepBuffers);\n        }\n        streamProcessors = [];\n        isStreamActivated = false;\n        isMediaInitialized = false;\n        setPreloaded(false);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n    }\n\n    function isActive() {\n        return isStreamActivated;\n    }\n\n    function setMediaSource(mediaSource) {\n        for (let i = 0; i < streamProcessors.length;) {\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\n                streamProcessors[i].setMediaSource(mediaSource);\n                i++;\n            } else {\n                streamProcessors[i].reset();\n                streamProcessors.splice(i,1);\n            }\n        }\n\n        for (let i = 0; i < streamProcessors.length; i++) {\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\n            //so do this after the buffers are created above.\n            streamProcessors[i].dischargePreBuffer();\n        }\n\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg +  'nostreams', manifestModel.getValue()));\n            logger.fatal(msg);\n        }\n    }\n\n    function resetInitialSettings() {\n        deactivate();\n        streamInfo = null;\n        updateError = {};\n        isUpdating = false;\n    }\n\n    function reset() {\n\n        if (playbackController) {\n            playbackController.pause();\n        }\n\n        if (fragmentController) {\n            fragmentController.reset();\n            fragmentController = null;\n        }\n\n        resetInitialSettings();\n\n        unRegisterEvents();\n\n        unRegisterProtectionEvents();\n\n        setPreloaded(false);\n    }\n\n    function getDuration() {\n        return streamInfo ? streamInfo.duration : NaN;\n    }\n\n    function getStartTime() {\n        return streamInfo ? streamInfo.start : NaN;\n    }\n\n    function getId() {\n        return streamInfo ? streamInfo.id : null;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function getFragmentController() {\n        return fragmentController;\n    }\n\n    function getThumbnailController() {\n        return thumbnailController;\n    }\n\n    function checkConfig() {\n        if (!abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @returns {Array}\n     * @memberof Stream#\n     */\n    function getBitrateListFor(type) {\n        checkConfig();\n        if (type === Constants.IMAGE) {\n            if (!thumbnailController) {\n                return [];\n            }\n            return thumbnailController.getBitrateList();\n        }\n        const mediaInfo = getMediaInfo(type);\n        return abrController.getBitrateList(mediaInfo);\n    }\n\n    function startEventController() {\n        if (eventController) {\n            eventController.start();\n        }\n    }\n\n    function stopEventController() {\n        if (eventController) {\n            eventController.stop();\n        }\n    }\n\n    function onProtectionError(event) {\n        if (event.error) {\n            errHandler.mediaKeySessionError(event.error.message);\n            errHandler.error(event.error);\n            logger.fatal(event.error.message);\n            reset();\n        }\n    }\n\n    function isMediaSupported(mediaInfo) {\n        const type = mediaInfo.type;\n        let codec,\n            msg;\n\n        if (type === Constants.MUXED && mediaInfo) {\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\n            logger.fatal(msg);\n            errHandler.manifestError(msg, 'multiplexedrep', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\n            return false;\n        }\n\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\n            return true;\n        }\n        codec = mediaInfo.codec;\n        logger.debug(type + ' codec: ' + codec);\n\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\n            errHandler.capabilityError('encryptedmedia');\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\n        } else if (!capabilities.supportsCodec(codec)) {\n            msg = type + 'Codec (' + codec + ') is not supported.';\n            logger.error(msg);\n            return false;\n        }\n\n        return true;\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\n\n        let processor = getProcessorForMediaInfo(e.newMediaInfo);\n        if (!processor) return;\n\n        let currentTime = playbackController.getTime();\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\n        let mediaInfo = e.newMediaInfo;\n        let manifest = manifestModel.getValue();\n\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\n\n        logger.debug('Stream -  Update stream controller');\n        if (manifest.refreshManifestOnSwitchTrack) {\n            logger.debug('Stream -  Refreshing manifest for switch track');\n            trackChangedEvent = e;\n            manifestUpdater.refreshManifest();\n        } else {\n            processor.selectMediaInfo(mediaInfo);\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\n                abrController.updateTopQualityIndex(mediaInfo);\n                processor.switchTrackAsked();\n                processor.getFragmentModel().abortRequests();\n            } else {\n                processor.getScheduleController().setSeekTarget(NaN);\n                adapter.setIndexHandlerTime(processor, currentTime);\n                adapter.resetIndexHandler(processor);\n            }\n        }\n    }\n\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\n        let streamProcessor = StreamProcessor(context).create({\n            type: mediaInfo.type,\n            mimeType: mediaInfo.mimeType,\n            timelineConverter: timelineConverter,\n            adapter: adapter,\n            manifestModel: manifestModel,\n            dashManifestModel: dashManifestModel,\n            mediaPlayerModel: mediaPlayerModel,\n            metricsModel: metricsModel,\n            dashMetrics: config.dashMetrics,\n            baseURLController: config.baseURLController,\n            stream: instance,\n            abrController: abrController,\n            domStorage: config.domStorage,\n            playbackController: playbackController,\n            mediaController: mediaController,\n            streamController: config.streamController,\n            textController: textController,\n            errHandler: errHandler\n        });\n\n        streamProcessor.initialize(mediaSource);\n        abrController.updateTopQualityIndex(mediaInfo);\n\n        if (optionalSettings) {\n            streamProcessor.setBuffer(optionalSettings.buffer);\n            streamProcessor.getIndexHandler().setCurrentTime(optionalSettings.currentTime);\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\n        } else {\n            streamProcessors.push(streamProcessor);\n        }\n\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\n            return;\n        }\n\n        if ((mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\n            let idx;\n            for (let i = 0; i < allMediaForType.length; i++) {\n                if (allMediaForType[i].index === mediaInfo.index) {\n                    idx = i;\n                }\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\n            }\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\n        } else {\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n    }\n\n    function initializeMediaForType(type, mediaSource) {\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\n\n        let mediaInfo = null;\n        let initialMediaInfo;\n\n        if (!allMediaForType || allMediaForType.length === 0) {\n            logger.info('No ' + type + ' data.');\n            return;\n        }\n\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\n            mediaInfo = allMediaForType[i];\n\n            if (type === Constants.EMBEDDED_TEXT) {\n                textController.addEmbeddedTrack(mediaInfo);\n            } else {\n                if (!isMediaSupported(mediaInfo)) continue;\n                mediaController.addTrack(mediaInfo);\n            }\n        }\n\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\n            return;\n        }\n\n        if (type === Constants.IMAGE) {\n            thumbnailController = ThumbnailController(context).create({\n                dashManifestModel: dashManifestModel,\n                adapter: adapter,\n                baseURLController: config.baseURLController,\n                stream: instance,\n                timelineConverter: config.timelineConverter\n            });\n            return;\n        }\n\n        if (type !== Constants.FRAGMENTED_TEXT || (type === Constants.FRAGMENTED_TEXT && textController.getTextDefaultEnabled())) {\n            mediaController.checkInitialMediaSettingsForType(type, streamInfo);\n            initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\n        }\n\n        if (type === Constants.FRAGMENTED_TEXT && !textController.getTextDefaultEnabled()) {\n            initialMediaInfo = mediaController.getTracksFor(type, streamInfo)[0];\n        }\n\n        // TODO : How to tell index handler live/duration?\n        // TODO : Pass to controller and then pass to each method on handler?\n\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\n    }\n\n    function initializeEventController () {\n        //if initializeMedia is called from a switch period, eventController could have been already created.\n        if (!eventController) {\n            eventController = EventController(context).create();\n\n            eventController.setConfig({\n                manifestUpdater: manifestUpdater,\n                playbackController: playbackController\n            });\n            addInlineEvents();\n        }\n    }\n\n    function addInlineEvents () {\n        const events = adapter.getEventsFor(streamInfo);\n        eventController.addInlineEvents(events);\n    }\n\n    function addInbandEvents (events) {\n        if (eventController) {\n            eventController.addInbandEvents(events);\n        }\n    }\n\n    function initializeMedia(mediaSource, previousBuffers) {\n        checkConfig();\n        let element = videoModel.getElement();\n\n        initializeEventController();\n\n        isUpdating = true;\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        if (element === null || (element && (/^VIDEO$/i).test(element.nodeName))) {\n            initializeMediaForType(Constants.VIDEO, mediaSource);\n        }\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\n        const buffers = createBuffers(previousBuffers);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n\n        if (streamProcessors.length === 0) {\n            const msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\n            logger.fatal(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n\n        return buffers;\n    }\n\n    function initializeAfterPreload() {\n        isUpdating = true;\n        checkConfig();\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        isMediaInitialized = true;\n        isUpdating = false;\n        if (streamProcessors.length === 0) {\n            let msg = 'No streams to play.';\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\n            logger.debug(msg);\n        } else {\n            checkIfInitializationCompleted();\n        }\n    }\n\n    function filterCodecs(type) {\n        const realAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), streamInfo.index, type, streamInfo);\n\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return;\n\n        // Filter codecs that are not supported\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\n            // keep at least codec from lowest representation\n            if (i === 0) return true;\n\n            const codec = dashManifestModel.getCodec(realAdaptation, i, true);\n            if (!capabilities.supportsCodec(codec)) {\n                logger.error('[Stream] codec not supported: ' + codec);\n                return false;\n            }\n            return true;\n        });\n    }\n\n    function checkIfInitializationCompleted() {\n        const ln = streamProcessors.length;\n        const hasError = !!updateError.audio || !!updateError.video;\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\n\n        for (let i = 0; i < ln; i++) {\n            if (streamProcessors[i].isUpdating() || isUpdating) {\n                return;\n            }\n        }\n\n        if (!isMediaInitialized) {\n            return;\n        }\n\n        if (protectionController) {\n            // Need to check if streamProcessors exists because streamProcessors\n            // could be cleared in case an error is detected while initializing DRM keysystem\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\n                    streamProcessors[i].getType() === Constants.VIDEO ||\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\n                }\n            }\n        }\n\n        eventBus.trigger(Events.STREAM_INITIALIZED, {\n            streamInfo: streamInfo,\n            error: error\n        });\n    }\n\n    function getMediaInfo(type) {\n        const ln = streamProcessors.length;\n        let streamProcessor = null;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n\n            if (streamProcessor.getType() === type) {\n                return streamProcessor.getMediaInfo();\n            }\n        }\n\n        return null;\n    }\n\n    function createBuffers(previousBuffers) {\n        const buffers = {};\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            buffers[streamProcessors[i].getType()] = streamProcessors[i].createBuffer(previousBuffers).getBuffer();\n        }\n        return buffers;\n    }\n\n    function onBufferingCompleted(e) {\n        if (e.streamInfo !== streamInfo) {\n            return;\n        }\n\n        let processors = getProcessors();\n        const ln = processors.length;\n\n        if (ln === 0) {\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\n            return;\n        }\n\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\n        for (let i = 0; i < ln; i++) {\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\n                return;\n            }\n        }\n\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\n            streamInfo: streamInfo\n        });\n    }\n\n    function onDataUpdateCompleted(e) {\n        let sp = e.sender.getStreamProcessor();\n\n        if (sp.getStreamInfo() !== streamInfo) {\n            return;\n        }\n\n        updateError[sp.getType()] = e.error;\n        checkIfInitializationCompleted();\n    }\n\n    function getProcessorForMediaInfo(mediaInfo) {\n        if (!mediaInfo) {\n            return null;\n        }\n\n        let processors = getProcessors();\n\n        return processors.filter(function (processor) {\n            return (processor.getType() === mediaInfo.type);\n        })[0];\n    }\n\n    function getProcessors() {\n        const ln = streamProcessors.length;\n        let arr = [];\n\n        let type,\n            streamProcessor;\n\n        for (let i = 0; i < ln; i++) {\n            streamProcessor = streamProcessors[i];\n            type = streamProcessor.getType();\n\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\n                arr.push(streamProcessor);\n            }\n        }\n\n        return arr;\n    }\n\n    function updateData(updatedStreamInfo) {\n        logger.info('Manifest updated... updating data system wide.');\n\n        isStreamActivated = false;\n        isUpdating = true;\n        streamInfo = updatedStreamInfo;\n\n        if (eventController) {\n            addInlineEvents();\n        }\n\n        filterCodecs(Constants.VIDEO);\n        filterCodecs(Constants.AUDIO);\n\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\n            let streamProcessor = streamProcessors[i];\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\n            abrController.updateTopQualityIndex(mediaInfo);\n            streamProcessor.addMediaInfo(mediaInfo, true);\n        }\n\n        if (trackChangedEvent) {\n            let mediaInfo = trackChangedEvent.newMediaInfo;\n            if (mediaInfo.type !== 'fragmentedText') {\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\n                if (!processor) return;\n                processor.switchTrackAsked();\n                trackChangedEvent = undefined;\n            }\n        }\n\n        isUpdating = false;\n        checkIfInitializationCompleted();\n    }\n\n    function isMediaCodecCompatible(stream) {\n        return compareCodecs(stream, Constants.VIDEO) && compareCodecs(stream, Constants.AUDIO);\n    }\n\n    function isProtectionCompatible(stream) {\n        return compareProtectionConfig(stream, Constants.VIDEO) && compareProtectionConfig(stream, Constants.AUDIO);\n    }\n\n    function compareProtectionConfig(stream, type) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        // If any of the periods requires EME, we can't do smooth transition\n        if (newAdaptation.ContentProtection || currentAdaptation.ContentProtection) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function compareCodecs(stream, type) {\n        if (!stream) {\n            return false;\n        }\n        const newStreamInfo = stream.getStreamInfo();\n        const currentStreamInfo = getStreamInfo();\n\n        if (!newStreamInfo || !currentStreamInfo) {\n            return false;\n        }\n\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\n\n        if (!newAdaptation || !currentAdaptation) {\n            // If there is no adaptation for neither the old or the new stream they're compatible\n            return !newAdaptation && !currentAdaptation;\n        }\n\n        const sameMimeType =  newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\n            return representation.codecs;\n        });\n\n        const codecMatch = newCodecs.some((newCodec) => {\n            return oldCodecs.indexOf(newCodec) > -1;\n        });\n\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\n        return codecMatch || (partialCodecMatch && sameMimeType);\n    }\n\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\n    function codecRootCompatibleWithCodec(codec1, codec2) {\n        const codecRoot = codec1.split('.')[0];\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\n        let compatTableCodec;\n        for (let i = 0; i < codecCompatibilityTable.length; i++) {\n            if (codecCompatibilityTable[i].codec === codecRoot) {\n                compatTableCodec = codecCompatibilityTable[i];\n                break;\n            }\n        }\n        if (compatTableCodec) {\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\n        }\n        return rootCompatible;\n    }\n\n    function setPreloaded(value) {\n        preloaded = value;\n    }\n\n    function getPreloaded() {\n        return preloaded;\n    }\n\n    function preload(mediaSource, previousBuffers) {\n        initializeEventController();\n\n        initializeMediaForType(Constants.VIDEO, mediaSource);\n        initializeMediaForType(Constants.AUDIO, mediaSource);\n        initializeMediaForType(Constants.TEXT, mediaSource);\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\n        initializeMediaForType(Constants.MUXED, mediaSource);\n        initializeMediaForType(Constants.IMAGE, mediaSource);\n\n        createBuffers(previousBuffers);\n\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\n        for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\n            streamProcessors[i].getScheduleController().start();\n        }\n\n        setPreloaded(true);\n    }\n\n    instance = {\n        initialize: initialize,\n        activate: activate,\n        deactivate: deactivate,\n        isActive: isActive,\n        getDuration: getDuration,\n        getStartTime: getStartTime,\n        getId: getId,\n        getStreamInfo: getStreamInfo,\n        preload: preload,\n        getFragmentController: getFragmentController,\n        getThumbnailController: getThumbnailController,\n        getBitrateListFor: getBitrateListFor,\n        startEventController: startEventController,\n        stopEventController: stopEventController,\n        updateData: updateData,\n        reset: reset,\n        getProcessors: getProcessors,\n        setMediaSource: setMediaSource,\n        isMediaCodecCompatible: isMediaCodecCompatible,\n        isProtectionCompatible: isProtectionCompatible,\n        getPreloaded: getPreloaded,\n        addInbandEvents: addInbandEvents\n    };\n\n    setup();\n    return instance;\n}\n\nStream.__dashjs_factory_name = 'Stream';\nexport default FactoryMaker.getClassFactory(Stream);\n"]}