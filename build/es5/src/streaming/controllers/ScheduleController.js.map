{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["Constants","PlayListTrace","AbrController","BufferController","BufferLevelRule","NextFragmentRequestRule","FragmentModel","EventBus","Events","FactoryMaker","Debug","MediaController","replaceTokenForTemplate","ScheduleController","config","context","eventBus","getInstance","metricsModel","adapter","dashMetrics","dashManifestModel","timelineConverter","mediaPlayerModel","abrController","playbackController","streamController","textController","type","streamProcessor","mediaController","instance","logger","fragmentModel","currentRepresentationInfo","initialRequest","isStopped","playListMetrics","playListTraceMetrics","playListTraceMetricsClosed","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","bufferLevelRule","nextFragmentRequestRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","bufferResetInProgress","mediaRequest","isReplacementRequest","setup","getLogger","resetInitialSettings","initialize","getFragmentModel","create","getIsTextTrack","mimeType","on","TIMED_TEXT_REQUESTED","onTimedTextRequested","QUALITY_CHANGE_REQUESTED","onQualityChanged","DATA_UPDATE_STARTED","onDataUpdateStarted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","STREAM_INITIALIZED","onStreamInitialized","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","INIT_REQUESTED","onInitRequested","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","isStarted","start","isBufferingCompleted","warn","debug","addPlaylistTraceMetrics","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","id","newTopQualityIndex","getTopQualityIndexFor","info","schedule","bufferController","getBufferController","isPaused","getScheduleWhilePaused","FRAGMENTED_TEXT","TEXT","isTextEnabled","getIsBufferingCompleted","validateExecutedFragmentRequest","isReplacement","length","streamInfo","getStreamInfo","isNaN","mediaInfo","execute","isTrackTypePresent","VIDEO","getNextFragment","fragmentController","getFragmentController","quality","getSwitchMode","TRACK_SWITCH_MODE_ALWAYS_REPLACE","switchInitData","replacement","shift","isInitializationRequest","representationId","request","getIsPruningInProgress","setSeekTarget","NaN","startTime","duration","setIndexHandlerTime","delayLoadingTime","Date","getTime","setTimeToLoadDelay","manifestInfo","isDynamic","url","executeRequest","setFragmentProcessState","getLowLatencyEnabled","checkPlaybackQuality","time","safeBufferLevel","fragmentDuration","getRequests","state","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","fastSwitchModeEnabled","getFastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","ABANDON_LOAD","replaceRequest","index","value","setTimeout","e","sender","getStreamProcessor","getInitRequest","bandwidth","switchTrackAsked","push","mediaType","getRepresentationInfo","newQuality","undefined","Error","clearPlayListTraceMetrics","REPRESENTATION_SWITCH_STOP_REASON","completeQualityChange","trigger","item","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","error","convertDataToRepresentationInfo","currentRepresentation","getIsDynamic","setTimeSyncCompleted","setLiveEdgeSeekTarget","getStreamStartTime","setSeekStartTime","liveEdgeFinder","getLiveEdgeFinder","liveEdge","getLiveEdge","dvrWindowSize","DVRWindowSize","computeLiveDelay","getFragmentRequest","ignoreIsFinished","liveStartTime","getLiveDelay","setLiveStartTime","seek","manifestUpdateInfo","getCurrentManifestUpdate","getMetricsFor","STREAM","updateManifestUpdateInfo","currentTime","presentationStartTime","latency","clientTimeOffset","getClientTimeOffset","range","serviceLocation","addExecutedRequest","fragEndTime","isSeeking","unintended","removeExecutedRequestsAfterTime","from","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","hasEnoughSpaceToAppend","BUFFER_EMPTY","REBUFFERING_REASON","abortRequests","seekTime","DVRWindow","end","playbackspeed","playbackRate","toString","getBufferTarget","getType","setPlayList","playList","finalisePlayList","reason","endTime","stopreason","trace","representationid","mstart","getPlaybackRate","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"ScheduleController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport {PlayListTrace} from '../vo/metrics/PlayList';\nimport AbrController from './AbrController';\nimport BufferController from './BufferController';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport NextFragmentRequestRule from '../rules/scheduling/NextFragmentRequestRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport MediaController from './MediaController';\nimport {replaceTokenForTemplate} from '../../dash/utils/SegmentsUtils';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const metricsModel = config.metricsModel;\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const dashManifestModel = config.dashManifestModel;\n    const timelineConverter = config.timelineConverter;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const streamController = config.streamController;\n    const textController = config.textController;\n    const type = config.type;\n    const streamProcessor = config.streamProcessor;\n    const mediaController = config.mediaController;\n\n    let instance,\n        logger,\n        fragmentModel,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        playListMetrics,\n        playListTraceMetrics,\n        playListTraceMetricsClosed,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        bufferLevelRule,\n        nextFragmentRequestRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitQuality,\n        replaceRequestArray,\n        switchTrack,\n        bufferResetInProgress,\n        mediaRequest,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function initialize() {\n        fragmentModel = streamProcessor.getFragmentModel();\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            metricsModel: metricsModel,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController\n        });\n\n        nextFragmentRequestRule = NextFragmentRequestRule(context).create({\n            adapter: adapter,\n            textController: textController,\n            playbackController: playbackController\n        });\n\n        if (dashManifestModel.getIsTextTrack(config.mimeType)) {\n            eventBus.on(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (!currentRepresentationInfo || streamProcessor.isBufferingCompleted()) {\n            logger.warn('Start denied to Schedule Controller');\n            return;\n        }\n        logger.debug('Schedule Controller starts');\n        addPlaylistTraceMetrics();\n        isStopped = false;\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) {\n            return;\n        }\n        logger.debug('Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        const bufferController = streamProcessor.getBufferController();\n        if (isStopped || isFragmentProcessingInProgress || !bufferController ||\n            (playbackController.isPaused() && !mediaPlayerModel.getScheduleWhilePaused()) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled())) {\n            logger.debug('Schedule stop!');\n            return;\n        }\n\n        if (bufferController.getIsBufferingCompleted()) {\n            logger.debug('Schedule stop because buffering is completed!');\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (bufferResetInProgress || isNaN(lastInitQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(currentRepresentationInfo.mediaInfo.type, streamInfo.id) ||\n            bufferLevelRule.execute(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO))) {\n\n            const getNextFragment = function () {\n                const fragmentController = streamProcessor.getFragmentController();\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!bufferResetInProgress)) {\n                    logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    if (switchTrack) {\n                        bufferResetInProgress = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE ? true : false;\n                        logger.debug('Switch track has been asked, get init request for ' + type + ' with representationid = ' + currentRepresentationInfo.id + 'bufferResetInProgress = ' + bufferResetInProgress);\n                        streamProcessor.switchInitData(currentRepresentationInfo.id, bufferResetInProgress);\n                        switchTrack = false;\n                    } else {\n                        streamProcessor.switchInitData(currentRepresentationInfo.id);\n                    }\n                    lastInitQuality = currentRepresentationInfo.quality;\n\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (fragmentController.isInitializationRequest(replacement)) {\n                        // To be sure the specific init segment had not already been loaded.\n                        streamProcessor.switchInitData(replacement.representationId);\n                    } else {\n                        let request;\n                        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n                        if (!streamProcessor.getBufferController().getIsPruningInProgress()) {\n                            request = nextFragmentRequestRule.execute(streamProcessor, seekTarget, replacement);\n                            setSeekTarget(NaN);\n                            if (request && !replacement) {\n                                if (!isNaN(request.startTime + request.duration)) {\n                                    adapter.setIndexHandlerTime(streamProcessor, request.startTime + request.duration);\n                                }\n                                request.delayLoadingTime = new Date().getTime() + timeToLoadDelay;\n                                setTimeToLoadDelay(0);\n                            }\n                            if (!request && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic) {\n                                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n                            }\n                        }\n\n                        if (request) {\n                            logger.debug('Next fragment request url is ' + request.url);\n                            fragmentModel.executeRequest(request);\n                        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n                            setFragmentProcessState(false);\n                            startScheduleTimer(mediaPlayerModel.getLowLatencyEnabled() ? 100 : 500);\n                        }\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && !switchTrack) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !dashManifestModel.getIsTextTrack(type)) {\n            const fastSwitchModeEnabled = mediaPlayerModel.getFastSwitchEnabled();\n            const bufferLevel = streamProcessor.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== AbrController.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > currentRepresentationInfo.quality && !bufferResetInProgress) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + streamProcessor.getBufferLevel());\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function onInitRequested(e) {\n        if (!e.sender || e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        getInitRequest(currentRepresentationInfo.quality);\n    }\n\n    function setFragmentProcessState (state) {\n        if (isFragmentProcessingInProgress !== state ) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function getInitRequest(quality) {\n        const request = adapter.getInitRequest(streamProcessor, quality);\n        if (request) {\n            setFragmentProcessState(true);\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', currentRepresentationInfo ? currentRepresentationInfo.bandwidth : null);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function onQualityChanged(e) {\n        if (type !== e.mediaType || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo(e.newQuality);\n\n        if (currentRepresentationInfo === null || currentRepresentationInfo === undefined) {\n            throw new Error('Unexpected error! - currentRepresentationInfo is null or undefined');\n        }\n\n        clearPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        addPlaylistTraceMetrics();\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error || e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        currentRepresentationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n    }\n\n    function onStreamInitialized(e) {\n        if (e.error || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo();\n\n        if (initialRequest) {\n            if (playbackController.getIsDynamic()) {\n                timelineConverter.setTimeSyncCompleted(true);\n                setLiveEdgeSeekTarget();\n            } else {\n                seekTarget = playbackController.getStreamStartTime(false);\n                streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n            }\n        }\n\n        if (isStopped) {\n            start();\n        }\n    }\n\n    function setLiveEdgeSeekTarget() {\n        const liveEdgeFinder = streamProcessor.getLiveEdgeFinder();\n        if (liveEdgeFinder) {\n            const liveEdge = liveEdgeFinder.getLiveEdge();\n            const dvrWindowSize = currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize / 2;\n            const startTime = liveEdge - playbackController.computeLiveDelay(currentRepresentationInfo.fragmentDuration, dvrWindowSize);\n            const request = adapter.getFragmentRequest(streamProcessor, currentRepresentationInfo, startTime, {\n                ignoreIsFinished: true\n            });\n\n            if (request) {\n                // When low latency mode is selected but browser doesn't support fetch\n                // start at the beginning of the segment to avoid consuming the whole buffer\n                if (mediaPlayerModel.getLowLatencyEnabled()) {\n                    const liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n                    playbackController.setLiveStartTime(liveStartTime);\n                } else {\n                    playbackController.setLiveStartTime(request.startTime);\n                }\n            } else {\n                logger.debug('setLiveEdgeSeekTarget : getFragmentRequest returned undefined request object');\n            }\n            seekTarget = playbackController.getStreamStartTime(false, liveEdge);\n            streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n\n            //special use case for multi period stream. If the startTime is out of the current period, send a seek command.\n            //in onPlaybackSeeking callback (StreamController), the detection of switch stream is done.\n            if (seekTarget > (currentRepresentationInfo.mediaInfo.streamInfo.start + currentRepresentationInfo.mediaInfo.streamInfo.duration)) {\n                playbackController.seek(seekTarget);\n            }\n\n            const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\n            metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\n                currentTime: seekTarget,\n                presentationStartTime: liveEdge,\n                latency: liveEdge - seekTarget,\n                clientTimeOffset: timelineConverter.getClientTimeOffset()\n            });\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== fragmentModel) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n        logger.info('Stream is complete');\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.sender !== fragmentModel) {\n            return;\n        }\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined',\n            ', Range:', e.request.range ? e.request.range : 'undefined');\n        if (dashManifestModel.getIsTextTrack(type)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (bufferResetInProgress) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        if (bufferResetInProgress && !isNaN(e.startTime)) {\n            bufferResetInProgress = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            }\n            else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e.streamProcessor !== streamProcessor) {\n            return;\n        }\n        logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (streamInfo) {\n            if (e.unintended) {\n                // There was an unintended buffer remove, probably creating a gap in the buffer, remove every saved request\n                fragmentModel.removeExecutedRequestsAfterTime(e.from,\n                    streamInfo.duration);\n            } else {\n                fragmentModel.syncExecutedRequestsWithBufferedRange(\n                    streamProcessor.getBufferController().getBuffer().getAllBufferRanges(),\n                    streamInfo.duration);\n            }\n        }\n\n        if (e.hasEnoughSpaceToAppend && isStopped) {\n            start();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        if ((e.sender.getStreamProcessor() === streamProcessor) && e.state === BufferController.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            logger.info('Buffer is empty! Stalling!');\n            clearPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onTimedTextRequested(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        //if subtitles are disabled, do not download subtitles file.\n        if (textController.isTextEnabled()) {\n            getInitRequest(e.index);\n        }\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !mediaPlayerModel.getScheduleWhilePaused()) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        seekTarget = e.seekTime;\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\n            latency: latency\n        });\n\n        //if, during the seek command, the scheduleController is waiting : stop waiting, request chunk as soon as possible\n        if (!isFragmentProcessingInProgress) {\n            startScheduleTimer(0);\n        } else {\n            logger.debug('onPlaybackSeeking for ' + type + ', call fragmentModel.abortRequests in order to seek quicker');\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        if (playListTraceMetrics) {\n            playListTraceMetrics.playbackspeed = e.playbackRate.toString();\n        }\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO));\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function setPlayList(playList) {\n        playListMetrics = playList;\n    }\n\n    function finalisePlayList(time, reason) {\n        clearPlayListTraceMetrics(time, reason);\n        playListMetrics = null;\n    }\n\n    function clearPlayListTraceMetrics(endTime, stopreason) {\n        if (playListMetrics && playListTraceMetricsClosed === false) {\n            const startTime = playListTraceMetrics.start;\n            const duration = endTime.getTime() - startTime.getTime();\n            playListTraceMetrics.duration = duration;\n            playListTraceMetrics.stopreason = stopreason;\n            playListMetrics.trace.push(playListTraceMetrics);\n            playListTraceMetricsClosed = true;\n        }\n    }\n\n    function addPlaylistTraceMetrics() {\n        if (playListMetrics && playListTraceMetricsClosed === true && currentRepresentationInfo) {\n            playListTraceMetricsClosed = false;\n            playListTraceMetrics = new PlayListTrace();\n            playListTraceMetrics.representationid = currentRepresentationInfo.id;\n            playListTraceMetrics.start = new Date();\n            playListTraceMetrics.mstart = playbackController.getTime() * 1000;\n            playListTraceMetrics.playbackspeed = playbackController.getPlaybackRate().toString();\n        }\n    }\n\n    function resetInitialSettings() {\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        playListMetrics = null;\n        playListTraceMetrics = null;\n        playListTraceMetricsClosed = true;\n        initialRequest = true;\n        lastInitQuality = NaN;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        bufferResetInProgress = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        if (dashManifestModel.getIsTextTrack(type)) {\n            eventBus.off(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        replaceRequest: replaceRequest,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        setPlayList: setPlayList,\n        getBufferTarget: getBufferTarget,\n        finalisePlayList: finalisePlayList\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]}