{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["Constants","PlayListTrace","AbrController","BufferController","BufferLevelRule","NextFragmentRequestRule","FragmentModel","EventBus","Events","FactoryMaker","Debug","MediaController","replaceTokenForTemplate","ScheduleController","config","context","eventBus","getInstance","metricsModel","adapter","dashMetrics","dashManifestModel","timelineConverter","mediaPlayerModel","abrController","playbackController","streamController","textController","type","streamProcessor","mediaController","instance","logger","fragmentModel","currentRepresentationInfo","initialRequest","isStopped","playListMetrics","playListTraceMetrics","playListTraceMetricsClosed","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","bufferLevelRule","nextFragmentRequestRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","bufferResetInProgress","mediaRequest","isReplacementRequest","setup","getLogger","resetInitialSettings","initialize","getFragmentModel","create","getIsTextTrack","mimeType","on","TIMED_TEXT_REQUESTED","onTimedTextRequested","QUALITY_CHANGE_REQUESTED","onQualityChanged","DATA_UPDATE_STARTED","onDataUpdateStarted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","STREAM_INITIALIZED","onStreamInitialized","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","INIT_REQUESTED","onInitRequested","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","isStarted","start","isBufferingCompleted","warn","debug","addPlaylistTraceMetrics","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","id","newTopQualityIndex","getTopQualityIndexFor","info","schedule","bufferController","getBufferController","isPaused","getScheduleWhilePaused","FRAGMENTED_TEXT","TEXT","isTextEnabled","getIsBufferingCompleted","validateExecutedFragmentRequest","isReplacement","length","streamInfo","getStreamInfo","isNaN","mediaInfo","execute","isTrackTypePresent","VIDEO","getNextFragment","fragmentController","getFragmentController","quality","getSwitchMode","TRACK_SWITCH_MODE_ALWAYS_REPLACE","switchInitData","replacement","shift","isInitializationRequest","representationId","request","getIsPruningInProgress","setSeekTarget","NaN","startTime","duration","setIndexHandlerTime","delayLoadingTime","Date","getTime","setTimeToLoadDelay","manifestInfo","isDynamic","url","executeRequest","setFragmentProcessState","getLowLatencyEnabled","checkPlaybackQuality","time","safeBufferLevel","fragmentDuration","getRequests","state","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","fastSwitchModeEnabled","getFastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","ABANDON_LOAD","replaceRequest","index","value","setTimeout","e","sender","getStreamProcessor","getInitRequest","bandwidth","switchTrackAsked","push","mediaType","getRepresentationInfo","newQuality","undefined","Error","clearPlayListTraceMetrics","REPRESENTATION_SWITCH_STOP_REASON","completeQualityChange","trigger","item","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","error","convertDataToRepresentationInfo","currentRepresentation","getIsDynamic","setTimeSyncCompleted","setLiveEdgeSeekTarget","getStreamStartTime","setSeekStartTime","liveEdgeFinder","getLiveEdgeFinder","liveEdge","getLiveEdge","dvrWindowSize","DVRWindowSize","computeLiveDelay","getFragmentRequest","ignoreIsFinished","liveStartTime","getLiveDelay","setLiveStartTime","seek","manifestUpdateInfo","getCurrentManifestUpdate","getMetricsFor","STREAM","updateManifestUpdateInfo","currentTime","presentationStartTime","latency","clientTimeOffset","getClientTimeOffset","range","serviceLocation","addExecutedRequest","fragEndTime","isSeeking","unintended","removeExecutedRequestsAfterTime","from","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","hasEnoughSpaceToAppend","BUFFER_EMPTY","REBUFFERING_REASON","abortRequests","seekTime","DVRWindow","end","playbackspeed","playbackRate","toString","getBufferTarget","getType","setPlayList","playList","finalisePlayList","reason","endTime","stopreason","trace","representationid","mstart","getPlaybackRate","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"ScheduleController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport {PlayListTrace} from '../vo/metrics/PlayList';\nimport AbrController from './AbrController';\nimport BufferController from './BufferController';\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\nimport NextFragmentRequestRule from '../rules/scheduling/NextFragmentRequestRule';\nimport FragmentModel from '../models/FragmentModel';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport MediaController from './MediaController';\nimport {replaceTokenForTemplate} from '../../dash/utils/SegmentsUtils';\n\nfunction ScheduleController(config) {\n\n    config = config || {};\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const metricsModel = config.metricsModel;\n    const adapter = config.adapter;\n    const dashMetrics = config.dashMetrics;\n    const dashManifestModel = config.dashManifestModel;\n    const timelineConverter = config.timelineConverter;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const abrController = config.abrController;\n    const playbackController = config.playbackController;\n    const streamController = config.streamController;\n    const textController = config.textController;\n    const type = config.type;\n    const streamProcessor = config.streamProcessor;\n    const mediaController = config.mediaController;\n\n    let instance,\n        logger,\n        fragmentModel,\n        currentRepresentationInfo,\n        initialRequest,\n        isStopped,\n        playListMetrics,\n        playListTraceMetrics,\n        playListTraceMetricsClosed,\n        isFragmentProcessingInProgress,\n        timeToLoadDelay,\n        scheduleTimeout,\n        seekTarget,\n        bufferLevelRule,\n        nextFragmentRequestRule,\n        lastFragmentRequest,\n        topQualityIndex,\n        lastInitQuality,\n        replaceRequestArray,\n        switchTrack,\n        bufferResetInProgress,\n        mediaRequest,\n        isReplacementRequest;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        resetInitialSettings();\n    }\n\n    function initialize() {\n        fragmentModel = streamProcessor.getFragmentModel();\n\n        bufferLevelRule = BufferLevelRule(context).create({\n            abrController: abrController,\n            dashMetrics: dashMetrics,\n            metricsModel: metricsModel,\n            mediaPlayerModel: mediaPlayerModel,\n            textController: textController\n        });\n\n        nextFragmentRequestRule = NextFragmentRequestRule(context).create({\n            adapter: adapter,\n            textController: textController,\n            playbackController: playbackController\n        });\n\n        if (dashManifestModel.getIsTextTrack(config.mimeType)) {\n            eventBus.on(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n    }\n\n    function isStarted() {\n        return (isStopped === false);\n    }\n\n    function start() {\n        if (!currentRepresentationInfo || streamProcessor.isBufferingCompleted()) {\n            logger.warn('Start denied to Schedule Controller');\n            return;\n        }\n        logger.debug('Schedule Controller starts');\n        addPlaylistTraceMetrics();\n        isStopped = false;\n\n        if (initialRequest) {\n            initialRequest = false;\n        }\n\n        startScheduleTimer(0);\n    }\n\n    function stop() {\n        if (isStopped) {\n            return;\n        }\n        logger.debug('Schedule Controller stops');\n        isStopped = true;\n        clearTimeout(scheduleTimeout);\n    }\n\n    function hasTopQualityChanged(type, id) {\n        topQualityIndex[id] = topQualityIndex[id] || {};\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\n\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\n            topQualityIndex[id][type] = newTopQualityIndex;\n            return true;\n        }\n        return false;\n\n    }\n\n    function schedule() {\n        const bufferController = streamProcessor.getBufferController();\n        if (isStopped || isFragmentProcessingInProgress || !bufferController ||\n            (playbackController.isPaused() && !mediaPlayerModel.getScheduleWhilePaused()) ||\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled())) {\n            logger.debug('Schedule stop!');\n            return;\n        }\n\n        if (bufferController.getIsBufferingCompleted()) {\n            logger.debug('Schedule stop because buffering is completed!');\n            return;\n        }\n\n        validateExecutedFragmentRequest();\n\n        const isReplacement = replaceRequestArray.length > 0;\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (bufferResetInProgress || isNaN(lastInitQuality) || switchTrack || isReplacement ||\n            hasTopQualityChanged(currentRepresentationInfo.mediaInfo.type, streamInfo.id) ||\n            bufferLevelRule.execute(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO))) {\n\n            const getNextFragment = function () {\n                const fragmentController = streamProcessor.getFragmentController();\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!bufferResetInProgress)) {\n                    logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\n                    if (switchTrack) {\n                        bufferResetInProgress = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE ? true : false;\n                        logger.debug('Switch track has been asked, get init request for ' + type + ' with representationid = ' + currentRepresentationInfo.id + 'bufferResetInProgress = ' + bufferResetInProgress);\n                        streamProcessor.switchInitData(currentRepresentationInfo.id, bufferResetInProgress);\n                        switchTrack = false;\n                    } else {\n                        streamProcessor.switchInitData(currentRepresentationInfo.id);\n                    }\n                    lastInitQuality = currentRepresentationInfo.quality;\n\n                } else {\n                    const replacement = replaceRequestArray.shift();\n\n                    if (fragmentController.isInitializationRequest(replacement)) {\n                        // To be sure the specific init segment had not already been loaded.\n                        streamProcessor.switchInitData(replacement.representationId);\n                    } else {\n                        let request;\n                        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\n                        if (!streamProcessor.getBufferController().getIsPruningInProgress()) {\n                            request = nextFragmentRequestRule.execute(streamProcessor, seekTarget, replacement);\n                            setSeekTarget(NaN);\n                            if (request && !replacement) {\n                                if (!isNaN(request.startTime + request.duration)) {\n                                    adapter.setIndexHandlerTime(streamProcessor, request.startTime + request.duration);\n                                }\n                                request.delayLoadingTime = new Date().getTime() + timeToLoadDelay;\n                                setTimeToLoadDelay(0);\n                            }\n                            if (!request && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic) {\n                                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\n                            }\n                        }\n\n                        if (request) {\n                            logger.debug('Next fragment request url is ' + request.url);\n                            fragmentModel.executeRequest(request);\n                        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\n                            setFragmentProcessState(false);\n                            startScheduleTimer(mediaPlayerModel.getLowLatencyEnabled() ? 100 : 500);\n                        }\n                    }\n                }\n            };\n\n            setFragmentProcessState(true);\n            if (!isReplacement && !switchTrack) {\n                abrController.checkPlaybackQuality(type);\n            }\n\n            getNextFragment();\n\n        } else {\n            startScheduleTimer(500);\n        }\n    }\n\n    function validateExecutedFragmentRequest() {\n        // Validate that the fragment request executed and appended into the source buffer is as\n        // good of quality as the current quality and is the correct media track.\n        const time = playbackController.getTime();\n        const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n        const request = fragmentModel.getRequests({\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n            time: time + safeBufferLevel,\n            threshold: 0\n        })[0];\n\n        if (request && replaceRequestArray.indexOf(request) === -1 && !dashManifestModel.getIsTextTrack(type)) {\n            const fastSwitchModeEnabled = mediaPlayerModel.getFastSwitchEnabled();\n            const bufferLevel = streamProcessor.getBufferLevel();\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\n\n            // Only replace on track switch when NEVER_REPLACE\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\n\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== AbrController.ABANDON_LOAD) {\n                replaceRequest(request);\n                isReplacementRequest = true;\n                logger.debug('Reloading outdated fragment at index: ', request.index);\n            } else if (request.quality > currentRepresentationInfo.quality && !bufferResetInProgress) {\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\n                setSeekTarget(playbackController.getTime() + streamProcessor.getBufferLevel());\n            }\n        }\n    }\n\n    function startScheduleTimer(value) {\n        clearTimeout(scheduleTimeout);\n        scheduleTimeout = setTimeout(schedule, value);\n    }\n\n    function onInitRequested(e) {\n        if (!e.sender || e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        getInitRequest(currentRepresentationInfo.quality);\n    }\n\n    function setFragmentProcessState (state) {\n        if (isFragmentProcessingInProgress !== state ) {\n            isFragmentProcessingInProgress = state;\n        } else {\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\n        }\n    }\n\n    function getInitRequest(quality) {\n        const request = adapter.getInitRequest(streamProcessor, quality);\n        if (request) {\n            setFragmentProcessState(true);\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', currentRepresentationInfo ? currentRepresentationInfo.bandwidth : null);\n            fragmentModel.executeRequest(request);\n        }\n    }\n\n    function switchTrackAsked() {\n        switchTrack = true;\n    }\n\n    function replaceRequest(request) {\n        replaceRequestArray.push(request);\n    }\n\n    function onQualityChanged(e) {\n        if (type !== e.mediaType || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo(e.newQuality);\n\n        if (currentRepresentationInfo === null || currentRepresentationInfo === undefined) {\n            throw new Error('Unexpected error! - currentRepresentationInfo is null or undefined');\n        }\n\n        clearPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\n        addPlaylistTraceMetrics();\n    }\n\n    function completeQualityChange(trigger) {\n        if (playbackController && fragmentModel) {\n            const item = fragmentModel.getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                time: playbackController.getTime(),\n                threshold: 0\n            })[0];\n            if (item && playbackController.getTime() >= item.startTime) {\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\n                        newMediaInfo: item.mediaInfo\n                    });\n                }\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\n                        mediaType: type,\n                        oldQuality: lastFragmentRequest.quality,\n                        newQuality: item.quality\n                    });\n                }\n                lastFragmentRequest = {\n                    mediaInfo: item.mediaInfo,\n                    quality: item.quality,\n                    adaptationIndex: item.adaptationIndex\n                };\n            }\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error || e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        currentRepresentationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n    }\n\n    function onStreamInitialized(e) {\n        if (e.error || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\n            return;\n        }\n\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo();\n\n        if (initialRequest) {\n            if (playbackController.getIsDynamic()) {\n                timelineConverter.setTimeSyncCompleted(true);\n                setLiveEdgeSeekTarget();\n            } else {\n                seekTarget = playbackController.getStreamStartTime(false);\n                streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n            }\n        }\n\n        if (isStopped) {\n            start();\n        }\n    }\n\n    function setLiveEdgeSeekTarget() {\n        const liveEdgeFinder = streamProcessor.getLiveEdgeFinder();\n        if (liveEdgeFinder) {\n            const liveEdge = liveEdgeFinder.getLiveEdge();\n            const dvrWindowSize = currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize / 2;\n            const startTime = liveEdge - playbackController.computeLiveDelay(currentRepresentationInfo.fragmentDuration, dvrWindowSize);\n            const request = adapter.getFragmentRequest(streamProcessor, currentRepresentationInfo, startTime, {\n                ignoreIsFinished: true\n            });\n\n            if (request) {\n                // When low latency mode is selected but browser doesn't support fetch\n                // start at the beginning of the segment to avoid consuming the whole buffer\n                if (mediaPlayerModel.getLowLatencyEnabled()) {\n                    const liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\n                    playbackController.setLiveStartTime(liveStartTime);\n                } else {\n                    playbackController.setLiveStartTime(request.startTime);\n                }\n            } else {\n                logger.debug('setLiveEdgeSeekTarget : getFragmentRequest returned undefined request object');\n            }\n            seekTarget = playbackController.getStreamStartTime(false, liveEdge);\n            streamProcessor.getBufferController().setSeekStartTime(seekTarget);\n\n            //special use case for multi period stream. If the startTime is out of the current period, send a seek command.\n            //in onPlaybackSeeking callback (StreamController), the detection of switch stream is done.\n            if (seekTarget > (currentRepresentationInfo.mediaInfo.streamInfo.start + currentRepresentationInfo.mediaInfo.streamInfo.duration)) {\n                playbackController.seek(seekTarget);\n            }\n\n            const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\n            metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\n                currentTime: seekTarget,\n                presentationStartTime: liveEdge,\n                latency: liveEdge - seekTarget,\n                clientTimeOffset: timelineConverter.getClientTimeOffset()\n            });\n        }\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== fragmentModel) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n        logger.info('Stream is complete');\n    }\n\n    function onFragmentLoadingCompleted(e) {\n        if (e.sender !== fragmentModel) {\n            return;\n        }\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined',\n            ', Range:', e.request.range ? e.request.range : 'undefined');\n        if (dashManifestModel.getIsTextTrack(type)) {\n            setFragmentProcessState(false);\n        }\n\n        if (e.error && e.request.serviceLocation && !isStopped) {\n            replaceRequest(e.request);\n            setFragmentProcessState(false);\n            startScheduleTimer(0);\n        }\n\n        if (bufferResetInProgress) {\n            mediaRequest = e.request;\n        }\n    }\n\n    function onPlaybackTimeUpdated() {\n        completeQualityChange(true);\n    }\n\n    function onBytesAppended(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        if (bufferResetInProgress && !isNaN(e.startTime)) {\n            bufferResetInProgress = false;\n            fragmentModel.addExecutedRequest(mediaRequest);\n        }\n\n        setFragmentProcessState(false);\n        if (isReplacementRequest && !isNaN(e.startTime)) {\n            //replace requests process is in progress, call schedule in n seconds.\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\n            const currentTime = playbackController.getTime();\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\n                startScheduleTimer(0);\n            }\n            else {\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\n            }\n            isReplacementRequest = false;\n        } else {\n            startScheduleTimer(0);\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e.streamProcessor !== streamProcessor) {\n            return;\n        }\n        logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has been aborted');\n        if (!playbackController.isSeeking() && !switchTrack) {\n            logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\n            replaceRequest(e.request);\n        }\n        setFragmentProcessState(false);\n        startScheduleTimer(0);\n    }\n\n    function onDataUpdateStarted(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        stop();\n    }\n\n    function onBufferCleared(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        const streamInfo = streamProcessor.getStreamInfo();\n        if (streamInfo) {\n            if (e.unintended) {\n                // There was an unintended buffer remove, probably creating a gap in the buffer, remove every saved request\n                fragmentModel.removeExecutedRequestsAfterTime(e.from,\n                    streamInfo.duration);\n            } else {\n                fragmentModel.syncExecutedRequestsWithBufferedRange(\n                    streamProcessor.getBufferController().getBuffer().getAllBufferRanges(),\n                    streamInfo.duration);\n            }\n        }\n\n        if (e.hasEnoughSpaceToAppend && isStopped) {\n            start();\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        if ((e.sender.getStreamProcessor() === streamProcessor) && e.state === BufferController.BUFFER_EMPTY && !playbackController.isSeeking()) {\n            logger.info('Buffer is empty! Stalling!');\n            clearPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\n        }\n    }\n\n    function onQuotaExceeded(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        stop();\n        setFragmentProcessState(false);\n    }\n\n    function onURLResolutionFailed() {\n        fragmentModel.abortRequests();\n        stop();\n    }\n\n    function onTimedTextRequested(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\n            return;\n        }\n\n        //if subtitles are disabled, do not download subtitles file.\n        if (textController.isTextEnabled()) {\n            getInitRequest(e.index);\n        }\n    }\n\n    function onPlaybackStarted() {\n        if (isStopped || !mediaPlayerModel.getScheduleWhilePaused()) {\n            start();\n        }\n    }\n\n    function onPlaybackSeeking(e) {\n        seekTarget = e.seekTime;\n        setTimeToLoadDelay(0);\n\n        if (isStopped) {\n            start();\n        }\n\n        const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\n        metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\n            latency: latency\n        });\n\n        //if, during the seek command, the scheduleController is waiting : stop waiting, request chunk as soon as possible\n        if (!isFragmentProcessingInProgress) {\n            startScheduleTimer(0);\n        } else {\n            logger.debug('onPlaybackSeeking for ' + type + ', call fragmentModel.abortRequests in order to seek quicker');\n            fragmentModel.abortRequests();\n        }\n    }\n\n    function onPlaybackRateChanged(e) {\n        if (playListTraceMetrics) {\n            playListTraceMetrics.playbackspeed = e.playbackRate.toString();\n        }\n    }\n\n    function setSeekTarget(value) {\n        seekTarget = value;\n    }\n\n    function setTimeToLoadDelay(value) {\n        timeToLoadDelay = value;\n    }\n\n    function getBufferTarget() {\n        return bufferLevelRule.getBufferTarget(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO));\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function setPlayList(playList) {\n        playListMetrics = playList;\n    }\n\n    function finalisePlayList(time, reason) {\n        clearPlayListTraceMetrics(time, reason);\n        playListMetrics = null;\n    }\n\n    function clearPlayListTraceMetrics(endTime, stopreason) {\n        if (playListMetrics && playListTraceMetricsClosed === false) {\n            const startTime = playListTraceMetrics.start;\n            const duration = endTime.getTime() - startTime.getTime();\n            playListTraceMetrics.duration = duration;\n            playListTraceMetrics.stopreason = stopreason;\n            playListMetrics.trace.push(playListTraceMetrics);\n            playListTraceMetricsClosed = true;\n        }\n    }\n\n    function addPlaylistTraceMetrics() {\n        if (playListMetrics && playListTraceMetricsClosed === true && currentRepresentationInfo) {\n            playListTraceMetricsClosed = false;\n            playListTraceMetrics = new PlayListTrace();\n            playListTraceMetrics.representationid = currentRepresentationInfo.id;\n            playListTraceMetrics.start = new Date();\n            playListTraceMetrics.mstart = playbackController.getTime() * 1000;\n            playListTraceMetrics.playbackspeed = playbackController.getPlaybackRate().toString();\n        }\n    }\n\n    function resetInitialSettings() {\n        isFragmentProcessingInProgress = false;\n        timeToLoadDelay = 0;\n        seekTarget = NaN;\n        playListMetrics = null;\n        playListTraceMetrics = null;\n        playListTraceMetricsClosed = true;\n        initialRequest = true;\n        lastInitQuality = NaN;\n        lastFragmentRequest = {\n            mediaInfo: undefined,\n            quality: NaN,\n            adaptationIndex: NaN\n        };\n        topQualityIndex = {};\n        replaceRequestArray = [];\n        isStopped = true;\n        switchTrack = false;\n        bufferResetInProgress = false;\n        mediaRequest = null;\n        isReplacementRequest = false;\n    }\n\n    function reset() {\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\n        eventBus.off(Events.INIT_REQUESTED, onInitRequested, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\n        if (dashManifestModel.getIsTextTrack(type)) {\n            eventBus.off(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\n        }\n\n        stop();\n        completeQualityChange(false);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        getType: getType,\n        setSeekTarget: setSeekTarget,\n        setTimeToLoadDelay: setTimeToLoadDelay,\n        replaceRequest: replaceRequest,\n        switchTrackAsked: switchTrackAsked,\n        isStarted: isStarted,\n        start: start,\n        stop: stop,\n        reset: reset,\n        setPlayList: setPlayList,\n        getBufferTarget: getBufferTarget,\n        finalisePlayList: finalisePlayList\n    };\n\n    setup();\n\n    return instance;\n}\n\nScheduleController.__dashjs_factory_name = 'ScheduleController';\nexport default FactoryMaker.getClassFactory(ScheduleController);\n"]}