{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["Constants","DashJSError","HTTPRequest","EventBus","Events","Errors","FactoryMaker","Debug","URLUtils","HTTP_TIMEOUT_MS","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","offsetToDeviceTimeMs","isSynchronizing","useManifestDateHeaderTimeSource","handlers","metricsModel","dashMetrics","baseURLController","setup","getLogger","initialize","timingSources","useManifestDateHeader","httpHeadHandler","httpHandler","bind","xsdatetimeDecoder","iso8601Decoder","directHandler","notSupportedHandler","getIsSynchronizing","attemptSync","setConfig","config","getOffsetToDeviceTimeMs","getOffsetMs","setIsSynchronizing","value","setOffsetMs","alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","Date","UTC","parseInt","parseFloat","getTime","parsedDate","parse","isNaN","isoStr","rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HEAD","GET","urls","shift","length","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","checkForDateHeader","metrics","getReadOnlyMetricsFor","STREAM","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","NaN","completeTimeSyncSequence","failed","offset","trigger","TIME_SYNCHRONIZATION_COMPLETED","error","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","calculateTimeOffset","serverTime","deviceTime","sources","sourceIndex","index","source","onComplete","hasOwnProperty","schemeIdUri","info","reset","__dashjs_factory_name","factory","getSingletonFactory","updateSingletonFactory"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BA,MAAOA,UAAP,KAAsB,wBAAtB,CACA,MAAOC,YAAP,KAAwB,qBAAxB,CACA,OAAQC,WAAR,KAA0B,6BAA1B,CACA,MAAOC,SAAP,KAAqB,uBAArB,CACA,MAAOC,OAAP,KAAmB,4BAAnB,CACA,MAAOC,OAAP,KAAmB,4BAAnB,CACA,MAAOC,aAAP,KAAyB,yBAAzB,CACA,MAAOC,MAAP,KAAkB,kBAAlB,CACA,MAAOC,SAAP,KAAqB,mBAArB,CAEA,KAAMC,iBAAkB,IAAxB,CAEA,QAASC,mBAAT,EAA8B,CAE1B,KAAMC,SAAU,KAAKA,OAArB,CACA,KAAMC,UAAWT,SAASQ,OAAT,EAAkBE,WAAlB,EAAjB,CACA,KAAMC,UAAWN,SAASG,OAAT,EAAkBE,WAAlB,EAAjB,CAEA,GAAIE,SAAJ,CACIC,MADJ,CAEIC,oBAFJ,CAGIC,eAHJ,CAIIC,+BAJJ,CAKIC,QALJ,CAMIC,YANJ,CAOIC,WAPJ,CAQIC,iBARJ,CAUA,QAASC,MAAT,EAAiB,CACbR,OAAST,MAAMI,OAAN,EAAeE,WAAf,GAA6BY,SAA7B,CAAuCV,QAAvC,CAAT,CACH,CAED,QAASW,WAAT,CAAoBC,aAApB,CAAmCC,qBAAnC,CAA0D,CACtDT,gCAAkCS,qBAAlC,CACAX,qBAAuB,CAAvB,CACAC,gBAAkB,KAAlB,CAEA;AACAE,SAAW,CACP,mCAAwCS,eADjC,CAEP,qCAAwCC,YAAYC,IAAZ,CAAiB,IAAjB,CAAuBC,iBAAvB,CAFjC,CAGP,kCAAwCF,YAAYC,IAAZ,CAAiB,IAAjB,CAAuBE,cAAvB,CAHjC,CAIP,gCAAwCC,aAJjC,CAMP;AACA;AACA,mCAAwCL,eARjC,CASP,qCAAwCC,YAAYC,IAAZ,CAAiB,IAAjB,CAAuBC,iBAAvB,CATjC,CAUP,kCAAwCF,YAAYC,IAAZ,CAAiB,IAAjB,CAAuBE,cAAvB,CAVjC,CAWP,gCAAwCC,aAXjC,CAaP;AACA;AACA;AACA;AACA,kCAAwCC,mBAjBjC,CAmBP;AACA,6BAAwCA,mBApBjC,CAqBP,8BAAwCA,mBArBjC,CAAX,CAwBA,GAAI,CAACC,oBAAL,CAA2B,CACvBC,YAAYV,aAAZ,EACH,CACJ,CAED,QAASW,UAAT,CAAmBC,MAAnB,CAA2B,CACvB,GAAI,CAACA,MAAL,CAAa,OAEb,GAAIA,OAAOlB,YAAX,CAAyB,CACrBA,aAAekB,OAAOlB,YAAtB,CACH,CAED,GAAIkB,OAAOjB,WAAX,CAAwB,CACpBA,YAAciB,OAAOjB,WAArB,CACH,CAED,GAAIiB,OAAOhB,iBAAX,CAA8B,CAC1BA,kBAAoBgB,OAAOhB,iBAA3B,CACH,CACJ,CAED,QAASiB,wBAAT,EAAmC,CAC/B,MAAOC,cAAP,CACH,CAED,QAASC,mBAAT,CAA4BC,KAA5B,CAAmC,CAC/BzB,gBAAkByB,KAAlB,CACH,CAED,QAASP,mBAAT,EAA8B,CAC1B,MAAOlB,gBAAP,CACH,CAED,QAAS0B,YAAT,CAAqBD,KAArB,CAA4B,CACxB1B,qBAAuB0B,KAAvB,CACH,CAED,QAASF,YAAT,EAAuB,CACnB,MAAOxB,qBAAP,CACH,CAED;AACA;AACA;AACA,QAAS4B,2BAAT,CAAoCC,aAApC,CAAmD,CAC/C;AACA,KAAMC,gBAAiB,EAAvB,CACA,KAAMC,iBAAkB,EAAxB,CACA,KAAMC,yBAA0B,IAAhC,CACA,GAAIC,eAAgB,kHAApB,CAEA,GAAIC,QAAJ,CACIC,cADJ,CAGA,GAAIC,OAAQH,cAAcI,IAAd,CAAmBR,aAAnB,CAAZ,CAEA;AACA;AACA;AACAK,QAAUI,KAAKC,GAAL,CACNC,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,CADM,CAENI,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,EAAyB,CAFnB,CAEsB;AAC5BI,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,CAHM,CAINI,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,CAJM,CAKNI,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,CALM,CAMLA,MAAM,CAAN,IAAaI,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,GAA0B,CAAvC,CANK,CAOLA,MAAM,CAAN,GAAYK,WAAWL,MAAM,CAAN,CAAX,EAAuBJ,uBAApC,EAAgE,CAP1D,CAAV,CASA;AACA,GAAII,MAAM,CAAN,GAAYA,MAAM,EAAN,CAAhB,CAA2B,CACvBD,eAAiBK,SAASJ,MAAM,CAAN,CAAT,CAAmB,EAAnB,EAAyBL,eAAzB,CAA2CS,SAASJ,MAAM,EAAN,CAAT,CAAoB,EAApB,CAA5D,CACAF,SAAW,CAACE,MAAM,CAAN,IAAa,GAAb,CAAmB,CAAC,CAApB,CAAwB,CAAC,CAA1B,EAA+BD,cAA/B,CAAgDL,cAAhD,CAAiEE,uBAA5E,CACH,CAED,MAAO,IAAIM,KAAJ,CAASJ,OAAT,EAAkBQ,OAAlB,EAAP,CACH,CAED;AACA;AACA;AACA,QAAS3B,kBAAT,CAA2Bc,aAA3B,CAA0C,CACtC,GAAIc,YAAaL,KAAKM,KAAL,CAAWf,aAAX,CAAjB,CAEA,GAAIgB,MAAMF,UAAN,CAAJ,CAAuB,CACnBA,WAAaf,2BAA2BC,aAA3B,CAAb,CACH,CAED,MAAOc,WAAP,CACH,CAED;AACA,QAAS3B,eAAT,CAAwB8B,MAAxB,CAAgC,CAC5B,MAAOR,MAAKM,KAAL,CAAWE,MAAX,CAAP,CACH,CAED;AACA;AACA,QAASC,eAAT,CAAwBC,OAAxB,CAAiC,CAC7B,MAAOV,MAAKM,KAAL,CAAWI,OAAX,CAAP,CACH,CAED,QAAS9B,oBAAT,CAA6B+B,GAA7B,CAAkCC,WAAlC,CAA+CC,WAA/C,CAA4D,CACxDA,cACH,CAED,QAASlC,cAAT,CAAuBY,aAAvB,CAAsCqB,WAAtC,CAAmDC,WAAnD,CAAgE,CAC5D,GAAIC,MAAOrC,kBAAkBc,aAAlB,CAAX,CAEA,GAAI,CAACgB,MAAMO,IAAN,CAAL,CAAkB,CACdF,YAAYE,IAAZ,EACA,OACH,CAEDD,cACH,CAED,QAAStC,YAAT,CAAqBwC,OAArB,CAA8BJ,GAA9B,CAAmCC,WAAnC,CAAgDC,WAAhD,CAA6DG,aAA7D,CAA4E,CACxE,GAAIC,WAAJ,CACIC,MADJ,CAEA,GAAIC,UAAW,KAAf,CACA,GAAIC,KAAM,GAAIC,eAAJ,EAAV,CAEA,GAAIC,MAAON,cAAgBrE,YAAY4E,IAA5B,CAAmC5E,YAAY6E,GAA1D,CACA,GAAIC,MAAOd,IAAIb,KAAJ,CAAU,MAAV,CAAX,CAEA;AACA;AACAa,IAAMc,KAAKC,KAAL,EAAN,CAEAT,WAAa,UAAY,CACrB,GAAIE,QAAJ,CAAc,CACV,OACH,CAED;AACA;AACAA,SAAW,IAAX,CAEA;AACA,GAAIM,KAAKE,MAAT,CAAiB,CACbpD,YAAYwC,OAAZ,CAAqBU,KAAKG,IAAL,CAAU,GAAV,CAArB,CAAqChB,WAArC,CAAkDC,WAAlD,CAA+DG,aAA/D,EACH,CAFD,IAEO,CACHH,cACH,CACJ,CAfD,CAiBAK,OAAS,UAAY,CACjB,GAAIJ,KAAJ,CACIe,MADJ,CAGA,GAAIT,IAAIU,MAAJ,GAAe,GAAnB,CAAwB,CACpBhB,KAAOE,cACCI,IAAIW,iBAAJ,CAAsB,MAAtB,CADD,CAECX,IAAIY,QAFZ,CAIAH,OAASd,QAAQD,IAAR,CAAT,CAEA;AACA,GAAI,CAACP,MAAMsB,MAAN,CAAL,CAAoB,CAChBjB,YAAYiB,MAAZ,EACAV,SAAW,IAAX,CACH,CACJ,CACJ,CAjBD,CAmBA,GAAI5D,SAAS0E,UAAT,CAAoBtB,GAApB,CAAJ,CAA8B,CAC1B;AACA,KAAMuB,SAAUlE,kBAAkBmE,OAAlB,EAAhB,CACA,GAAID,OAAJ,CAAa,CACTvB,IAAMpD,SAAS4E,OAAT,CAAiBxB,GAAjB,CAAsBuB,QAAQvB,GAA9B,CAAN,CACH,CACJ,CAEDS,IAAIgB,IAAJ,CAASd,IAAT,CAAeX,GAAf,EACAS,IAAIiB,OAAJ,CAAcnF,iBAAmB,CAAjC,CACAkE,IAAIF,MAAJ,CAAaA,MAAb,CACAE,IAAIkB,SAAJ,CAAgBrB,UAAhB,CACAG,IAAImB,IAAJ,GACH,CAED,QAASjE,gBAAT,CAAyBqC,GAAzB,CAA8BC,WAA9B,CAA2CC,WAA3C,CAAwD,CACpDtC,YAAYkC,cAAZ,CAA4BE,GAA5B,CAAiCC,WAAjC,CAA8CC,WAA9C,CAA2D,IAA3D,EACH,CAED,QAAS2B,mBAAT,EAA8B,CAC1B,GAAIC,SAAU3E,aAAa4E,qBAAb,CAAmCjG,UAAUkG,MAA7C,CAAd,CACA,GAAIC,iBAAkB7E,YAAY8E,kCAAZ,CAA+CJ,OAA/C,CAAwD,MAAxD,CAAtB,CACA,GAAIK,gBAAiBF,kBAAoB,IAApB,CAA2B,GAAI5C,KAAJ,CAAS4C,eAAT,EAA0BxC,OAA1B,EAA3B,CAAiE2C,OAAOC,GAA7F,CAEA,GAAI,CAACzC,MAAMuC,cAAN,CAAL,CAA4B,CACxBzD,YAAYyD,eAAiB,GAAI9C,KAAJ,GAAWI,OAAX,EAA7B,EACA6C,yBAAyB,KAAzB,CAAgCH,eAAiB,IAAjD,CAAuDpF,oBAAvD,EACH,CAHD,IAGO,CACHuF,yBAAyB,IAAzB,EACH,CACJ,CAED,QAASA,yBAAT,CAAkCC,MAAlC,CAA0CpC,IAA1C,CAAgDqC,MAAhD,CAAwD,CACpDhE,mBAAmB,KAAnB,EACA9B,SAAS+F,OAAT,CAAiBvG,OAAOwG,8BAAxB,CAAwD,CAAEvC,KAAMA,IAAR,CAAcqC,OAAQA,MAAtB,CAA8BG,MAAOJ,OAAS,GAAIxG,YAAJ,CAAgBI,OAAOyG,2BAAvB,CAAoDzG,OAAO0G,8BAA3D,CAAT,CAAsG,IAA3I,CAAxD,EACH,CAED,QAASC,oBAAT,CAA6BC,UAA7B,CAAyCC,UAAzC,CAAqD,CACjD,MAAOD,YAAaC,UAApB,CACH,CAED,QAAS7E,YAAT,CAAqB8E,OAArB,CAA8BC,WAA9B,CAA2C,CAEvC;AACA,GAAKC,OAAQD,aAAe,CAA5B,CAEA;AACA;AACA;AACA,GAAIE,QAASH,QAAQE,KAAR,CAAb,CAEA;AACA,KAAME,YAAa,SAAUlD,IAAV,CAAgBqC,MAAhB,CAAwB,CACvC,GAAID,QAAS,CAACpC,IAAD,EAAS,CAACqC,MAAvB,CACA,GAAID,QAAUtF,+BAAd,CAA+C,CAC3C;AACA4E,qBACH,CAHD,IAGO,CACHS,yBAAyBC,MAAzB,CAAiCpC,IAAjC,CAAuCqC,MAAvC,EACH,CACJ,CARD,CAUAhE,mBAAmB,IAAnB,EAEA,GAAI4E,MAAJ,CAAY,CACR;AACA,GAAIlG,SAASoG,cAAT,CAAwBF,OAAOG,WAA/B,CAAJ,CAAiD,CAC7C;AACArG,SAASkG,OAAOG,WAAhB,EACIH,OAAO3E,KADX,CAEI,SAAUsE,UAAV,CAAsB,CAClB;AACA,KAAMC,YAAa,GAAI3D,KAAJ,GAAWI,OAAX,EAAnB,CACA,KAAM+C,QAASM,oBAAoBC,UAApB,CAAgCC,UAAhC,CAAf,CAEAtE,YAAY8D,MAAZ,EAEA1F,OAAO0G,IAAP,CAAY,eAAiB,GAAInE,KAAJ,CAAS2D,UAAT,CAA7B,EACAlG,OAAO0G,IAAP,CAAY,gBAAkB,GAAInE,KAAJ,CAAS0D,UAAT,CAA9B,EACAjG,OAAO0G,IAAP,CAAY,kCAAoChB,MAAhD,EAEAa,WAAWN,UAAX,CAAuBP,MAAvB,EACH,CAdL,CAeI,UAAY,CACR;AACA;AACA;AACArE,YAAY8E,OAAZ,CAAqBE,MAAQ,CAA7B,EACH,CApBL,EAsBH,CAxBD,IAwBO,CACH;AACA;AACAhF,YAAY8E,OAAZ,CAAqBE,MAAQ,CAA7B,EACH,CACJ,CA/BD,IA+BO,CACH;AACAzE,YAAY,CAAZ,EACA2E,aACH,CACJ,CAED,QAASI,MAAT,EAAiB,CACbjF,mBAAmB,KAAnB,EACH,CAED3B,SAAW,CACPW,WAAYA,UADL,CAEPc,wBAAyBA,uBAFlB,CAGPF,UAAWA,SAHJ,CAIPqF,MAAOA,KAJA,CAAX,CAOAnG,QAEA,MAAOT,SAAP,CACH,CAEDL,mBAAmBkH,qBAAnB,CAA2C,oBAA3C,CACA,KAAMC,SAAUvH,aAAawH,mBAAb,CAAiCpH,kBAAjC,CAAhB,CACAmH,QAAQpH,eAAR,CAA0BA,eAA1B,CACAH,aAAayH,sBAAb,CAAoCrH,mBAAmBkH,qBAAvD,CAA8EC,OAA9E,EACA,cAAeA,QAAf","file":"TimeSyncController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport DashJSError from './../vo/DashJSError';\nimport {HTTPRequest} from './../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport Errors from './../../core/errors/Errors';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst HTTP_TIMEOUT_MS = 5000;\n\nfunction TimeSyncController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        offsetToDeviceTimeMs,\n        isSynchronizing,\n        useManifestDateHeaderTimeSource,\n        handlers,\n        metricsModel,\n        dashMetrics,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize(timingSources, useManifestDateHeader) {\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\n        offsetToDeviceTimeMs = 0;\n        isSynchronizing = false;\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\n        };\n\n        if (!getIsSynchronizing()) {\n            attemptSync(timingSources);\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n    }\n\n    function getOffsetToDeviceTimeMs() {\n        return getOffsetMs();\n    }\n\n    function setIsSynchronizing(value) {\n        isSynchronizing = value;\n    }\n\n    function getIsSynchronizing() {\n        return isSynchronizing;\n    }\n\n    function setOffsetMs(value) {\n        offsetToDeviceTimeMs = value;\n    }\n\n    function getOffsetMs() {\n        return offsetToDeviceTimeMs;\n    }\n\n    // takes xsdatetime and returns milliseconds since UNIX epoch\n    // may not be necessary as xsdatetime is very similar to ISO 8601\n    // which is natively understood by javascript Date parser\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n    // try to use the built in parser, since xsdate is a constrained ISO8601\n    // which is supported natively by Date.parse. if that fails, try a\n    // regex-based version used elsewhere in this application.\n    function xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n    function iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\n    // milliseconds since UNIX epoch\n    function rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                        req.getResponseHeader('Date') :\n                        req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    function checkForDateHeader() {\n        let metrics = metricsModel.getReadOnlyMetricsFor(Constants.STREAM);\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID(metrics, 'Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            setOffsetMs(dateHeaderTime - new Date().getTime());\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\n        } else {\n            completeTimeSyncSequence(true);\n        }\n    }\n\n    function completeTimeSyncSequence(failed, time, offset) {\n        setIsSynchronizing(false);\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null });\n    }\n\n    function calculateTimeOffset(serverTime, deviceTime) {\n        return serverTime - deviceTime;\n    }\n\n    function attemptSync(sources, sourceIndex) {\n\n        // if called with no sourceIndex, use zero (highest priority)\n        let  index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        let source = sources[index];\n\n        // callback to emit event to listeners\n        const onComplete = function (time, offset) {\n            let failed = !time || !offset;\n            if (failed && useManifestDateHeaderTimeSource) {\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n                checkForDateHeader();\n            } else {\n                completeTimeSyncSequence(failed, time, offset);\n            }\n        };\n\n        setIsSynchronizing(true);\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        const deviceTime = new Date().getTime();\n                        const offset = calculateTimeOffset(serverTime, deviceTime);\n\n                        setOffsetMs(offset);\n\n                        logger.info('Local time: ' + new Date(deviceTime));\n                        logger.info('Server time: ' + new Date(serverTime));\n                        logger.info('Server Time - Local Time (ms): ' + offset);\n\n                        onComplete(serverTime, offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        attemptSync(sources, index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                attemptSync(sources, index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            setOffsetMs(0);\n            onComplete();\n        }\n    }\n\n    function reset() {\n        setIsSynchronizing(false);\n    }\n\n    instance = {\n        initialize: initialize,\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]}