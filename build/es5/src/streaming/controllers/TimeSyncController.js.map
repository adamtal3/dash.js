{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["Constants","DashJSError","HTTPRequest","EventBus","Events","Errors","FactoryMaker","Debug","URLUtils","HTTP_TIMEOUT_MS","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","offsetToDeviceTimeMs","isSynchronizing","useManifestDateHeaderTimeSource","handlers","metricsModel","dashMetrics","baseURLController","setup","getLogger","initialize","timingSources","useManifestDateHeader","httpHeadHandler","httpHandler","bind","xsdatetimeDecoder","iso8601Decoder","directHandler","notSupportedHandler","getIsSynchronizing","attemptSync","setConfig","config","getOffsetToDeviceTimeMs","getOffsetMs","setIsSynchronizing","value","setOffsetMs","alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","Date","UTC","parseInt","parseFloat","getTime","parsedDate","parse","isNaN","isoStr","rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HEAD","GET","urls","shift","length","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","checkForDateHeader","metrics","getReadOnlyMetricsFor","STREAM","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","NaN","completeTimeSyncSequence","failed","offset","trigger","TIME_SYNCHRONIZATION_COMPLETED","error","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","calculateTimeOffset","serverTime","deviceTime","sources","sourceIndex","index","source","onComplete","hasOwnProperty","schemeIdUri","info","reset","__dashjs_factory_name","factory","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport DashJSError from './../vo/DashJSError';\nimport {HTTPRequest} from './../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport Errors from './../../core/errors/Errors';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst HTTP_TIMEOUT_MS = 5000;\n\nfunction TimeSyncController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        logger,\n        offsetToDeviceTimeMs,\n        isSynchronizing,\n        useManifestDateHeaderTimeSource,\n        handlers,\n        metricsModel,\n        dashMetrics,\n        baseURLController;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n    }\n\n    function initialize(timingSources, useManifestDateHeader) {\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\n        offsetToDeviceTimeMs = 0;\n        isSynchronizing = false;\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\n        };\n\n        if (!getIsSynchronizing()) {\n            attemptSync(timingSources);\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n    }\n\n    function getOffsetToDeviceTimeMs() {\n        return getOffsetMs();\n    }\n\n    function setIsSynchronizing(value) {\n        isSynchronizing = value;\n    }\n\n    function getIsSynchronizing() {\n        return isSynchronizing;\n    }\n\n    function setOffsetMs(value) {\n        offsetToDeviceTimeMs = value;\n    }\n\n    function getOffsetMs() {\n        return offsetToDeviceTimeMs;\n    }\n\n    // takes xsdatetime and returns milliseconds since UNIX epoch\n    // may not be necessary as xsdatetime is very similar to ISO 8601\n    // which is natively understood by javascript Date parser\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n    // try to use the built in parser, since xsdate is a constrained ISO8601\n    // which is supported natively by Date.parse. if that fails, try a\n    // regex-based version used elsewhere in this application.\n    function xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n    function iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\n    // milliseconds since UNIX epoch\n    function rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                        req.getResponseHeader('Date') :\n                        req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    function checkForDateHeader() {\n        let metrics = metricsModel.getReadOnlyMetricsFor(Constants.STREAM);\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID(metrics, 'Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            setOffsetMs(dateHeaderTime - new Date().getTime());\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\n        } else {\n            completeTimeSyncSequence(true);\n        }\n    }\n\n    function completeTimeSyncSequence(failed, time, offset) {\n        setIsSynchronizing(false);\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null });\n    }\n\n    function calculateTimeOffset(serverTime, deviceTime) {\n        return serverTime - deviceTime;\n    }\n\n    function attemptSync(sources, sourceIndex) {\n\n        // if called with no sourceIndex, use zero (highest priority)\n        let  index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        let source = sources[index];\n\n        // callback to emit event to listeners\n        const onComplete = function (time, offset) {\n            let failed = !time || !offset;\n            if (failed && useManifestDateHeaderTimeSource) {\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n                checkForDateHeader();\n            } else {\n                completeTimeSyncSequence(failed, time, offset);\n            }\n        };\n\n        setIsSynchronizing(true);\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        const deviceTime = new Date().getTime();\n                        const offset = calculateTimeOffset(serverTime, deviceTime);\n\n                        setOffsetMs(offset);\n\n                        logger.info('Local time: ' + new Date(deviceTime));\n                        logger.info('Server time: ' + new Date(serverTime));\n                        logger.info('Server Time - Local Time (ms): ' + offset);\n\n                        onComplete(serverTime, offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        attemptSync(sources, index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                attemptSync(sources, index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            setOffsetMs(0);\n            onComplete();\n        }\n    }\n\n    function reset() {\n        setIsSynchronizing(false);\n    }\n\n    instance = {\n        initialize: initialize,\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]}