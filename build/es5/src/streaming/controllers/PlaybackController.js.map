{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["Constants","BufferController","EventBus","Events","FactoryMaker","Debug","LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","metricsModel","dashMetrics","manifestModel","dashManifestModel","adapter","videoModel","timelineConverter","liveStartTime","wallclockTimeIntervalId","commonEarliestTime","liveDelay","bufferedRange","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","compatibleWithPreviousStream","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","setup","getLogger","reset","initialize","StreamInfo","compatible","addAllListeners","manifestInfo","start","ua","navigator","userAgent","toLowerCase","isSafari","test","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","play","e","fromStreamInfo","id","undefined","getTimeToStreamEnd","parseFloat","getStreamEndTime","getTime","toFixed","startTime","getStreamStartTime","offset","duration","getElement","isPaused","pause","isSeeking","seek","time","stickToBuffered","internalSeek","removeEventListener","onPlaybackSeeking","info","setCurrentTime","trigger","PLAYBACK_SEEK_ASKED","seekToLive","metrics","getReadOnlyMetricsFor","VIDEO","AUDIO","DVRMetrics","getCurrentDVRInfo","DVRWindow","range","end","getLiveDelay","getNormalizedTime","t","isNaN","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","setLiveStartTime","value","getLiveStartTime","computeLiveDelay","fragmentDuration","dvrWindowSize","mpd","getMpd","getValue","delay","ret","END_OF_PLAYLIST_PADDING","getUseSuggestedPresentationDelay","hasOwnProperty","SUGGESTED_PRESENTATION_DELAY","suggestedPresentationDelay","getLowLatencyEnabled","getLiveDelayFragmentCount","minBufferTime","targetDelayCapping","Math","max","min","getCurrentLiveLatency","NaN","currentTime","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","getStartTimeFromUriParameters","fragData","getURIFragmentData","uriParameters","r","parseInt","DVRWindowSize","floor","availableFrom","fragS","s","fragT","ignoreStartOffset","liveEdge","presentationStartTime","startTimeOffset","earliestTime","audio","video","getActualPresentationTime","actualTime","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","getWallclockTimeUpdateInterval","clearInterval","updateCurrentTime","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","seekTime","PLAYBACK_SEEKING","onPlaybackSeeked","PLAYBACK_SEEKED","addEventListener","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","checkTimeInRanges","ranges","length","i","len","getCatchUpPlaybackRate","needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","p","bl","abs","getLowLatencyMinDrift","cpr","deltaLatency","d","pow","E","newRate","setPlaybackRate","getLowLatencyMaxDriftBeforeSeeking","initialStartTime","bufferedRanges","started","type","sender","getType","hasVideoTrack","isTrackTypePresent","hasAudioTrack","stream","request","minDelay","warn","setLiveDelay","state","BUFFER_EMPTY","setStallState","mediaType","onPlaybackStalled","PLAYBACK_STALLED","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"PlaybackController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport BufferController from './BufferController';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        streamController,\n        metricsModel,\n        dashMetrics,\n        manifestModel,\n        dashManifestModel,\n        adapter,\n        videoModel,\n        timelineConverter,\n        liveStartTime,\n        wallclockTimeIntervalId,\n        commonEarliestTime,\n        liveDelay,\n        bufferedRange,\n        streamInfo,\n        isDynamic,\n        mediaPlayerModel,\n        playOnceInitialized,\n        lastLivePlaybackTime,\n        availabilityStartTime,\n        compatibleWithPreviousStream,\n        isLowLatencySeekingInProgress,\n        playbackStalled,\n        minPlaybackRateChange,\n        uriFragmentModel;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function initialize(StreamInfo, compatible) {\n        streamInfo = StreamInfo;\n        addAllListeners();\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        isLowLatencySeekingInProgress = false;\n        playbackStalled = false;\n        liveStartTime = streamInfo.start;\n        compatibleWithPreviousStream = compatible;\n\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n\n        // Detect safari browser (special behavior for low latency streams)\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n\n        if (playOnceInitialized) {\n            playOnceInitialized = false;\n            play();\n        }\n    }\n\n    function onPeriodSwitchStarted(e) {\n        if (!isDynamic && e.fromStreamInfo && commonEarliestTime[e.fromStreamInfo.id] !== undefined) {\n            delete bufferedRange[e.fromStreamInfo.id];\n            delete commonEarliestTime[e.fromStreamInfo.id];\n        }\n    }\n\n    function getTimeToStreamEnd() {\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n    }\n\n    function getStreamEndTime() {\n        const startTime = getStreamStartTime(true);\n        const offset = isDynamic && streamInfo ? startTime - streamInfo.start : 0;\n        return startTime + (streamInfo ? streamInfo.duration - offset : offset);\n    }\n\n    function play() {\n        if (streamInfo && videoModel && videoModel.getElement()) {\n            videoModel.play();\n        } else {\n            playOnceInitialized = true;\n        }\n    }\n\n    function isPaused() {\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\n    }\n\n    function pause() {\n        if (streamInfo && videoModel) {\n            videoModel.pause();\n        }\n    }\n\n    function isSeeking() {\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\n    }\n\n    function seek(time, stickToBuffered, internalSeek) {\n        if (streamInfo && videoModel) {\n            if (internalSeek === true) {\n                if (time !== videoModel.getTime()) {\n                    // Internal seek = seek video model only (disable 'seeking' listener),\n                    // buffer(s) are already appended at given time (see onBytesAppended())\n                    videoModel.removeEventListener('seeking', onPlaybackSeeking);\n                    logger.info('Requesting seek to time: ' + time);\n                    videoModel.setCurrentTime(time, stickToBuffered);\n                }\n            } else {\n                eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\n                logger.info('Requesting seek to time: ' + time);\n                videoModel.setCurrentTime(time, stickToBuffered);\n            }\n        }\n    }\n\n    function seekToLive() {\n        const metrics = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO);\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(metrics);\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n    }\n\n    function getTime() {\n        return streamInfo && videoModel ? videoModel.getTime() : null;\n    }\n\n    function getNormalizedTime() {\n        let t = getTime();\n\n        if (isDynamic && !isNaN(availabilityStartTime)) {\n            const timeOffset = availabilityStartTime / 1000;\n            // Fix current time for firefox and safari (returned as an absolute time)\n            if (t > timeOffset) {\n                t -= timeOffset;\n            }\n        }\n\n        return t;\n    }\n\n    function getPlaybackRate() {\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n    }\n\n    function getPlayedRanges() {\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n    }\n\n    function getEnded() {\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\n    }\n\n    function getIsDynamic() {\n        return isDynamic;\n    }\n\n    function getStreamController() {\n        return streamController;\n    }\n\n    function setLiveStartTime(value) {\n        liveStartTime = value;\n    }\n\n    function getLiveStartTime() {\n        return liveStartTime;\n    }\n\n    /**\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n     * @param {number} fragmentDuration - seconds?\n     * @param {number} dvrWindowSize - seconds?\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function computeLiveDelay(fragmentDuration, dvrWindowSize) {\n        const mpd = dashManifestModel.getMpd(manifestModel.getValue());\n\n        let delay;\n        let ret;\n        const END_OF_PLAYLIST_PADDING = 10;\n\n        if (mediaPlayerModel.getUseSuggestedPresentationDelay() && mpd.hasOwnProperty(Constants.SUGGESTED_PRESENTATION_DELAY)) {\n            delay = mpd.suggestedPresentationDelay;\n        } else if (mediaPlayerModel.getLowLatencyEnabled()) {\n            delay = 0;\n        } else if (mediaPlayerModel.getLiveDelay()) {\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n        } else if (!isNaN(fragmentDuration)) {\n            delay = fragmentDuration * mediaPlayerModel.getLiveDelayFragmentCount();\n        } else {\n            delay = streamInfo.manifestInfo.minBufferTime * 2;\n        }\n\n        if (mpd.availabilityStartTime) {\n            availabilityStartTime = mpd.availabilityStartTime.getTime();\n        }\n\n        if (dvrWindowSize > 0) {\n            // cap target latency to:\n            // - dvrWindowSize / 2 for short playlists\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n            ret = Math.min(delay, targetDelayCapping);\n        } else {\n            ret = delay;\n        }\n        liveDelay = ret;\n        return ret;\n    }\n\n    function getLiveDelay() {\n        return liveDelay;\n    }\n\n    function getCurrentLiveLatency() {\n        if (!isDynamic || isNaN(availabilityStartTime)) {\n            return NaN;\n        }\n        let currentTime = getNormalizedTime();\n        if (isNaN(currentTime) || currentTime === 0) {\n            return 0;\n        }\n\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n    }\n\n    function reset() {\n        liveStartTime = NaN;\n        playOnceInitialized = false;\n        commonEarliestTime = {};\n        liveDelay = 0;\n        availabilityStartTime = 0;\n        bufferedRange = {};\n        if (videoModel) {\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n            eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n            eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n            stopUpdatingWallclockTime();\n            removeAllListeners();\n        }\n        wallclockTimeIntervalId = null;\n        videoModel = null;\n        streamInfo = null;\n        isDynamic = null;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.manifestModel) {\n            manifestModel = config.manifestModel;\n        }\n        if (config.dashManifestModel) {\n            dashManifestModel = config.dashManifestModel;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.uriFragmentModel) {\n            uriFragmentModel = config.uriFragmentModel;\n        }\n    }\n\n    function getStartTimeFromUriParameters() {\n        const fragData = uriFragmentModel.getURIFragmentData();\n        let uriParameters;\n        if (fragData) {\n            uriParameters = {};\n            const r = parseInt(fragData.r, 10);\n            if (r >= 0 && streamInfo && r < streamInfo.manifestInfo.DVRWindowSize && fragData.t === null) {\n                fragData.t = Math.max(Math.floor(Date.now() / 1000) - streamInfo.manifestInfo.DVRWindowSize, (streamInfo.manifestInfo.availableFrom.getTime() / 1000) + streamInfo.start) + r;\n            }\n            uriParameters.fragS = parseFloat(fragData.s);\n            uriParameters.fragT = parseFloat(fragData.t);\n        }\n        return uriParameters;\n    }\n\n    /**\n     * @param {boolean} ignoreStartOffset - ignore URL fragment start offset if true\n     * @param {number} liveEdge - liveEdge value\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function getStreamStartTime(ignoreStartOffset, liveEdge) {\n        let presentationStartTime;\n        let startTimeOffset = NaN;\n\n        if (!ignoreStartOffset) {\n            const uriParameters = getStartTimeFromUriParameters();\n            if (uriParameters) {\n                startTimeOffset = !isNaN(uriParameters.fragS) ? uriParameters.fragS : uriParameters.fragT;\n            } else {\n                startTimeOffset = 0;\n            }\n        } else {\n            startTimeOffset = streamInfo ? streamInfo.start : startTimeOffset;\n        }\n\n        if (isDynamic) {\n            if (!isNaN(startTimeOffset) && streamInfo) {\n                presentationStartTime = startTimeOffset - (streamInfo.manifestInfo.availableFrom.getTime() / 1000);\n\n                if (presentationStartTime > liveStartTime ||\n                    presentationStartTime < (!isNaN(liveEdge) ? (liveEdge - streamInfo.manifestInfo.DVRWindowSize) : NaN)) {\n                    presentationStartTime = null;\n                }\n            }\n            presentationStartTime = presentationStartTime || liveStartTime;\n\n        } else {\n            if (streamInfo) {\n                if (!isNaN(startTimeOffset) && startTimeOffset < Math.max(streamInfo.manifestInfo.duration, streamInfo.duration) && startTimeOffset >= 0) {\n                    presentationStartTime = startTimeOffset;\n                } else {\n                    let earliestTime = commonEarliestTime[streamInfo.id]; //set by ready bufferStart after first onBytesAppended\n                    presentationStartTime = earliestTime !== undefined ? Math.max(earliestTime.audio !== undefined ? earliestTime.audio : 0, earliestTime.video !== undefined ? earliestTime.video : 0, streamInfo.start) : streamInfo.start;\n                }\n            }\n        }\n\n        return presentationStartTime;\n    }\n\n    function getActualPresentationTime(currentTime) {\n        const metrics = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO);\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(metrics);\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n        let actualTime;\n\n        if (!DVRWindow) return NaN;\n        if (currentTime > DVRWindow.end) {\n            actualTime = Math.max(DVRWindow.end - streamInfo.manifestInfo.minBufferTime * 2, DVRWindow.start);\n        } else if (currentTime + 0.250 < DVRWindow.start) {\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n            actualTime = DVRWindow.start;\n        } else {\n            return currentTime;\n        }\n\n        return actualTime;\n    }\n\n    function startUpdatingWallclockTime() {\n        if (wallclockTimeIntervalId !== null) return;\n\n        const tick = function () {\n            onWallclockTime();\n        };\n\n        wallclockTimeIntervalId = setInterval(tick, mediaPlayerModel.getWallclockTimeUpdateInterval());\n    }\n\n    function stopUpdatingWallclockTime() {\n        clearInterval(wallclockTimeIntervalId);\n        wallclockTimeIntervalId = null;\n    }\n\n    function updateCurrentTime() {\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n        const currentTime = getNormalizedTime();\n        const actualTime = getActualPresentationTime(currentTime);\n\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\n        if (timeChanged) {\n            seek(actualTime);\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error) return;\n\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n        const info = representationInfo.mediaInfo.streamInfo;\n\n        if (streamInfo.id !== info.id) return;\n        streamInfo = info;\n\n        updateCurrentTime();\n    }\n\n    function onCanPlay() {\n        eventBus.trigger(Events.CAN_PLAY);\n    }\n\n    function onPlaybackStart() {\n        logger.info('Native video element event: play');\n        updateCurrentTime();\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_STARTED, {\n            startTime: getTime()\n        });\n    }\n\n    function onPlaybackWaiting() {\n        logger.info('Native video element event: waiting');\n        eventBus.trigger(Events.PLAYBACK_WAITING, {\n            playingTime: getTime()\n        });\n    }\n\n    function onPlaybackPlaying() {\n        logger.info('Native video element event: playing');\n        eventBus.trigger(Events.PLAYBACK_PLAYING, {\n            playingTime: getTime()\n        });\n    }\n\n    function onPlaybackPaused() {\n        logger.info('Native video element event: pause');\n        eventBus.trigger(Events.PLAYBACK_PAUSED, {\n            ended: getEnded()\n        });\n    }\n\n    function onPlaybackSeeking() {\n        const seekTime = getTime();\n        logger.info('Seeking to: ' + seekTime);\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_SEEKING, {\n            seekTime: seekTime\n        });\n    }\n\n    function onPlaybackSeeked() {\n        logger.info('Native video element event: seeked');\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\n        // Reactivate 'seeking' event listener (see seek())\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n    }\n\n    function onPlaybackTimeUpdated() {\n        if (streamInfo) {\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\n                timeToEnd: getTimeToStreamEnd(),\n                time: getTime()\n            });\n        }\n    }\n\n    function updateLivePlaybackTime() {\n        const now = Date.now();\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n            lastLivePlaybackTime = now;\n            onPlaybackTimeUpdated();\n        }\n    }\n\n    function onPlaybackProgress() {\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\n    }\n\n    function onPlaybackRateChanged() {\n        const rate = getPlaybackRate();\n        logger.info('Native video element event: ratechange: ', rate);\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, {\n            playbackRate: rate\n        });\n    }\n\n    function onPlaybackMetaDataLoaded() {\n        logger.info('Native video element event: loadedmetadata');\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\n        startUpdatingWallclockTime();\n    }\n\n    // Event to handle the native video element ended event\n    function onNativePlaybackEnded() {\n        logger.info('Native video element event: ended');\n        pause();\n        stopUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_ENDED, {'isLast': streamController.getActiveStreamInfo().isLast});\n    }\n\n    // Handle DASH PLAYBACK_ENDED event\n    function onPlaybackEnded(e) {\n        if (wallclockTimeIntervalId && e.isLast) {\n            // PLAYBACK_ENDED was triggered elsewhere, react.\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n            videoModel.setCurrentTime(getStreamEndTime());\n            pause();\n            stopUpdatingWallclockTime();\n        }\n    }\n\n    function onPlaybackError(event) {\n        const target = event.target || event.srcElement;\n        eventBus.trigger(Events.PLAYBACK_ERROR, {\n            error: target.error\n        });\n    }\n\n    function onWallclockTime() {\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\n            isDynamic: isDynamic,\n            time: new Date()\n        });\n\n        // Updates playback time for paused dynamic streams\n        // (video element doesn't call timeupdate when the playback is paused)\n        if (getIsDynamic() && isPaused()) {\n            updateLivePlaybackTime();\n        }\n    }\n\n    function checkTimeInRanges(time, ranges) {\n        if (ranges && ranges.length > 0) {\n            for (let i = 0, len = ranges.length; i < len; i++) {\n                if (time >= ranges.start(i) && time < ranges.end(i)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function onPlaybackProgression() {\n        if (\n            isDynamic &&\n            mediaPlayerModel.getLowLatencyEnabled() &&\n            mediaPlayerModel.getCatchUpPlaybackRate() > 0 &&\n            !isPaused() &&\n            !isSeeking()\n        ) {\n            if (needToCatchUp()) {\n                startPlaybackCatchUp();\n            } else {\n                stopPlaybackCatchUp();\n            }\n        }\n    }\n\n    function getBufferLevel() {\n        let bufferLevel = null;\n        streamController.getActiveStreamProcessors().forEach(p => {\n            const bl = p.getBufferLevel();\n            if (bufferLevel === null) {\n                bufferLevel = bl;\n            } else {\n                bufferLevel = Math.min(bufferLevel, bl);\n            }\n        });\n\n        return bufferLevel;\n    }\n\n    function needToCatchUp() {\n        return mediaPlayerModel.getCatchUpPlaybackRate() > 0 && getTime() > 0 &&\n            Math.abs(getCurrentLiveLatency() - mediaPlayerModel.getLiveDelay()) > mediaPlayerModel.getLowLatencyMinDrift();\n    }\n\n    function startPlaybackCatchUp() {\n        if (videoModel) {\n            const cpr = mediaPlayerModel.getCatchUpPlaybackRate();\n            const liveDelay = mediaPlayerModel.getLiveDelay();\n            const deltaLatency = getCurrentLiveLatency() - liveDelay;\n            const d = deltaLatency * 5;\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n            let newRate = (1 - cpr) + s;\n            // take into account situations in which there are buffer stalls,\n            // in which increasing playbackRate to reach target latency will\n            // just cause more and more stall situations\n            if (playbackStalled) {\n                const bufferLevel = getBufferLevel();\n                if (bufferLevel > liveDelay / 2) {\n                    playbackStalled = false;\n                } else if (deltaLatency > 0) {\n                    newRate = 1.0;\n                }\n            }\n\n            // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n            if (Math.abs(videoModel.getPlaybackRate() - newRate) > minPlaybackRateChange) {\n                videoModel.setPlaybackRate(newRate);\n            }\n\n            if (mediaPlayerModel.getLowLatencyMaxDriftBeforeSeeking() > 0 && !isLowLatencySeekingInProgress &&\n                deltaLatency > mediaPlayerModel.getLowLatencyMaxDriftBeforeSeeking()) {\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n                isLowLatencySeekingInProgress = true;\n                seekToLive();\n            } else {\n                isLowLatencySeekingInProgress = false;\n            }\n        }\n    }\n\n    function stopPlaybackCatchUp() {\n        if (videoModel) {\n            videoModel.setPlaybackRate(1.0);\n        }\n    }\n\n    function onBytesAppended(e) {\n        let earliestTime,\n            initialStartTime;\n        let ranges = e.bufferedRanges;\n        if (!ranges || !ranges.length) return;\n        if (commonEarliestTime[streamInfo.id] && commonEarliestTime[streamInfo.id].started === true) {\n            //stream has already been started.\n            return;\n        }\n\n        const type = e.sender.getType();\n\n        if (bufferedRange[streamInfo.id] === undefined) {\n            bufferedRange[streamInfo.id] = [];\n        }\n\n        bufferedRange[streamInfo.id][type] = ranges;\n\n        if (commonEarliestTime[streamInfo.id] === undefined) {\n            commonEarliestTime[streamInfo.id] = [];\n            commonEarliestTime[streamInfo.id].started = false;\n        }\n\n        if (commonEarliestTime[streamInfo.id][type] === undefined) {\n            commonEarliestTime[streamInfo.id][type] = Math.max(ranges.start(0), streamInfo.start);\n        }\n\n        const hasVideoTrack = streamController.isTrackTypePresent(Constants.VIDEO);\n        const hasAudioTrack = streamController.isTrackTypePresent(Constants.AUDIO);\n\n        initialStartTime = getStreamStartTime(false);\n        if (hasAudioTrack && hasVideoTrack) {\n            //current stream has audio and video contents\n            if (!isNaN(commonEarliestTime[streamInfo.id].audio) && !isNaN(commonEarliestTime[streamInfo.id].video)) {\n\n                if (commonEarliestTime[streamInfo.id].audio < commonEarliestTime[streamInfo.id].video) {\n                    // common earliest is video time\n                    // check buffered audio range has video time, if ok, we seek, otherwise, we wait some other data\n                    earliestTime = commonEarliestTime[streamInfo.id].video > initialStartTime ? commonEarliestTime[streamInfo.id].video : initialStartTime;\n                    ranges = bufferedRange[streamInfo.id].audio;\n                } else {\n                    // common earliest is audio time\n                    // check buffered video range has audio time, if ok, we seek, otherwise, we wait some other data\n                    earliestTime = commonEarliestTime[streamInfo.id].audio > initialStartTime ? commonEarliestTime[streamInfo.id].audio : initialStartTime;\n                    ranges = bufferedRange[streamInfo.id].video;\n                }\n                if (checkTimeInRanges(earliestTime, ranges)) {\n                    if (!isSeeking() && !compatibleWithPreviousStream && earliestTime !== 0) {\n                        seek(earliestTime, true, true);\n                    }\n                    commonEarliestTime[streamInfo.id].started = true;\n                }\n            }\n        } else {\n            //current stream has only audio or only video content\n            if (commonEarliestTime[streamInfo.id][type]) {\n                earliestTime = commonEarliestTime[streamInfo.id][type] > initialStartTime ? commonEarliestTime[streamInfo.id][type] : initialStartTime;\n                if (!isSeeking() && !compatibleWithPreviousStream) {\n                    seek(earliestTime, false, true);\n                }\n                commonEarliestTime[streamInfo.id].started = true;\n            }\n        }\n    }\n\n    function onFragmentLoadProgress(e) {\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n        if (e.stream === false && mediaPlayerModel.getLowLatencyEnabled() && !isNaN(e.request.duration)) {\n            const minDelay = 1.2 * e.request.duration;\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n                mediaPlayerModel.setLiveDelay(minDelay);\n            }\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        // do not stall playback when get an event from Stream that is not active\n        if (e.streamInfo.id !== streamInfo.id) return;\n\n        if (mediaPlayerModel.getLowLatencyEnabled()) {\n            if (e.state === BufferController.BUFFER_EMPTY && !isSeeking()) {\n                if (!playbackStalled) {\n                    playbackStalled = true;\n                    stopPlaybackCatchUp();\n                }\n            }\n        } else {\n            videoModel.setStallState(e.mediaType, e.state === BufferController.BUFFER_EMPTY);\n        }\n    }\n\n\n    function onPlaybackStalled(e) {\n        eventBus.trigger(Events.PLAYBACK_STALLED, {\n            e: e\n        });\n    }\n\n    function addAllListeners() {\n        videoModel.addEventListener('canplay', onCanPlay);\n        videoModel.addEventListener('play', onPlaybackStart);\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\n        videoModel.addEventListener('playing', onPlaybackPlaying);\n        videoModel.addEventListener('pause', onPlaybackPaused);\n        videoModel.addEventListener('error', onPlaybackError);\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.addEventListener('progress', onPlaybackProgress);\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.addEventListener('stalled', onPlaybackStalled);\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\n    }\n\n    function removeAllListeners() {\n        videoModel.removeEventListener('canplay', onCanPlay);\n        videoModel.removeEventListener('play', onPlaybackStart);\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\n        videoModel.removeEventListener('pause', onPlaybackPaused);\n        videoModel.removeEventListener('error', onPlaybackError);\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.removeEventListener('progress', onPlaybackProgress);\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n        getStreamStartTime: getStreamStartTime,\n        getTimeToStreamEnd: getTimeToStreamEnd,\n        getTime: getTime,\n        getNormalizedTime: getNormalizedTime,\n        getPlaybackRate: getPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        getIsDynamic: getIsDynamic,\n        getStreamController: getStreamController,\n        setLiveStartTime: setLiveStartTime,\n        getLiveStartTime: getLiveStartTime,\n        computeLiveDelay: computeLiveDelay,\n        getLiveDelay: getLiveDelay,\n        getCurrentLiveLatency: getCurrentLiveLatency,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isSeeking: isSeeking,\n        seek: seek,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\n"]}